<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python多进程拷贝文件]]></title>
    <url>%2F2019%2F07%2F18%2Fpython%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Python多进程拷贝实现思路 创建可获取目标文件或文件夹中的所有文件夹和文件的列表的函数 创建拷贝文件的函数 主函数创建进程池和消息队列 获取文件夹和文件列表先判断路径是文件还是文件夹，是文件直接添加至文件列表；文件夹的话，添加至文件夹列表，利用os.listdir()函数列出当前文件夹内的所有文件，循环遍历，拼接源地址，然后作为参数递归循环； 12345678910111213def get_file_list(source_path): """ 遍历该文件夹中的所有文件和文件夹 获取源文件夹中的文件夹、文件列表 """ if os.path.isdir(source_path): S_Dir_List.append(source_path) for temp in os.listdir(source_path): # 拼接源地址+文件名，变成新地址，再进行递归 new_source_path = os.path.join(source_path, temp) get_file_list(new_source_path) else: S_File_List.append(source_path) 拷贝文件传入的参数 queue： 消息队列，用于主函数计数 source_file： 源文件路径 dest_file： 目标文件的路径 循环读取写入，是防止文件过大，读写卡死 12345678910111213141516171819def copy_file(queue, source_file, dest_file): """ 复制文件从源文件 """ try: fr = open(source_file,"rb") fw = open(dest_file,"wb") except Exception as e: print("error:" + str(e)) else: while True: content = fr.read(4096) if not content: break fw.write(content) fr.close() fw.close() # 将文件名传入队列消息，代表复制完成 queue.put(source_file) 源代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from multiprocessing import Manager, Poolimport osimport time# 源文件列表 文件夹列表S_File_List = []S_Dir_List = []def get_file_list(source_path): """ 遍历该文件夹中的所有文件和文件夹 获取源文件夹中的文件夹、文件列表 """ if os.path.isdir(source_path): S_Dir_List.append(source_path) for temp in os.listdir(source_path): # 拼接源地址+文件名，变成新地址，再进行递归 new_source_path = os.path.join(source_path, temp) get_file_list(new_source_path) else: S_File_List.append(source_path)def copy_file(queue, source_file, dest_file): """ 复制文件从源文件 """ try: fr = open(source_file,"rb") fw = open(dest_file,"wb") except Exception as e: print("error:" + str(e)) else: while True: content = fr.read(4096) if not content: break fw.write(content) fr.close() fw.close() # 将文件名传入队列消息，代表复制完成 queue.put(source_file)def main(): # 获取源文件夹中的所有文件和文件夹 source_path = input("请输入要拷贝的源文件路径：") get_file_list(source_path) # 创建目标文件夹 dest_path = source_path + "-[复件]" for sour_dir in S_Dir_List: # 替换文件的路径 dest_dir = sour_dir.replace(source_path, dest_path) try: os.mkdir(dest_dir) except Exception as e: print("error" + str(e)) # 创建进程池 pool = Pool(5) queue = Manager().Queue() # 创建队列消息用来计数 for sour_file in S_File_List: # 替换文件的路径 dest_file = sour_file.replace(source_path,dest_path) # print(dest_file) # 往进程池添加任务 pool.apply_async(copy_file, args=(queue, sour_file, dest_file)) pool.close() # 关闭进程池 pool.join() # 等待子进程结束 # 显示复制文件的进度 filesNums = len(S_File_List) COUNT = 0 while True: queue.get() COUNT += 1 Rate = COUNT/filesNums print("\r当前进度： %.2f%%"%(Rate*100), end='') if Rate &gt;= 1: break print("\n...Done")if __name__ == '__main__': main()]]></content>
      <categories>
        <category>python系统编程</category>
      </categories>
      <tags>
        <tag>-python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的DOS命令]]></title>
    <url>%2F2019%2F07%2F16%2F%E5%B8%B8%E8%A7%81%E7%9A%84DOS%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[介绍常用的dos命令 1.Net命令在Dos命令提示符下输入 “net” 、 “net /?” 或 “net help”，可以获得帮助信息。1234NET [ ACCOUNTS | COMPUTER | CONFIG | CONTINUE | FILE | GROUP | HELP | HELPMSG | LOCALGROUP | PAUSE | SESSION | SHARE | START | STATISTICS | STOP | TIME | USE | USER | VIEW ] net view 作用：显示域列表、计算机列表或指定计算机的共享资源列表。 1命令格式：Net view [\\computername | /domain[:domainname]] 参数： 不带参数的 “net view” ，显示当前域的计算机列表 “\computername” ，指定要查看其共享资源的计算机 “/domain[:domainname]” ，指定要查看其可用计算机的域如：12Net view \\ABC #查看ABC计算机的共享资源列表Net view /domain:XYZ #查看XYZ域中的机器列表。 net user 作用：添加或更改用户帐号或显示用户帐号信息。 1命令格式：Net user [username [password | *] [options]] [/domain] 参数： 不带参数的“Net user” ，查看计算机上的用户帐号列表 “username” 用于添加、删除更改或查看用户的账号名 “password” 用于为用户账号分配或更改密码 “*” 提示输入密码 “/domain” 在计算机主域的主域控制器中执行操作 “net user” 命令一般配合 “net loaclgroup”命令使用，用于添加用户，以及提升yoghurt到管理员组中。 123命令格式：net loaclgroup [groupname [/COMMENT:&quot;text&quot;]] [/DOMAIN] groupname &#123;/ADD [/COMMENT:&quot;text&quot;] | /DELETE&#125; [/DOMAIN] groupname name [...] &#123;/ADD | /DELETE&#125; [/DOMAIN] 参数： 不带参数的 “net localgroup” 命令，可显示服务器和计算机的本地组名称 “groupname” 表示添加、扩充或删除的本地组名称 “/COMMENT:”text”” 表示为新建或现有的组添加注释 “/DOMAIN” 表示在当前域的主域控制器中执行操作，否则仅在本地计算机上执行操作 “name […]” 列出要添加到本地组或从本地组删除的一个或多个用户名或组名 “/add” 用于将全局组名或用户名添加到本地组中 “/delete” 用于从本地组中删除组名或用户名如，将用户名“test”, 密码“12345678” 的用户添加至管理员组中 1234net user # 查看用户net user test 12345678 /add # 添加用户net localgroup Administrators test /add # 添加至管理员组net localgroup Administrators # 查看管理员组 net use]]></content>
      <categories>
        <category>windows基础</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>dos命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动挖掘漏洞---SQL注入（一）]]></title>
    <url>%2F2019%2F07%2F15%2F%E6%89%8B%E5%8A%A8%E6%8C%96%E6%8E%98%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SQL注入 所谓SQL注入，就是通过使用POST或GET方式把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。 程序存在SQL注入，追其原因，就是代码或编码的不完善 如常见的用户登陆，举个简单的例子： 1SELECT * FROM users WHERE user='uname' AND password='pass' 一般情况下，通过布尔判断，只要SQL语句为真，即为登陆成功。这句SQL语句意思是查询users表中是否存在用户名为uname，密码为pass的用户，语句为真即登陆成功，语句为假即登陆失败。 若在不知道用户名和密码的情况下，我们可以将【pass】替换为【’ or 1=1 – 】 1SELECT * FROM users WHERE user='uname' AND password='' or 1=1 -- ' 注:【– 】 可以用来注释掉后边的语句。根据布尔判断，这句话就可以成真了，登陆成功 一些简单判断是否存在SQL注入的方法： 基于报错的检测方法(low) ‘ “ % ( ) 基于布尔的检测 1’ and ‘1’=’1 &emsp;或&emsp; 1’ and ‘1 1’ and ‘1’=’2 &emsp;或&emsp; 1’ and ‘0 表列数/显示信息位于哪一列 ‘ order by 9–+ #按查询列号 （如select * from table order by n 表示select里面的第n个字段） select * 时表字段数=查询字段数 联合查询 ‘ union select 1,2–+ ‘ union all select database(),2–+（联合查询前后语句的查询字段数要相等） 下面用metasploitable中的dvwa(low)进行演示这个提交表单作用是根据用户输入id ，返回用户的first_name、subname； 当我们不根据规则，输入一些不规范的数据，如“’”网页报错了，并返回了信息，可以判断是MySQL的数据库，错误原因是引号无法闭合。也可以利用布尔值判断当输入1’ and ‘1’=’1 ，语句为真，程序执行 ；1’ and ‘1’=’2 ，语句为假，程序不执行； 基于这些判断，就可以认为存在SQL注入现在可以猜解select中的字段个数，利用“order by”语句 可以从1开始（注意空格）当数值到3时，网页报错 “Unknown column ‘3’ in ‘order clause’”说明，查询的字段个数为2； 然后我们可以利用联合查询语句，查询一些有用的信息因为union查询前后查询字段个数要相等，这里用1，2代替，1，2也可以替换成一些函数 ‘ union select database(),substring_index(user(),”@”,1) – （字符串截取substring_index(str, “分隔符”，计数)）利用hackbar构造语句提交 常用可SQL查询内容： DB用户：user() DB版本：version() 全局函数：@@datadir、@@hostname、@@VERSION、@@version_compile_os 当前库： database() ASCII转字符：char() 连接字符串：CONCAT_WS(CHAR(32,58,32),user(),database(),version()) 计算哈希：md5() Mysql 数据结构 information_schema 使用连接字符串函数查询（ascii码中，32为空格，58为冒号：） Mysql数据结构 对表的meta data的查询需要使用information_schema.tables， table_schema是数据库的名称，table_name是具体的表名，table_type指的是表的类型MySQL：所有的元数据都保存在一张元数据表【information_schema】 查看所有库所有表/统计库中表的数量1' union select table_name,table_schema from information_schema.tables -- 查询所有数据库中的所有表 1' union select table_schema,count(*) from information_schema.tables group by table_schema -- 统计每个数据库中的表数量 Dvwa库中的表名1' union select table_schema,table_name from information_schema.tables where table_schema='dvwa' -- 查询dvwa库的表 查询列名字段1' union select table_name,column_name from information_schema.columns where table_schema="dvwa" and table_name="users" -- 查询users表中的列名字段 查询表中数据1' union select user,password from dvwa.users -- 查询users表中的用户名、密码 到这里，用户名和密码都知道了，但是密码是加密过的，我们可以通过在线或离线的破解可以利用一些工具对密码使用的加密方式进行判断 1root@kali:/# hash-identifier 判断出来是md5哈希加密这里用离线破解的方式先将用户名密码保存至文件夹，格式如下用john进行破解 1root@kali:/# john --format=raw-MD5 dvwa.txt 如果出现以下错误，说明命令已经执行过了 123Using default input encoding: UTF-8Loaded 5 password hashes with no different salts (Raw-MD5 [MD5 128/128 SSE2 4x3])No password hashes left to crack (see FAQ) 命令执行后，会在“~”家目录里生成.john/的文件夹，里面有日志和破解后的明文文件要再执行，删除这两个文件即可]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>Web渗透</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程池Pool & 进程间通信Queue]]></title>
    <url>%2F2019%2F07%2F12%2F%E8%BF%9B%E7%A8%8B%E6%B1%A0Pool-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1Queue%2F</url>
    <content type="text"><![CDATA[进程池Pool当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。 初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务，请看下面的实例： 1234567891011121314151617181920212223242526from multiprocessing import Poolimport osimport randomimport timedef worker(num): # for i in range(5): # print('---进程号: %d ---num=%d----'%(os.getpid(), num)) # time.sleep(1) print('---进程号: %d ---num=%d----'%(os.getpid(), num)) time.sleep(2)if __name__ == '__main__': pool = Pool(3) # 创建进程池， 进程数=3 for i in range(10): print("----添加任务：%d-----"%i) pool.apply_async(worker, (i,)) # 非堵塞式添加 # pool.apply(worker, (i,)) # 堵塞式添加 # 向进程池中添加任务数=10， 若添加的函数有参数，以元组的方式传入 pool.close() # 关闭进程池，不再添加新任务 pool.join() # 等待子进程都结束，主进程再结束 # 不然 主进程会在添加完任务后就结束 执行结果: 1234567891011121314151617181920----添加任务：0---------添加任务：1---------添加任务：2---------添加任务：3---------添加任务：4---------添加任务：5---------添加任务：6---------添加任务：7---------添加任务：8---------添加任务：9--------进程号: 13608 ---num=0-------进程号: 17324 ---num=1-------进程号: 2716 ---num=2-------进程号: 13608 ---num=3-------进程号: 17324 ---num=4-------进程号: 2716 ---num=5-------进程号: 13608 ---num=6-------进程号: 17324 ---num=7-------进程号: 2716 ---num=8-------进程号: 13608 ---num=9---- 非堵塞式添加和堵塞式添加阻塞与非阻塞指的是程序的两种运行状态 阻塞：遇到IO就发生阻塞，程序一旦遇到阻塞操作就会停在原地，并且立刻释放CPU资源 非阻塞（就绪态或运行态）：没有遇到IO操作，或者通过某种手段让程序即便是遇到IO操作也不会停在原地，执行其他操作，力求尽可能多的占有CPU pool.apply 和 pool.apply_async 的区别 apply ：阻塞式，需要等待当前子进程执行完毕后，在执行下一个子进程，耗时长。 apply_async ： 非阻塞式，async是异步的意思，不用等待当前运行的子进程执行完毕，随时根据系统调度来进行进程切换，耗时短。 进程间通信QueueProcess之间有时需要通信，操作系统提供了很多机制来实现进程间的通信。multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序 Queue的使用在内存中开辟一个队列模型，用来存放消息，任何拥有队列对象的进程都可以进行消息存放和取出 初始化Queue()对象时（例如：q=Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）； Queue.qsize()：返回当前队列包含的消息数量； Queue.empty()：如果队列为空，返回True，反之False ； Queue.full()：如果队列满了，返回True,反之False； Queue.get([block[,timeout]]):获取队列中的一条消息，然后将其从列队中移除，block默认值为True； 1)如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出”Queue.Empty”异常； （如 Queue.get(block=True,timeout=2)） 2）如果block值为False，消息列队如果为空，则会立刻抛出”Queue.Empty”异常； Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True； 1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full”异常；（如 Queue.put(‘xxx’block=True,timeout=2)） 2）如果block值为False，消息列队如果没有空间可写入，则会立刻抛出”Queue.Full”异常； Queue.get_nowait()：相当Queue.get(False)； Queue.put_nowait(item)：相当Queue.put(item, False)； Queue实例在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据： 1234567891011121314151617181920212223242526272829303132from multiprocessing import Process, Queueimport os, timedef write_data(queue): for value in ['Message1', 'Message2', 'Message3']: print("Put %s to queue..." %value) queue.put(value) # 加入消息队列 time.sleep(2)def read_data(queue): while True: if not queue.empty(): # 判断消息队列是否为空 value = queue.get(True) # 默认值为True，获取消息队列中的一个值 print("Get %s to queue..." %value) time.sleep(2) else: breakif __name__ == '__main__': # 当前父进程创建Queue,供两个子进程读写 q = Queue() # 初始化队列 ，未传入参数时，即可不受限制接受消息 pw = Process(target=write_data, args=(q,)) # 创建写进程 pr = Process(target=read_data, args=(q,)) # 创建读进程 # 写进程pw开启 pw.start() # 等待写进程pw结束 pw.join() # 读进程pr开启 pr.start() # 等待度进程pr结束 pr.join() print("...Done") 执行结果： 1234567Put Message1 to queue...Put Message2 to queue...Put Message3 to queue...Get Message1 to queue...Get Message2 to queue...Get Message3 to queue......Done 进程池通信Queue如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()，否则会得到一条如下的错误信息： RuntimeError: Queue objects should only be shared between processes through inheritance. 下面的实例演示了进程池中的进程如何通信： 123456789101112131415161718192021222324from multiprocessing import Manager, Poolimport os, timedef reader(queue): print("reader启动(%s),父进程为(%s)"%(os.getpid(),os.getppid())) for i in range(queue.qsize()): print("reader从Queue获取到消息：%s "% queue.get(True)) def writer(queue): print("writer启动(%s),父进程为(%s)"%(os.getpid(),os.getppid())) for i in ['Message1', 'Message2', 'Message3', 'Message4']: queue.put(i)if __name__ == '__main__': print("(%s) start"%os.getpid()) q = Manager().Queue() #使用Manager中的Queue来初始化 po = Pool() #使用阻塞模式创建进程，这样就不需要在reader中使用死循环了，可以让writer完全执行完成后，再用reader去读取 po.apply(writer,(q,)) po.apply(reader,(q,)) po.close() po.join() print("(%s) End"%os.getpid()) 执行结果： 12345678(12196) startwriter启动(6812),父进程为(12196)reader启动(7992),父进程为(12196)reader从Queue获取到消息：Message1reader从Queue获取到消息：Message2reader从Queue获取到消息：Message3reader从Queue获取到消息：Message4(12196) End]]></content>
      <categories>
        <category>python系统编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python创建进程的三种方式]]></title>
    <url>%2F2019%2F07%2F09%2FPython%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[python创建进程的三种方式 fork创建 multiprocessing 模块 Process类 继承Process类, 子类创建 1.fork创建os.fork方法会创建出一个子进程，原进程（父进程）返回一个大于零的值（即ret &gt; 0），这个值恰好是子进程的pid；而创建的新的子进程返回的值为零（即ret = 0）fork方法创建进程不适用于window系统，window系统中没有这个系统调用 1234567891011import osret = os.fork() if ret == 0: #子进程 print("Sub process pid = %d, Sub process ppid = %d" % (os.getpid(), os.getppid()))else: #父进程 print("Parent Process ret = %d" % ret) print("Parent Process pid = %d" % os.getpid()) 执行效果: 123Parent Process ret = 2757Parent Process pid = 2756Sub process pid = 2757, Sub process ppid = 2756 2.multiprocessing 模块 Process类通过Multiprocessing模块中的Process类,创建Process对象,target参数传入的是子进程执行的函数戴码, 通过start方法开启子进程 123456789101112131415161718from multiprocessing import Processimport timeimport osdef test(): time.sleep(2) print('子进程Process (pid:&#123;&#125;) starting...'.format(os.getpid())) if __name__ == '__main__': p = Process(target=test) p.start() p.join(3) # （堵塞）等待子进程结束，再执行父进程 join(timout) 超时时间 # 传入 1s 父进程等待1s，若超过1秒，子进程未结束，父进程先运行 # 传入3s 等待时间未结束，子进程结束，父进程运行 # 如果没有传入参数 父进程只有等待子进程结束，再运行 print('父进程Process (pid:&#123;&#125;) starting...'.format(os.getpid())) 注:fork方法创建的进程，主进程不会等待子进程结束再结束Process类创建的进程，默认情况主进程会等待子进程都结束，再结束 3.继承Process类, 子类创建创建一个子类, 继承Process类, 重写run方法, 实例出一个对象, 调用start方法运行子进程,调用start方法，会自动调用run方法 1234567891011121314151617from multiprocessing import Processimport timeimport osclass NewProcess(Process): #继承Process类 def run(self): # 重写run方法 while True: print('子进程Process (pid:&#123;&#125;) starting...'.format(os.getpid())) time.sleep(1)if __name__ == '__main__': p = NewProcess() # 实例化一个子进程对象 p.start() # 运行子进程的代码(即run方法) while True: print('父进程Process (pid:&#123;&#125;) starting...'.format(os.getpid())) time.sleep(1)]]></content>
      <categories>
        <category>python系统编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2019%2F06%2F30%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这是我的第一篇博客 Markdown常用的语法 Markdown常用语法1.标题 1234567语法:# 一级标题## 二级标题### 三级标题#### 四级级标题##### 五级标题###### 六级标题 2.字体 1加粗: *字体* 效果: 字体 1斜体: **字体** 效果: 字体 1斜体加粗: ***字体*** 效果: 字体 1删除线: ~~字体~~ 效果: 字体 3.代码格式 编程语言可以更换格式: 效果： 1print("hello,world~"); 4.插入图片 在根目录sourse文件夹里创建一个images文件夹, 将图片放在 source/images/ 下 1格式: ![image](/images/xxx.jpg) 效果如下: 5.引用 在引用的文字前加&gt;，可以无限加… 1引用: &gt; 效果: 引用 引用 引用 引用 6.分割线 三个或者三个以上的 - 或者 * 都可以 1格式: ---或*** 7.超链接 12格式:[超链接名](超链接地址 "超链接title") 效果:百度淘宝 8.列表 1234无序列表: * 这是一个列表 + 这是一个列表 - 这是一个列表 效果: 这是一个列表 这是一个列表 这是一个列表 12345有序列表: 1. 这是一个列表 2. 这是一个列表 3. 这是一个列表 4. 这是一个列表 效果: 这是一个列表 这是一个列表 这是一个列表 这是一个列表 9.表格 表格内容对齐方式: -： 左对齐:-: ： 居中对齐-: ： 右对齐 123456格式: 表头1 | 表头2 | 表头3 | 表头4 - | :- | :-: | -: | 默认左对齐|左对齐|居中对齐|右对齐 默认左对齐|左对齐|居中对齐|右对齐 默认左对齐|左对齐|居中对齐|右对齐 效果: 表头1 表头2 表头3 表头4 默认左对齐 左对齐 居中对齐 右对齐 默认左对齐 左对齐 居中对齐 右对齐 默认左对齐 左对齐 居中对齐 右对齐 10.全文阅读在文章要不显示的部分前，添加以下内容 1格式: &lt;!-- more --&gt; markdown语法进阶1.字体、大小、颜色123456789语法:&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt; &lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt; &lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt; &lt;font color=red&gt;我是红色&lt;/font&gt; &lt;font color=#008000&gt;我是绿色&lt;/font&gt; &lt;font color=Blue&gt;我是蓝色&lt;/font&gt; &lt;font size=5&gt;我是尺寸&lt;/font&gt; &lt;font face=&quot;黑体&quot; color=green size=5&gt;我是黑体，绿色，尺寸为5&lt;/font&gt; 我是黑体字我是微软雅黑我是华文彩云我是红色我是绿色我是蓝色我是尺寸我是黑体，绿色，尺寸为5 2.文字背景1&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=yellow&gt;文字背景&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 文字背景]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
